
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Patients
 * 
 */
export type Patients = $Result.DefaultSelection<Prisma.$PatientsPayload>
/**
 * Model Doctors
 * 
 */
export type Doctors = $Result.DefaultSelection<Prisma.$DoctorsPayload>
/**
 * Model Departments
 * 
 */
export type Departments = $Result.DefaultSelection<Prisma.$DepartmentsPayload>
/**
 * Model Appointments
 * 
 */
export type Appointments = $Result.DefaultSelection<Prisma.$AppointmentsPayload>
/**
 * Model Rooms
 * 
 */
export type Rooms = $Result.DefaultSelection<Prisma.$RoomsPayload>
/**
 * Model MedicalHistory
 * 
 */
export type MedicalHistory = $Result.DefaultSelection<Prisma.$MedicalHistoryPayload>
/**
 * Model Diagnosis
 * 
 */
export type Diagnosis = $Result.DefaultSelection<Prisma.$DiagnosisPayload>
/**
 * Model Medications
 * 
 */
export type Medications = $Result.DefaultSelection<Prisma.$MedicationsPayload>
/**
 * Model Treatments
 * 
 */
export type Treatments = $Result.DefaultSelection<Prisma.$TreatmentsPayload>
/**
 * Model Insurance
 * 
 */
export type Insurance = $Result.DefaultSelection<Prisma.$InsurancePayload>
/**
 * Model LabTests
 * 
 */
export type LabTests = $Result.DefaultSelection<Prisma.$LabTestsPayload>
/**
 * Model Bills
 * 
 */
export type Bills = $Result.DefaultSelection<Prisma.$BillsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Patients
 * const patients = await prisma.patients.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Patients
   * const patients = await prisma.patients.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.patients`: Exposes CRUD operations for the **Patients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patients.findMany()
    * ```
    */
  get patients(): Prisma.PatientsDelegate<ExtArgs>;

  /**
   * `prisma.doctors`: Exposes CRUD operations for the **Doctors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctors.findMany()
    * ```
    */
  get doctors(): Prisma.DoctorsDelegate<ExtArgs>;

  /**
   * `prisma.departments`: Exposes CRUD operations for the **Departments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.departments.findMany()
    * ```
    */
  get departments(): Prisma.DepartmentsDelegate<ExtArgs>;

  /**
   * `prisma.appointments`: Exposes CRUD operations for the **Appointments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointments.findMany()
    * ```
    */
  get appointments(): Prisma.AppointmentsDelegate<ExtArgs>;

  /**
   * `prisma.rooms`: Exposes CRUD operations for the **Rooms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.rooms.findMany()
    * ```
    */
  get rooms(): Prisma.RoomsDelegate<ExtArgs>;

  /**
   * `prisma.medicalHistory`: Exposes CRUD operations for the **MedicalHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalHistories
    * const medicalHistories = await prisma.medicalHistory.findMany()
    * ```
    */
  get medicalHistory(): Prisma.MedicalHistoryDelegate<ExtArgs>;

  /**
   * `prisma.diagnosis`: Exposes CRUD operations for the **Diagnosis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Diagnoses
    * const diagnoses = await prisma.diagnosis.findMany()
    * ```
    */
  get diagnosis(): Prisma.DiagnosisDelegate<ExtArgs>;

  /**
   * `prisma.medications`: Exposes CRUD operations for the **Medications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medications.findMany()
    * ```
    */
  get medications(): Prisma.MedicationsDelegate<ExtArgs>;

  /**
   * `prisma.treatments`: Exposes CRUD operations for the **Treatments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treatments
    * const treatments = await prisma.treatments.findMany()
    * ```
    */
  get treatments(): Prisma.TreatmentsDelegate<ExtArgs>;

  /**
   * `prisma.insurance`: Exposes CRUD operations for the **Insurance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insurances
    * const insurances = await prisma.insurance.findMany()
    * ```
    */
  get insurance(): Prisma.InsuranceDelegate<ExtArgs>;

  /**
   * `prisma.labTests`: Exposes CRUD operations for the **LabTests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabTests
    * const labTests = await prisma.labTests.findMany()
    * ```
    */
  get labTests(): Prisma.LabTestsDelegate<ExtArgs>;

  /**
   * `prisma.bills`: Exposes CRUD operations for the **Bills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills
    * const bills = await prisma.bills.findMany()
    * ```
    */
  get bills(): Prisma.BillsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.19.1
   * Query Engine version: 69d742ee20b815d88e17e54db4a2a7a3b30324e3
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Patients: 'Patients',
    Doctors: 'Doctors',
    Departments: 'Departments',
    Appointments: 'Appointments',
    Rooms: 'Rooms',
    MedicalHistory: 'MedicalHistory',
    Diagnosis: 'Diagnosis',
    Medications: 'Medications',
    Treatments: 'Treatments',
    Insurance: 'Insurance',
    LabTests: 'LabTests',
    Bills: 'Bills'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "patients" | "doctors" | "departments" | "appointments" | "rooms" | "medicalHistory" | "diagnosis" | "medications" | "treatments" | "insurance" | "labTests" | "bills"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Patients: {
        payload: Prisma.$PatientsPayload<ExtArgs>
        fields: Prisma.PatientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload>
          }
          findFirst: {
            args: Prisma.PatientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload>
          }
          findMany: {
            args: Prisma.PatientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload>[]
          }
          create: {
            args: Prisma.PatientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload>
          }
          createMany: {
            args: Prisma.PatientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload>[]
          }
          delete: {
            args: Prisma.PatientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload>
          }
          update: {
            args: Prisma.PatientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload>
          }
          deleteMany: {
            args: Prisma.PatientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientsPayload>
          }
          aggregate: {
            args: Prisma.PatientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatients>
          }
          groupBy: {
            args: Prisma.PatientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientsCountArgs<ExtArgs>
            result: $Utils.Optional<PatientsCountAggregateOutputType> | number
          }
        }
      }
      Doctors: {
        payload: Prisma.$DoctorsPayload<ExtArgs>
        fields: Prisma.DoctorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          findFirst: {
            args: Prisma.DoctorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          findMany: {
            args: Prisma.DoctorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>[]
          }
          create: {
            args: Prisma.DoctorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          createMany: {
            args: Prisma.DoctorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>[]
          }
          delete: {
            args: Prisma.DoctorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          update: {
            args: Prisma.DoctorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          deleteMany: {
            args: Prisma.DoctorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorsPayload>
          }
          aggregate: {
            args: Prisma.DoctorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctors>
          }
          groupBy: {
            args: Prisma.DoctorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorsCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorsCountAggregateOutputType> | number
          }
        }
      }
      Departments: {
        payload: Prisma.$DepartmentsPayload<ExtArgs>
        fields: Prisma.DepartmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload>
          }
          findFirst: {
            args: Prisma.DepartmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload>
          }
          findMany: {
            args: Prisma.DepartmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload>[]
          }
          create: {
            args: Prisma.DepartmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload>
          }
          createMany: {
            args: Prisma.DepartmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload>[]
          }
          delete: {
            args: Prisma.DepartmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload>
          }
          update: {
            args: Prisma.DepartmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentsPayload>
          }
          aggregate: {
            args: Prisma.DepartmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartments>
          }
          groupBy: {
            args: Prisma.DepartmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentsCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentsCountAggregateOutputType> | number
          }
        }
      }
      Appointments: {
        payload: Prisma.$AppointmentsPayload<ExtArgs>
        fields: Prisma.AppointmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload>
          }
          findFirst: {
            args: Prisma.AppointmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload>
          }
          findMany: {
            args: Prisma.AppointmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload>[]
          }
          create: {
            args: Prisma.AppointmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload>
          }
          createMany: {
            args: Prisma.AppointmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload>[]
          }
          delete: {
            args: Prisma.AppointmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload>
          }
          update: {
            args: Prisma.AppointmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentsPayload>
          }
          aggregate: {
            args: Prisma.AppointmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointments>
          }
          groupBy: {
            args: Prisma.AppointmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsCountAggregateOutputType> | number
          }
        }
      }
      Rooms: {
        payload: Prisma.$RoomsPayload<ExtArgs>
        fields: Prisma.RoomsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload>
          }
          findFirst: {
            args: Prisma.RoomsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload>
          }
          findMany: {
            args: Prisma.RoomsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload>[]
          }
          create: {
            args: Prisma.RoomsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload>
          }
          createMany: {
            args: Prisma.RoomsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload>[]
          }
          delete: {
            args: Prisma.RoomsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload>
          }
          update: {
            args: Prisma.RoomsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload>
          }
          deleteMany: {
            args: Prisma.RoomsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomsPayload>
          }
          aggregate: {
            args: Prisma.RoomsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRooms>
          }
          groupBy: {
            args: Prisma.RoomsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomsCountArgs<ExtArgs>
            result: $Utils.Optional<RoomsCountAggregateOutputType> | number
          }
        }
      }
      MedicalHistory: {
        payload: Prisma.$MedicalHistoryPayload<ExtArgs>
        fields: Prisma.MedicalHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          findFirst: {
            args: Prisma.MedicalHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          findMany: {
            args: Prisma.MedicalHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>[]
          }
          create: {
            args: Prisma.MedicalHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          createMany: {
            args: Prisma.MedicalHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>[]
          }
          delete: {
            args: Prisma.MedicalHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          update: {
            args: Prisma.MedicalHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          deleteMany: {
            args: Prisma.MedicalHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          aggregate: {
            args: Prisma.MedicalHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalHistory>
          }
          groupBy: {
            args: Prisma.MedicalHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalHistoryCountAggregateOutputType> | number
          }
        }
      }
      Diagnosis: {
        payload: Prisma.$DiagnosisPayload<ExtArgs>
        fields: Prisma.DiagnosisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiagnosisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiagnosisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findFirst: {
            args: Prisma.DiagnosisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiagnosisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          findMany: {
            args: Prisma.DiagnosisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          create: {
            args: Prisma.DiagnosisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          createMany: {
            args: Prisma.DiagnosisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiagnosisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>[]
          }
          delete: {
            args: Prisma.DiagnosisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          update: {
            args: Prisma.DiagnosisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          deleteMany: {
            args: Prisma.DiagnosisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiagnosisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DiagnosisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiagnosisPayload>
          }
          aggregate: {
            args: Prisma.DiagnosisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiagnosis>
          }
          groupBy: {
            args: Prisma.DiagnosisGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiagnosisCountArgs<ExtArgs>
            result: $Utils.Optional<DiagnosisCountAggregateOutputType> | number
          }
        }
      }
      Medications: {
        payload: Prisma.$MedicationsPayload<ExtArgs>
        fields: Prisma.MedicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload>
          }
          findFirst: {
            args: Prisma.MedicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload>
          }
          findMany: {
            args: Prisma.MedicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload>[]
          }
          create: {
            args: Prisma.MedicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload>
          }
          createMany: {
            args: Prisma.MedicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload>[]
          }
          delete: {
            args: Prisma.MedicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload>
          }
          update: {
            args: Prisma.MedicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload>
          }
          deleteMany: {
            args: Prisma.MedicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationsPayload>
          }
          aggregate: {
            args: Prisma.MedicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedications>
          }
          groupBy: {
            args: Prisma.MedicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationsCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationsCountAggregateOutputType> | number
          }
        }
      }
      Treatments: {
        payload: Prisma.$TreatmentsPayload<ExtArgs>
        fields: Prisma.TreatmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreatmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreatmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload>
          }
          findFirst: {
            args: Prisma.TreatmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreatmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload>
          }
          findMany: {
            args: Prisma.TreatmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload>[]
          }
          create: {
            args: Prisma.TreatmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload>
          }
          createMany: {
            args: Prisma.TreatmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreatmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload>[]
          }
          delete: {
            args: Prisma.TreatmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload>
          }
          update: {
            args: Prisma.TreatmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload>
          }
          deleteMany: {
            args: Prisma.TreatmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreatmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TreatmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreatmentsPayload>
          }
          aggregate: {
            args: Prisma.TreatmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreatments>
          }
          groupBy: {
            args: Prisma.TreatmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreatmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreatmentsCountArgs<ExtArgs>
            result: $Utils.Optional<TreatmentsCountAggregateOutputType> | number
          }
        }
      }
      Insurance: {
        payload: Prisma.$InsurancePayload<ExtArgs>
        fields: Prisma.InsuranceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsuranceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsuranceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload>
          }
          findFirst: {
            args: Prisma.InsuranceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsuranceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload>
          }
          findMany: {
            args: Prisma.InsuranceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload>[]
          }
          create: {
            args: Prisma.InsuranceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload>
          }
          createMany: {
            args: Prisma.InsuranceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsuranceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload>[]
          }
          delete: {
            args: Prisma.InsuranceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload>
          }
          update: {
            args: Prisma.InsuranceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload>
          }
          deleteMany: {
            args: Prisma.InsuranceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsuranceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsuranceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePayload>
          }
          aggregate: {
            args: Prisma.InsuranceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsurance>
          }
          groupBy: {
            args: Prisma.InsuranceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsuranceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsuranceCountArgs<ExtArgs>
            result: $Utils.Optional<InsuranceCountAggregateOutputType> | number
          }
        }
      }
      LabTests: {
        payload: Prisma.$LabTestsPayload<ExtArgs>
        fields: Prisma.LabTestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabTestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabTestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload>
          }
          findFirst: {
            args: Prisma.LabTestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabTestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload>
          }
          findMany: {
            args: Prisma.LabTestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload>[]
          }
          create: {
            args: Prisma.LabTestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload>
          }
          createMany: {
            args: Prisma.LabTestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabTestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload>[]
          }
          delete: {
            args: Prisma.LabTestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload>
          }
          update: {
            args: Prisma.LabTestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload>
          }
          deleteMany: {
            args: Prisma.LabTestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabTestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabTestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestsPayload>
          }
          aggregate: {
            args: Prisma.LabTestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabTests>
          }
          groupBy: {
            args: Prisma.LabTestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabTestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabTestsCountArgs<ExtArgs>
            result: $Utils.Optional<LabTestsCountAggregateOutputType> | number
          }
        }
      }
      Bills: {
        payload: Prisma.$BillsPayload<ExtArgs>
        fields: Prisma.BillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          findFirst: {
            args: Prisma.BillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          findMany: {
            args: Prisma.BillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>[]
          }
          create: {
            args: Prisma.BillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          createMany: {
            args: Prisma.BillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>[]
          }
          delete: {
            args: Prisma.BillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          update: {
            args: Prisma.BillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          deleteMany: {
            args: Prisma.BillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BillsPayload>
          }
          aggregate: {
            args: Prisma.BillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBills>
          }
          groupBy: {
            args: Prisma.BillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BillsCountArgs<ExtArgs>
            result: $Utils.Optional<BillsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PatientsCountOutputType
   */

  export type PatientsCountOutputType = {
    appointments: number
    medicalHistory: number
    diagnosis: number
    treatments: number
    insurance: number
    labTests: number
    bills: number
  }

  export type PatientsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientsCountOutputTypeCountAppointmentsArgs
    medicalHistory?: boolean | PatientsCountOutputTypeCountMedicalHistoryArgs
    diagnosis?: boolean | PatientsCountOutputTypeCountDiagnosisArgs
    treatments?: boolean | PatientsCountOutputTypeCountTreatmentsArgs
    insurance?: boolean | PatientsCountOutputTypeCountInsuranceArgs
    labTests?: boolean | PatientsCountOutputTypeCountLabTestsArgs
    bills?: boolean | PatientsCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientsCountOutputType
     */
    select?: PatientsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountMedicalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalHistoryWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountDiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountInsuranceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountLabTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTestsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillsWhereInput
  }


  /**
   * Count Type DoctorsCountOutputType
   */

  export type DoctorsCountOutputType = {
    appointments: number
    diagnosis: number
    treatments: number
    labTests: number
  }

  export type DoctorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | DoctorsCountOutputTypeCountAppointmentsArgs
    diagnosis?: boolean | DoctorsCountOutputTypeCountDiagnosisArgs
    treatments?: boolean | DoctorsCountOutputTypeCountTreatmentsArgs
    labTests?: boolean | DoctorsCountOutputTypeCountLabTestsArgs
  }

  // Custom InputTypes
  /**
   * DoctorsCountOutputType without action
   */
  export type DoctorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorsCountOutputType
     */
    select?: DoctorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorsCountOutputType without action
   */
  export type DoctorsCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentsWhereInput
  }

  /**
   * DoctorsCountOutputType without action
   */
  export type DoctorsCountOutputTypeCountDiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
  }

  /**
   * DoctorsCountOutputType without action
   */
  export type DoctorsCountOutputTypeCountTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentsWhereInput
  }

  /**
   * DoctorsCountOutputType without action
   */
  export type DoctorsCountOutputTypeCountLabTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTestsWhereInput
  }


  /**
   * Count Type DepartmentsCountOutputType
   */

  export type DepartmentsCountOutputType = {
    doctors: number
  }

  export type DepartmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctors?: boolean | DepartmentsCountOutputTypeCountDoctorsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentsCountOutputType
     */
    select?: DepartmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentsCountOutputType without action
   */
  export type DepartmentsCountOutputTypeCountDoctorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorsWhereInput
  }


  /**
   * Count Type MedicationsCountOutputType
   */

  export type MedicationsCountOutputType = {
    treatments: number
  }

  export type MedicationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treatments?: boolean | MedicationsCountOutputTypeCountTreatmentsArgs
  }

  // Custom InputTypes
  /**
   * MedicationsCountOutputType without action
   */
  export type MedicationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationsCountOutputType
     */
    select?: MedicationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicationsCountOutputType without action
   */
  export type MedicationsCountOutputTypeCountTreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Patients
   */

  export type AggregatePatients = {
    _count: PatientsCountAggregateOutputType | null
    _avg: PatientsAvgAggregateOutputType | null
    _sum: PatientsSumAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  export type PatientsAvgAggregateOutputType = {
    patient_id: number | null
  }

  export type PatientsSumAggregateOutputType = {
    patient_id: number | null
  }

  export type PatientsMinAggregateOutputType = {
    patient_id: number | null
    first_name: string | null
    last_name: string | null
    date_of_birth: Date | null
    gender: string | null
    contact_number: string | null
    address: string | null
  }

  export type PatientsMaxAggregateOutputType = {
    patient_id: number | null
    first_name: string | null
    last_name: string | null
    date_of_birth: Date | null
    gender: string | null
    contact_number: string | null
    address: string | null
  }

  export type PatientsCountAggregateOutputType = {
    patient_id: number
    first_name: number
    last_name: number
    date_of_birth: number
    gender: number
    contact_number: number
    address: number
    _all: number
  }


  export type PatientsAvgAggregateInputType = {
    patient_id?: true
  }

  export type PatientsSumAggregateInputType = {
    patient_id?: true
  }

  export type PatientsMinAggregateInputType = {
    patient_id?: true
    first_name?: true
    last_name?: true
    date_of_birth?: true
    gender?: true
    contact_number?: true
    address?: true
  }

  export type PatientsMaxAggregateInputType = {
    patient_id?: true
    first_name?: true
    last_name?: true
    date_of_birth?: true
    gender?: true
    contact_number?: true
    address?: true
  }

  export type PatientsCountAggregateInputType = {
    patient_id?: true
    first_name?: true
    last_name?: true
    date_of_birth?: true
    gender?: true
    contact_number?: true
    address?: true
    _all?: true
  }

  export type PatientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to aggregate.
     */
    where?: PatientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientsOrderByWithRelationInput | PatientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientsMaxAggregateInputType
  }

  export type GetPatientsAggregateType<T extends PatientsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatients[P]>
      : GetScalarType<T[P], AggregatePatients[P]>
  }




  export type PatientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientsWhereInput
    orderBy?: PatientsOrderByWithAggregationInput | PatientsOrderByWithAggregationInput[]
    by: PatientsScalarFieldEnum[] | PatientsScalarFieldEnum
    having?: PatientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientsCountAggregateInputType | true
    _avg?: PatientsAvgAggregateInputType
    _sum?: PatientsSumAggregateInputType
    _min?: PatientsMinAggregateInputType
    _max?: PatientsMaxAggregateInputType
  }

  export type PatientsGroupByOutputType = {
    patient_id: number
    first_name: string
    last_name: string
    date_of_birth: Date
    gender: string
    contact_number: string
    address: string
    _count: PatientsCountAggregateOutputType | null
    _avg: PatientsAvgAggregateOutputType | null
    _sum: PatientsSumAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  type GetPatientsGroupByPayload<T extends PatientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientsGroupByOutputType[P]>
            : GetScalarType<T[P], PatientsGroupByOutputType[P]>
        }
      >
    >


  export type PatientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_id?: boolean
    first_name?: boolean
    last_name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    contact_number?: boolean
    address?: boolean
    appointments?: boolean | Patients$appointmentsArgs<ExtArgs>
    medicalHistory?: boolean | Patients$medicalHistoryArgs<ExtArgs>
    diagnosis?: boolean | Patients$diagnosisArgs<ExtArgs>
    treatments?: boolean | Patients$treatmentsArgs<ExtArgs>
    insurance?: boolean | Patients$insuranceArgs<ExtArgs>
    labTests?: boolean | Patients$labTestsArgs<ExtArgs>
    bills?: boolean | Patients$billsArgs<ExtArgs>
    _count?: boolean | PatientsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type PatientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    patient_id?: boolean
    first_name?: boolean
    last_name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    contact_number?: boolean
    address?: boolean
  }, ExtArgs["result"]["patients"]>

  export type PatientsSelectScalar = {
    patient_id?: boolean
    first_name?: boolean
    last_name?: boolean
    date_of_birth?: boolean
    gender?: boolean
    contact_number?: boolean
    address?: boolean
  }

  export type PatientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Patients$appointmentsArgs<ExtArgs>
    medicalHistory?: boolean | Patients$medicalHistoryArgs<ExtArgs>
    diagnosis?: boolean | Patients$diagnosisArgs<ExtArgs>
    treatments?: boolean | Patients$treatmentsArgs<ExtArgs>
    insurance?: boolean | Patients$insuranceArgs<ExtArgs>
    labTests?: boolean | Patients$labTestsArgs<ExtArgs>
    bills?: boolean | Patients$billsArgs<ExtArgs>
    _count?: boolean | PatientsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patients"
    objects: {
      appointments: Prisma.$AppointmentsPayload<ExtArgs>[]
      medicalHistory: Prisma.$MedicalHistoryPayload<ExtArgs>[]
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs>[]
      treatments: Prisma.$TreatmentsPayload<ExtArgs>[]
      insurance: Prisma.$InsurancePayload<ExtArgs>[]
      labTests: Prisma.$LabTestsPayload<ExtArgs>[]
      bills: Prisma.$BillsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      patient_id: number
      first_name: string
      last_name: string
      date_of_birth: Date
      gender: string
      contact_number: string
      address: string
    }, ExtArgs["result"]["patients"]>
    composites: {}
  }

  type PatientsGetPayload<S extends boolean | null | undefined | PatientsDefaultArgs> = $Result.GetResult<Prisma.$PatientsPayload, S>

  type PatientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientsCountAggregateInputType | true
    }

  export interface PatientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patients'], meta: { name: 'Patients' } }
    /**
     * Find zero or one Patients that matches the filter.
     * @param {PatientsFindUniqueArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientsFindUniqueArgs>(args: SelectSubset<T, PatientsFindUniqueArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patients that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientsFindUniqueOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientsFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsFindFirstArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientsFindFirstArgs>(args?: SelectSubset<T, PatientsFindFirstArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsFindFirstOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientsFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patients.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patients.findMany({ take: 10 })
     * 
     * // Only select the `patient_id`
     * const patientsWithPatient_idOnly = await prisma.patients.findMany({ select: { patient_id: true } })
     * 
     */
    findMany<T extends PatientsFindManyArgs>(args?: SelectSubset<T, PatientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patients.
     * @param {PatientsCreateArgs} args - Arguments to create a Patients.
     * @example
     * // Create one Patients
     * const Patients = await prisma.patients.create({
     *   data: {
     *     // ... data to create a Patients
     *   }
     * })
     * 
     */
    create<T extends PatientsCreateArgs>(args: SelectSubset<T, PatientsCreateArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {PatientsCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientsCreateManyArgs>(args?: SelectSubset<T, PatientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientsCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `patient_id`
     * const patientsWithPatient_idOnly = await prisma.patients.createManyAndReturn({ 
     *   select: { patient_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientsCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Patients.
     * @param {PatientsDeleteArgs} args - Arguments to delete one Patients.
     * @example
     * // Delete one Patients
     * const Patients = await prisma.patients.delete({
     *   where: {
     *     // ... filter to delete one Patients
     *   }
     * })
     * 
     */
    delete<T extends PatientsDeleteArgs>(args: SelectSubset<T, PatientsDeleteArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patients.
     * @param {PatientsUpdateArgs} args - Arguments to update one Patients.
     * @example
     * // Update one Patients
     * const patients = await prisma.patients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientsUpdateArgs>(args: SelectSubset<T, PatientsUpdateArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientsDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientsDeleteManyArgs>(args?: SelectSubset<T, PatientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientsUpdateManyArgs>(args: SelectSubset<T, PatientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patients.
     * @param {PatientsUpsertArgs} args - Arguments to update or create a Patients.
     * @example
     * // Update or create a Patients
     * const patients = await prisma.patients.upsert({
     *   create: {
     *     // ... data to create a Patients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patients we want to update
     *   }
     * })
     */
    upsert<T extends PatientsUpsertArgs>(args: SelectSubset<T, PatientsUpsertArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patients.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientsCountArgs>(
      args?: Subset<T, PatientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientsAggregateArgs>(args: Subset<T, PatientsAggregateArgs>): Prisma.PrismaPromise<GetPatientsAggregateType<T>>

    /**
     * Group by Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientsGroupByArgs['orderBy'] }
        : { orderBy?: PatientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patients model
   */
  readonly fields: PatientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends Patients$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patients$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "findMany"> | Null>
    medicalHistory<T extends Patients$medicalHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Patients$medicalHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    diagnosis<T extends Patients$diagnosisArgs<ExtArgs> = {}>(args?: Subset<T, Patients$diagnosisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany"> | Null>
    treatments<T extends Patients$treatmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patients$treatmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "findMany"> | Null>
    insurance<T extends Patients$insuranceArgs<ExtArgs> = {}>(args?: Subset<T, Patients$insuranceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "findMany"> | Null>
    labTests<T extends Patients$labTestsArgs<ExtArgs> = {}>(args?: Subset<T, Patients$labTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "findMany"> | Null>
    bills<T extends Patients$billsArgs<ExtArgs> = {}>(args?: Subset<T, Patients$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patients model
   */ 
  interface PatientsFieldRefs {
    readonly patient_id: FieldRef<"Patients", 'Int'>
    readonly first_name: FieldRef<"Patients", 'String'>
    readonly last_name: FieldRef<"Patients", 'String'>
    readonly date_of_birth: FieldRef<"Patients", 'DateTime'>
    readonly gender: FieldRef<"Patients", 'String'>
    readonly contact_number: FieldRef<"Patients", 'String'>
    readonly address: FieldRef<"Patients", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Patients findUnique
   */
  export type PatientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where: PatientsWhereUniqueInput
  }

  /**
   * Patients findUniqueOrThrow
   */
  export type PatientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where: PatientsWhereUniqueInput
  }

  /**
   * Patients findFirst
   */
  export type PatientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientsOrderByWithRelationInput | PatientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * Patients findFirstOrThrow
   */
  export type PatientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientsOrderByWithRelationInput | PatientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * Patients findMany
   */
  export type PatientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientsOrderByWithRelationInput | PatientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * Patients create
   */
  export type PatientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * The data needed to create a Patients.
     */
    data: XOR<PatientsCreateInput, PatientsUncheckedCreateInput>
  }

  /**
   * Patients createMany
   */
  export type PatientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientsCreateManyInput | PatientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patients createManyAndReturn
   */
  export type PatientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientsCreateManyInput | PatientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patients update
   */
  export type PatientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * The data needed to update a Patients.
     */
    data: XOR<PatientsUpdateInput, PatientsUncheckedUpdateInput>
    /**
     * Choose, which Patients to update.
     */
    where: PatientsWhereUniqueInput
  }

  /**
   * Patients updateMany
   */
  export type PatientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientsUpdateManyMutationInput, PatientsUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientsWhereInput
  }

  /**
   * Patients upsert
   */
  export type PatientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * The filter to search for the Patients to update in case it exists.
     */
    where: PatientsWhereUniqueInput
    /**
     * In case the Patients found by the `where` argument doesn't exist, create a new Patients with this data.
     */
    create: XOR<PatientsCreateInput, PatientsUncheckedCreateInput>
    /**
     * In case the Patients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientsUpdateInput, PatientsUncheckedUpdateInput>
  }

  /**
   * Patients delete
   */
  export type PatientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
    /**
     * Filter which Patients to delete.
     */
    where: PatientsWhereUniqueInput
  }

  /**
   * Patients deleteMany
   */
  export type PatientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientsWhereInput
  }

  /**
   * Patients.appointments
   */
  export type Patients$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    where?: AppointmentsWhereInput
    orderBy?: AppointmentsOrderByWithRelationInput | AppointmentsOrderByWithRelationInput[]
    cursor?: AppointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * Patients.medicalHistory
   */
  export type Patients$medicalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    where?: MedicalHistoryWhereInput
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    cursor?: MedicalHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalHistoryScalarFieldEnum | MedicalHistoryScalarFieldEnum[]
  }

  /**
   * Patients.diagnosis
   */
  export type Patients$diagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    cursor?: DiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Patients.treatments
   */
  export type Patients$treatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    where?: TreatmentsWhereInput
    orderBy?: TreatmentsOrderByWithRelationInput | TreatmentsOrderByWithRelationInput[]
    cursor?: TreatmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentsScalarFieldEnum | TreatmentsScalarFieldEnum[]
  }

  /**
   * Patients.insurance
   */
  export type Patients$insuranceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    where?: InsuranceWhereInput
    orderBy?: InsuranceOrderByWithRelationInput | InsuranceOrderByWithRelationInput[]
    cursor?: InsuranceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsuranceScalarFieldEnum | InsuranceScalarFieldEnum[]
  }

  /**
   * Patients.labTests
   */
  export type Patients$labTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    where?: LabTestsWhereInput
    orderBy?: LabTestsOrderByWithRelationInput | LabTestsOrderByWithRelationInput[]
    cursor?: LabTestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabTestsScalarFieldEnum | LabTestsScalarFieldEnum[]
  }

  /**
   * Patients.bills
   */
  export type Patients$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    where?: BillsWhereInput
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    cursor?: BillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Patients without action
   */
  export type PatientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patients
     */
    select?: PatientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientsInclude<ExtArgs> | null
  }


  /**
   * Model Doctors
   */

  export type AggregateDoctors = {
    _count: DoctorsCountAggregateOutputType | null
    _avg: DoctorsAvgAggregateOutputType | null
    _sum: DoctorsSumAggregateOutputType | null
    _min: DoctorsMinAggregateOutputType | null
    _max: DoctorsMaxAggregateOutputType | null
  }

  export type DoctorsAvgAggregateOutputType = {
    doctor_id: number | null
    department_id: number | null
  }

  export type DoctorsSumAggregateOutputType = {
    doctor_id: number | null
    department_id: number | null
  }

  export type DoctorsMinAggregateOutputType = {
    doctor_id: number | null
    first_name: string | null
    last_name: string | null
    specialty: string | null
    contact_number: string | null
    department_id: number | null
  }

  export type DoctorsMaxAggregateOutputType = {
    doctor_id: number | null
    first_name: string | null
    last_name: string | null
    specialty: string | null
    contact_number: string | null
    department_id: number | null
  }

  export type DoctorsCountAggregateOutputType = {
    doctor_id: number
    first_name: number
    last_name: number
    specialty: number
    contact_number: number
    department_id: number
    _all: number
  }


  export type DoctorsAvgAggregateInputType = {
    doctor_id?: true
    department_id?: true
  }

  export type DoctorsSumAggregateInputType = {
    doctor_id?: true
    department_id?: true
  }

  export type DoctorsMinAggregateInputType = {
    doctor_id?: true
    first_name?: true
    last_name?: true
    specialty?: true
    contact_number?: true
    department_id?: true
  }

  export type DoctorsMaxAggregateInputType = {
    doctor_id?: true
    first_name?: true
    last_name?: true
    specialty?: true
    contact_number?: true
    department_id?: true
  }

  export type DoctorsCountAggregateInputType = {
    doctor_id?: true
    first_name?: true
    last_name?: true
    specialty?: true
    contact_number?: true
    department_id?: true
    _all?: true
  }

  export type DoctorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to aggregate.
     */
    where?: DoctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorsMaxAggregateInputType
  }

  export type GetDoctorsAggregateType<T extends DoctorsAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctors[P]>
      : GetScalarType<T[P], AggregateDoctors[P]>
  }




  export type DoctorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorsWhereInput
    orderBy?: DoctorsOrderByWithAggregationInput | DoctorsOrderByWithAggregationInput[]
    by: DoctorsScalarFieldEnum[] | DoctorsScalarFieldEnum
    having?: DoctorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorsCountAggregateInputType | true
    _avg?: DoctorsAvgAggregateInputType
    _sum?: DoctorsSumAggregateInputType
    _min?: DoctorsMinAggregateInputType
    _max?: DoctorsMaxAggregateInputType
  }

  export type DoctorsGroupByOutputType = {
    doctor_id: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department_id: number
    _count: DoctorsCountAggregateOutputType | null
    _avg: DoctorsAvgAggregateOutputType | null
    _sum: DoctorsSumAggregateOutputType | null
    _min: DoctorsMinAggregateOutputType | null
    _max: DoctorsMaxAggregateOutputType | null
  }

  type GetDoctorsGroupByPayload<T extends DoctorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorsGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorsGroupByOutputType[P]>
        }
      >
    >


  export type DoctorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doctor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    specialty?: boolean
    contact_number?: boolean
    department_id?: boolean
    department?: boolean | DepartmentsDefaultArgs<ExtArgs>
    appointments?: boolean | Doctors$appointmentsArgs<ExtArgs>
    diagnosis?: boolean | Doctors$diagnosisArgs<ExtArgs>
    treatments?: boolean | Doctors$treatmentsArgs<ExtArgs>
    labTests?: boolean | Doctors$labTestsArgs<ExtArgs>
    _count?: boolean | DoctorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctors"]>

  export type DoctorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doctor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    specialty?: boolean
    contact_number?: boolean
    department_id?: boolean
    department?: boolean | DepartmentsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctors"]>

  export type DoctorsSelectScalar = {
    doctor_id?: boolean
    first_name?: boolean
    last_name?: boolean
    specialty?: boolean
    contact_number?: boolean
    department_id?: boolean
  }

  export type DoctorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentsDefaultArgs<ExtArgs>
    appointments?: boolean | Doctors$appointmentsArgs<ExtArgs>
    diagnosis?: boolean | Doctors$diagnosisArgs<ExtArgs>
    treatments?: boolean | Doctors$treatmentsArgs<ExtArgs>
    labTests?: boolean | Doctors$labTestsArgs<ExtArgs>
    _count?: boolean | DoctorsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoctorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentsDefaultArgs<ExtArgs>
  }

  export type $DoctorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctors"
    objects: {
      department: Prisma.$DepartmentsPayload<ExtArgs>
      appointments: Prisma.$AppointmentsPayload<ExtArgs>[]
      diagnosis: Prisma.$DiagnosisPayload<ExtArgs>[]
      treatments: Prisma.$TreatmentsPayload<ExtArgs>[]
      labTests: Prisma.$LabTestsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      doctor_id: number
      first_name: string
      last_name: string
      specialty: string
      contact_number: string
      department_id: number
    }, ExtArgs["result"]["doctors"]>
    composites: {}
  }

  type DoctorsGetPayload<S extends boolean | null | undefined | DoctorsDefaultArgs> = $Result.GetResult<Prisma.$DoctorsPayload, S>

  type DoctorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorsCountAggregateInputType | true
    }

  export interface DoctorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctors'], meta: { name: 'Doctors' } }
    /**
     * Find zero or one Doctors that matches the filter.
     * @param {DoctorsFindUniqueArgs} args - Arguments to find a Doctors
     * @example
     * // Get one Doctors
     * const doctors = await prisma.doctors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorsFindUniqueArgs>(args: SelectSubset<T, DoctorsFindUniqueArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Doctors that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorsFindUniqueOrThrowArgs} args - Arguments to find a Doctors
     * @example
     * // Get one Doctors
     * const doctors = await prisma.doctors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorsFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsFindFirstArgs} args - Arguments to find a Doctors
     * @example
     * // Get one Doctors
     * const doctors = await prisma.doctors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorsFindFirstArgs>(args?: SelectSubset<T, DoctorsFindFirstArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Doctors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsFindFirstOrThrowArgs} args - Arguments to find a Doctors
     * @example
     * // Get one Doctors
     * const doctors = await prisma.doctors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorsFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctors.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctors.findMany({ take: 10 })
     * 
     * // Only select the `doctor_id`
     * const doctorsWithDoctor_idOnly = await prisma.doctors.findMany({ select: { doctor_id: true } })
     * 
     */
    findMany<T extends DoctorsFindManyArgs>(args?: SelectSubset<T, DoctorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Doctors.
     * @param {DoctorsCreateArgs} args - Arguments to create a Doctors.
     * @example
     * // Create one Doctors
     * const Doctors = await prisma.doctors.create({
     *   data: {
     *     // ... data to create a Doctors
     *   }
     * })
     * 
     */
    create<T extends DoctorsCreateArgs>(args: SelectSubset<T, DoctorsCreateArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Doctors.
     * @param {DoctorsCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctors = await prisma.doctors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorsCreateManyArgs>(args?: SelectSubset<T, DoctorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorsCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctors = await prisma.doctors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `doctor_id`
     * const doctorsWithDoctor_idOnly = await prisma.doctors.createManyAndReturn({ 
     *   select: { doctor_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorsCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Doctors.
     * @param {DoctorsDeleteArgs} args - Arguments to delete one Doctors.
     * @example
     * // Delete one Doctors
     * const Doctors = await prisma.doctors.delete({
     *   where: {
     *     // ... filter to delete one Doctors
     *   }
     * })
     * 
     */
    delete<T extends DoctorsDeleteArgs>(args: SelectSubset<T, DoctorsDeleteArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Doctors.
     * @param {DoctorsUpdateArgs} args - Arguments to update one Doctors.
     * @example
     * // Update one Doctors
     * const doctors = await prisma.doctors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorsUpdateArgs>(args: SelectSubset<T, DoctorsUpdateArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorsDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorsDeleteManyArgs>(args?: SelectSubset<T, DoctorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctors = await prisma.doctors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorsUpdateManyArgs>(args: SelectSubset<T, DoctorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctors.
     * @param {DoctorsUpsertArgs} args - Arguments to update or create a Doctors.
     * @example
     * // Update or create a Doctors
     * const doctors = await prisma.doctors.upsert({
     *   create: {
     *     // ... data to create a Doctors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctors we want to update
     *   }
     * })
     */
    upsert<T extends DoctorsUpsertArgs>(args: SelectSubset<T, DoctorsUpsertArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctors.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorsCountArgs>(
      args?: Subset<T, DoctorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorsAggregateArgs>(args: Subset<T, DoctorsAggregateArgs>): Prisma.PrismaPromise<GetDoctorsAggregateType<T>>

    /**
     * Group by Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorsGroupByArgs['orderBy'] }
        : { orderBy?: DoctorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctors model
   */
  readonly fields: DoctorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentsDefaultArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    appointments<T extends Doctors$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Doctors$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "findMany"> | Null>
    diagnosis<T extends Doctors$diagnosisArgs<ExtArgs> = {}>(args?: Subset<T, Doctors$diagnosisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany"> | Null>
    treatments<T extends Doctors$treatmentsArgs<ExtArgs> = {}>(args?: Subset<T, Doctors$treatmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "findMany"> | Null>
    labTests<T extends Doctors$labTestsArgs<ExtArgs> = {}>(args?: Subset<T, Doctors$labTestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctors model
   */ 
  interface DoctorsFieldRefs {
    readonly doctor_id: FieldRef<"Doctors", 'Int'>
    readonly first_name: FieldRef<"Doctors", 'String'>
    readonly last_name: FieldRef<"Doctors", 'String'>
    readonly specialty: FieldRef<"Doctors", 'String'>
    readonly contact_number: FieldRef<"Doctors", 'String'>
    readonly department_id: FieldRef<"Doctors", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Doctors findUnique
   */
  export type DoctorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where: DoctorsWhereUniqueInput
  }

  /**
   * Doctors findUniqueOrThrow
   */
  export type DoctorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where: DoctorsWhereUniqueInput
  }

  /**
   * Doctors findFirst
   */
  export type DoctorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorsScalarFieldEnum | DoctorsScalarFieldEnum[]
  }

  /**
   * Doctors findFirstOrThrow
   */
  export type DoctorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorsScalarFieldEnum | DoctorsScalarFieldEnum[]
  }

  /**
   * Doctors findMany
   */
  export type DoctorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorsScalarFieldEnum | DoctorsScalarFieldEnum[]
  }

  /**
   * Doctors create
   */
  export type DoctorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctors.
     */
    data: XOR<DoctorsCreateInput, DoctorsUncheckedCreateInput>
  }

  /**
   * Doctors createMany
   */
  export type DoctorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorsCreateManyInput | DoctorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Doctors createManyAndReturn
   */
  export type DoctorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Doctors.
     */
    data: DoctorsCreateManyInput | DoctorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doctors update
   */
  export type DoctorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctors.
     */
    data: XOR<DoctorsUpdateInput, DoctorsUncheckedUpdateInput>
    /**
     * Choose, which Doctors to update.
     */
    where: DoctorsWhereUniqueInput
  }

  /**
   * Doctors updateMany
   */
  export type DoctorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorsUpdateManyMutationInput, DoctorsUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorsWhereInput
  }

  /**
   * Doctors upsert
   */
  export type DoctorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctors to update in case it exists.
     */
    where: DoctorsWhereUniqueInput
    /**
     * In case the Doctors found by the `where` argument doesn't exist, create a new Doctors with this data.
     */
    create: XOR<DoctorsCreateInput, DoctorsUncheckedCreateInput>
    /**
     * In case the Doctors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorsUpdateInput, DoctorsUncheckedUpdateInput>
  }

  /**
   * Doctors delete
   */
  export type DoctorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    /**
     * Filter which Doctors to delete.
     */
    where: DoctorsWhereUniqueInput
  }

  /**
   * Doctors deleteMany
   */
  export type DoctorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorsWhereInput
  }

  /**
   * Doctors.appointments
   */
  export type Doctors$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    where?: AppointmentsWhereInput
    orderBy?: AppointmentsOrderByWithRelationInput | AppointmentsOrderByWithRelationInput[]
    cursor?: AppointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * Doctors.diagnosis
   */
  export type Doctors$diagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    cursor?: DiagnosisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Doctors.treatments
   */
  export type Doctors$treatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    where?: TreatmentsWhereInput
    orderBy?: TreatmentsOrderByWithRelationInput | TreatmentsOrderByWithRelationInput[]
    cursor?: TreatmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentsScalarFieldEnum | TreatmentsScalarFieldEnum[]
  }

  /**
   * Doctors.labTests
   */
  export type Doctors$labTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    where?: LabTestsWhereInput
    orderBy?: LabTestsOrderByWithRelationInput | LabTestsOrderByWithRelationInput[]
    cursor?: LabTestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabTestsScalarFieldEnum | LabTestsScalarFieldEnum[]
  }

  /**
   * Doctors without action
   */
  export type DoctorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
  }


  /**
   * Model Departments
   */

  export type AggregateDepartments = {
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  export type DepartmentsAvgAggregateOutputType = {
    department_id: number | null
  }

  export type DepartmentsSumAggregateOutputType = {
    department_id: number | null
  }

  export type DepartmentsMinAggregateOutputType = {
    department_id: number | null
    department_name: string | null
  }

  export type DepartmentsMaxAggregateOutputType = {
    department_id: number | null
    department_name: string | null
  }

  export type DepartmentsCountAggregateOutputType = {
    department_id: number
    department_name: number
    _all: number
  }


  export type DepartmentsAvgAggregateInputType = {
    department_id?: true
  }

  export type DepartmentsSumAggregateInputType = {
    department_id?: true
  }

  export type DepartmentsMinAggregateInputType = {
    department_id?: true
    department_name?: true
  }

  export type DepartmentsMaxAggregateInputType = {
    department_id?: true
    department_name?: true
  }

  export type DepartmentsCountAggregateInputType = {
    department_id?: true
    department_name?: true
    _all?: true
  }

  export type DepartmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to aggregate.
     */
    where?: DepartmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentsOrderByWithRelationInput | DepartmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentsMaxAggregateInputType
  }

  export type GetDepartmentsAggregateType<T extends DepartmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartments[P]>
      : GetScalarType<T[P], AggregateDepartments[P]>
  }




  export type DepartmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentsWhereInput
    orderBy?: DepartmentsOrderByWithAggregationInput | DepartmentsOrderByWithAggregationInput[]
    by: DepartmentsScalarFieldEnum[] | DepartmentsScalarFieldEnum
    having?: DepartmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentsCountAggregateInputType | true
    _avg?: DepartmentsAvgAggregateInputType
    _sum?: DepartmentsSumAggregateInputType
    _min?: DepartmentsMinAggregateInputType
    _max?: DepartmentsMaxAggregateInputType
  }

  export type DepartmentsGroupByOutputType = {
    department_id: number
    department_name: string
    _count: DepartmentsCountAggregateOutputType | null
    _avg: DepartmentsAvgAggregateOutputType | null
    _sum: DepartmentsSumAggregateOutputType | null
    _min: DepartmentsMinAggregateOutputType | null
    _max: DepartmentsMaxAggregateOutputType | null
  }

  type GetDepartmentsGroupByPayload<T extends DepartmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentsGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    department_id?: boolean
    department_name?: boolean
    doctors?: boolean | Departments$doctorsArgs<ExtArgs>
    _count?: boolean | DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["departments"]>

  export type DepartmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    department_id?: boolean
    department_name?: boolean
  }, ExtArgs["result"]["departments"]>

  export type DepartmentsSelectScalar = {
    department_id?: boolean
    department_name?: boolean
  }

  export type DepartmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctors?: boolean | Departments$doctorsArgs<ExtArgs>
    _count?: boolean | DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepartmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Departments"
    objects: {
      doctors: Prisma.$DoctorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      department_id: number
      department_name: string
    }, ExtArgs["result"]["departments"]>
    composites: {}
  }

  type DepartmentsGetPayload<S extends boolean | null | undefined | DepartmentsDefaultArgs> = $Result.GetResult<Prisma.$DepartmentsPayload, S>

  type DepartmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentsCountAggregateInputType | true
    }

  export interface DepartmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Departments'], meta: { name: 'Departments' } }
    /**
     * Find zero or one Departments that matches the filter.
     * @param {DepartmentsFindUniqueArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentsFindUniqueArgs>(args: SelectSubset<T, DepartmentsFindUniqueArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Departments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentsFindUniqueOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsFindFirstArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentsFindFirstArgs>(args?: SelectSubset<T, DepartmentsFindFirstArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Departments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsFindFirstOrThrowArgs} args - Arguments to find a Departments
     * @example
     * // Get one Departments
     * const departments = await prisma.departments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.departments.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.departments.findMany({ take: 10 })
     * 
     * // Only select the `department_id`
     * const departmentsWithDepartment_idOnly = await prisma.departments.findMany({ select: { department_id: true } })
     * 
     */
    findMany<T extends DepartmentsFindManyArgs>(args?: SelectSubset<T, DepartmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Departments.
     * @param {DepartmentsCreateArgs} args - Arguments to create a Departments.
     * @example
     * // Create one Departments
     * const Departments = await prisma.departments.create({
     *   data: {
     *     // ... data to create a Departments
     *   }
     * })
     * 
     */
    create<T extends DepartmentsCreateArgs>(args: SelectSubset<T, DepartmentsCreateArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentsCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const departments = await prisma.departments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentsCreateManyArgs>(args?: SelectSubset<T, DepartmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentsCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const departments = await prisma.departments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `department_id`
     * const departmentsWithDepartment_idOnly = await prisma.departments.createManyAndReturn({ 
     *   select: { department_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Departments.
     * @param {DepartmentsDeleteArgs} args - Arguments to delete one Departments.
     * @example
     * // Delete one Departments
     * const Departments = await prisma.departments.delete({
     *   where: {
     *     // ... filter to delete one Departments
     *   }
     * })
     * 
     */
    delete<T extends DepartmentsDeleteArgs>(args: SelectSubset<T, DepartmentsDeleteArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Departments.
     * @param {DepartmentsUpdateArgs} args - Arguments to update one Departments.
     * @example
     * // Update one Departments
     * const departments = await prisma.departments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentsUpdateArgs>(args: SelectSubset<T, DepartmentsUpdateArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentsDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.departments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentsDeleteManyArgs>(args?: SelectSubset<T, DepartmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const departments = await prisma.departments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentsUpdateManyArgs>(args: SelectSubset<T, DepartmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Departments.
     * @param {DepartmentsUpsertArgs} args - Arguments to update or create a Departments.
     * @example
     * // Update or create a Departments
     * const departments = await prisma.departments.upsert({
     *   create: {
     *     // ... data to create a Departments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Departments we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentsUpsertArgs>(args: SelectSubset<T, DepartmentsUpsertArgs<ExtArgs>>): Prisma__DepartmentsClient<$Result.GetResult<Prisma.$DepartmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.departments.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentsCountArgs>(
      args?: Subset<T, DepartmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentsAggregateArgs>(args: Subset<T, DepartmentsAggregateArgs>): Prisma.PrismaPromise<GetDepartmentsAggregateType<T>>

    /**
     * Group by Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentsGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Departments model
   */
  readonly fields: DepartmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Departments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctors<T extends Departments$doctorsArgs<ExtArgs> = {}>(args?: Subset<T, Departments$doctorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Departments model
   */ 
  interface DepartmentsFieldRefs {
    readonly department_id: FieldRef<"Departments", 'Int'>
    readonly department_name: FieldRef<"Departments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Departments findUnique
   */
  export type DepartmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where: DepartmentsWhereUniqueInput
  }

  /**
   * Departments findUniqueOrThrow
   */
  export type DepartmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where: DepartmentsWhereUniqueInput
  }

  /**
   * Departments findFirst
   */
  export type DepartmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentsOrderByWithRelationInput | DepartmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * Departments findFirstOrThrow
   */
  export type DepartmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentsOrderByWithRelationInput | DepartmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * Departments findMany
   */
  export type DepartmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentsOrderByWithRelationInput | DepartmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentsScalarFieldEnum | DepartmentsScalarFieldEnum[]
  }

  /**
   * Departments create
   */
  export type DepartmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Departments.
     */
    data: XOR<DepartmentsCreateInput, DepartmentsUncheckedCreateInput>
  }

  /**
   * Departments createMany
   */
  export type DepartmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentsCreateManyInput | DepartmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Departments createManyAndReturn
   */
  export type DepartmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentsCreateManyInput | DepartmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Departments update
   */
  export type DepartmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Departments.
     */
    data: XOR<DepartmentsUpdateInput, DepartmentsUncheckedUpdateInput>
    /**
     * Choose, which Departments to update.
     */
    where: DepartmentsWhereUniqueInput
  }

  /**
   * Departments updateMany
   */
  export type DepartmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentsUpdateManyMutationInput, DepartmentsUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentsWhereInput
  }

  /**
   * Departments upsert
   */
  export type DepartmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Departments to update in case it exists.
     */
    where: DepartmentsWhereUniqueInput
    /**
     * In case the Departments found by the `where` argument doesn't exist, create a new Departments with this data.
     */
    create: XOR<DepartmentsCreateInput, DepartmentsUncheckedCreateInput>
    /**
     * In case the Departments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentsUpdateInput, DepartmentsUncheckedUpdateInput>
  }

  /**
   * Departments delete
   */
  export type DepartmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
    /**
     * Filter which Departments to delete.
     */
    where: DepartmentsWhereUniqueInput
  }

  /**
   * Departments deleteMany
   */
  export type DepartmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentsWhereInput
  }

  /**
   * Departments.doctors
   */
  export type Departments$doctorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctors
     */
    select?: DoctorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorsInclude<ExtArgs> | null
    where?: DoctorsWhereInput
    orderBy?: DoctorsOrderByWithRelationInput | DoctorsOrderByWithRelationInput[]
    cursor?: DoctorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorsScalarFieldEnum | DoctorsScalarFieldEnum[]
  }

  /**
   * Departments without action
   */
  export type DepartmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Departments
     */
    select?: DepartmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentsInclude<ExtArgs> | null
  }


  /**
   * Model Appointments
   */

  export type AggregateAppointments = {
    _count: AppointmentsCountAggregateOutputType | null
    _avg: AppointmentsAvgAggregateOutputType | null
    _sum: AppointmentsSumAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  export type AppointmentsAvgAggregateOutputType = {
    appointment_id: number | null
    patient_id: number | null
    doctor_id: number | null
  }

  export type AppointmentsSumAggregateOutputType = {
    appointment_id: number | null
    patient_id: number | null
    doctor_id: number | null
  }

  export type AppointmentsMinAggregateOutputType = {
    appointment_id: number | null
    patient_id: number | null
    doctor_id: number | null
    appointment_date: Date | null
    reason_for_visit: string | null
  }

  export type AppointmentsMaxAggregateOutputType = {
    appointment_id: number | null
    patient_id: number | null
    doctor_id: number | null
    appointment_date: Date | null
    reason_for_visit: string | null
  }

  export type AppointmentsCountAggregateOutputType = {
    appointment_id: number
    patient_id: number
    doctor_id: number
    appointment_date: number
    reason_for_visit: number
    _all: number
  }


  export type AppointmentsAvgAggregateInputType = {
    appointment_id?: true
    patient_id?: true
    doctor_id?: true
  }

  export type AppointmentsSumAggregateInputType = {
    appointment_id?: true
    patient_id?: true
    doctor_id?: true
  }

  export type AppointmentsMinAggregateInputType = {
    appointment_id?: true
    patient_id?: true
    doctor_id?: true
    appointment_date?: true
    reason_for_visit?: true
  }

  export type AppointmentsMaxAggregateInputType = {
    appointment_id?: true
    patient_id?: true
    doctor_id?: true
    appointment_date?: true
    reason_for_visit?: true
  }

  export type AppointmentsCountAggregateInputType = {
    appointment_id?: true
    patient_id?: true
    doctor_id?: true
    appointment_date?: true
    reason_for_visit?: true
    _all?: true
  }

  export type AppointmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to aggregate.
     */
    where?: AppointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentsOrderByWithRelationInput | AppointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentsMaxAggregateInputType
  }

  export type GetAppointmentsAggregateType<T extends AppointmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointments[P]>
      : GetScalarType<T[P], AggregateAppointments[P]>
  }




  export type AppointmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentsWhereInput
    orderBy?: AppointmentsOrderByWithAggregationInput | AppointmentsOrderByWithAggregationInput[]
    by: AppointmentsScalarFieldEnum[] | AppointmentsScalarFieldEnum
    having?: AppointmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentsCountAggregateInputType | true
    _avg?: AppointmentsAvgAggregateInputType
    _sum?: AppointmentsSumAggregateInputType
    _min?: AppointmentsMinAggregateInputType
    _max?: AppointmentsMaxAggregateInputType
  }

  export type AppointmentsGroupByOutputType = {
    appointment_id: number
    patient_id: number
    doctor_id: number
    appointment_date: Date
    reason_for_visit: string
    _count: AppointmentsCountAggregateOutputType | null
    _avg: AppointmentsAvgAggregateOutputType | null
    _sum: AppointmentsSumAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  type GetAppointmentsGroupByPayload<T extends AppointmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointment_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    appointment_date?: boolean
    reason_for_visit?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>

  export type AppointmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appointment_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    appointment_date?: boolean
    reason_for_visit?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>

  export type AppointmentsSelectScalar = {
    appointment_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    appointment_date?: boolean
    reason_for_visit?: boolean
  }

  export type AppointmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }
  export type AppointmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }

  export type $AppointmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointments"
    objects: {
      patient: Prisma.$PatientsPayload<ExtArgs>
      doctor: Prisma.$DoctorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      appointment_id: number
      patient_id: number
      doctor_id: number
      appointment_date: Date
      reason_for_visit: string
    }, ExtArgs["result"]["appointments"]>
    composites: {}
  }

  type AppointmentsGetPayload<S extends boolean | null | undefined | AppointmentsDefaultArgs> = $Result.GetResult<Prisma.$AppointmentsPayload, S>

  type AppointmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentsCountAggregateInputType | true
    }

  export interface AppointmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointments'], meta: { name: 'Appointments' } }
    /**
     * Find zero or one Appointments that matches the filter.
     * @param {AppointmentsFindUniqueArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentsFindUniqueArgs>(args: SelectSubset<T, AppointmentsFindUniqueArgs<ExtArgs>>): Prisma__AppointmentsClient<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppointmentsFindUniqueOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentsClient<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsFindFirstArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentsFindFirstArgs>(args?: SelectSubset<T, AppointmentsFindFirstArgs<ExtArgs>>): Prisma__AppointmentsClient<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsFindFirstOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentsClient<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointments.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointments.findMany({ take: 10 })
     * 
     * // Only select the `appointment_id`
     * const appointmentsWithAppointment_idOnly = await prisma.appointments.findMany({ select: { appointment_id: true } })
     * 
     */
    findMany<T extends AppointmentsFindManyArgs>(args?: SelectSubset<T, AppointmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointments.
     * @param {AppointmentsCreateArgs} args - Arguments to create a Appointments.
     * @example
     * // Create one Appointments
     * const Appointments = await prisma.appointments.create({
     *   data: {
     *     // ... data to create a Appointments
     *   }
     * })
     * 
     */
    create<T extends AppointmentsCreateArgs>(args: SelectSubset<T, AppointmentsCreateArgs<ExtArgs>>): Prisma__AppointmentsClient<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {AppointmentsCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentsCreateManyArgs>(args?: SelectSubset<T, AppointmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentsCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `appointment_id`
     * const appointmentsWithAppointment_idOnly = await prisma.appointments.createManyAndReturn({ 
     *   select: { appointment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Appointments.
     * @param {AppointmentsDeleteArgs} args - Arguments to delete one Appointments.
     * @example
     * // Delete one Appointments
     * const Appointments = await prisma.appointments.delete({
     *   where: {
     *     // ... filter to delete one Appointments
     *   }
     * })
     * 
     */
    delete<T extends AppointmentsDeleteArgs>(args: SelectSubset<T, AppointmentsDeleteArgs<ExtArgs>>): Prisma__AppointmentsClient<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointments.
     * @param {AppointmentsUpdateArgs} args - Arguments to update one Appointments.
     * @example
     * // Update one Appointments
     * const appointments = await prisma.appointments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentsUpdateArgs>(args: SelectSubset<T, AppointmentsUpdateArgs<ExtArgs>>): Prisma__AppointmentsClient<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentsDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentsDeleteManyArgs>(args?: SelectSubset<T, AppointmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointments = await prisma.appointments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentsUpdateManyArgs>(args: SelectSubset<T, AppointmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointments.
     * @param {AppointmentsUpsertArgs} args - Arguments to update or create a Appointments.
     * @example
     * // Update or create a Appointments
     * const appointments = await prisma.appointments.upsert({
     *   create: {
     *     // ... data to create a Appointments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointments we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentsUpsertArgs>(args: SelectSubset<T, AppointmentsUpsertArgs<ExtArgs>>): Prisma__AppointmentsClient<$Result.GetResult<Prisma.$AppointmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointments.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentsCountArgs>(
      args?: Subset<T, AppointmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentsAggregateArgs>(args: Subset<T, AppointmentsAggregateArgs>): Prisma.PrismaPromise<GetAppointmentsAggregateType<T>>

    /**
     * Group by Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentsGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointments model
   */
  readonly fields: AppointmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientsDefaultArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends DoctorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorsDefaultArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointments model
   */ 
  interface AppointmentsFieldRefs {
    readonly appointment_id: FieldRef<"Appointments", 'Int'>
    readonly patient_id: FieldRef<"Appointments", 'Int'>
    readonly doctor_id: FieldRef<"Appointments", 'Int'>
    readonly appointment_date: FieldRef<"Appointments", 'DateTime'>
    readonly reason_for_visit: FieldRef<"Appointments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Appointments findUnique
   */
  export type AppointmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where: AppointmentsWhereUniqueInput
  }

  /**
   * Appointments findUniqueOrThrow
   */
  export type AppointmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where: AppointmentsWhereUniqueInput
  }

  /**
   * Appointments findFirst
   */
  export type AppointmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentsOrderByWithRelationInput | AppointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * Appointments findFirstOrThrow
   */
  export type AppointmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentsOrderByWithRelationInput | AppointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * Appointments findMany
   */
  export type AppointmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentsOrderByWithRelationInput | AppointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * Appointments create
   */
  export type AppointmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointments.
     */
    data: XOR<AppointmentsCreateInput, AppointmentsUncheckedCreateInput>
  }

  /**
   * Appointments createMany
   */
  export type AppointmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentsCreateManyInput | AppointmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointments createManyAndReturn
   */
  export type AppointmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentsCreateManyInput | AppointmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointments update
   */
  export type AppointmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointments.
     */
    data: XOR<AppointmentsUpdateInput, AppointmentsUncheckedUpdateInput>
    /**
     * Choose, which Appointments to update.
     */
    where: AppointmentsWhereUniqueInput
  }

  /**
   * Appointments updateMany
   */
  export type AppointmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentsUpdateManyMutationInput, AppointmentsUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentsWhereInput
  }

  /**
   * Appointments upsert
   */
  export type AppointmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointments to update in case it exists.
     */
    where: AppointmentsWhereUniqueInput
    /**
     * In case the Appointments found by the `where` argument doesn't exist, create a new Appointments with this data.
     */
    create: XOR<AppointmentsCreateInput, AppointmentsUncheckedCreateInput>
    /**
     * In case the Appointments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentsUpdateInput, AppointmentsUncheckedUpdateInput>
  }

  /**
   * Appointments delete
   */
  export type AppointmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
    /**
     * Filter which Appointments to delete.
     */
    where: AppointmentsWhereUniqueInput
  }

  /**
   * Appointments deleteMany
   */
  export type AppointmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentsWhereInput
  }

  /**
   * Appointments without action
   */
  export type AppointmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointments
     */
    select?: AppointmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentsInclude<ExtArgs> | null
  }


  /**
   * Model Rooms
   */

  export type AggregateRooms = {
    _count: RoomsCountAggregateOutputType | null
    _avg: RoomsAvgAggregateOutputType | null
    _sum: RoomsSumAggregateOutputType | null
    _min: RoomsMinAggregateOutputType | null
    _max: RoomsMaxAggregateOutputType | null
  }

  export type RoomsAvgAggregateOutputType = {
    room_id: number | null
  }

  export type RoomsSumAggregateOutputType = {
    room_id: number | null
  }

  export type RoomsMinAggregateOutputType = {
    room_id: number | null
    room_number: string | null
    room_type: string | null
    availability_status: boolean | null
  }

  export type RoomsMaxAggregateOutputType = {
    room_id: number | null
    room_number: string | null
    room_type: string | null
    availability_status: boolean | null
  }

  export type RoomsCountAggregateOutputType = {
    room_id: number
    room_number: number
    room_type: number
    availability_status: number
    _all: number
  }


  export type RoomsAvgAggregateInputType = {
    room_id?: true
  }

  export type RoomsSumAggregateInputType = {
    room_id?: true
  }

  export type RoomsMinAggregateInputType = {
    room_id?: true
    room_number?: true
    room_type?: true
    availability_status?: true
  }

  export type RoomsMaxAggregateInputType = {
    room_id?: true
    room_number?: true
    room_type?: true
    availability_status?: true
  }

  export type RoomsCountAggregateInputType = {
    room_id?: true
    room_number?: true
    room_type?: true
    availability_status?: true
    _all?: true
  }

  export type RoomsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to aggregate.
     */
    where?: RoomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomsOrderByWithRelationInput | RoomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomsMaxAggregateInputType
  }

  export type GetRoomsAggregateType<T extends RoomsAggregateArgs> = {
        [P in keyof T & keyof AggregateRooms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRooms[P]>
      : GetScalarType<T[P], AggregateRooms[P]>
  }




  export type RoomsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomsWhereInput
    orderBy?: RoomsOrderByWithAggregationInput | RoomsOrderByWithAggregationInput[]
    by: RoomsScalarFieldEnum[] | RoomsScalarFieldEnum
    having?: RoomsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomsCountAggregateInputType | true
    _avg?: RoomsAvgAggregateInputType
    _sum?: RoomsSumAggregateInputType
    _min?: RoomsMinAggregateInputType
    _max?: RoomsMaxAggregateInputType
  }

  export type RoomsGroupByOutputType = {
    room_id: number
    room_number: string
    room_type: string
    availability_status: boolean
    _count: RoomsCountAggregateOutputType | null
    _avg: RoomsAvgAggregateOutputType | null
    _sum: RoomsSumAggregateOutputType | null
    _min: RoomsMinAggregateOutputType | null
    _max: RoomsMaxAggregateOutputType | null
  }

  type GetRoomsGroupByPayload<T extends RoomsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomsGroupByOutputType[P]>
            : GetScalarType<T[P], RoomsGroupByOutputType[P]>
        }
      >
    >


  export type RoomsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    room_id?: boolean
    room_number?: boolean
    room_type?: boolean
    availability_status?: boolean
  }, ExtArgs["result"]["rooms"]>

  export type RoomsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    room_id?: boolean
    room_number?: boolean
    room_type?: boolean
    availability_status?: boolean
  }, ExtArgs["result"]["rooms"]>

  export type RoomsSelectScalar = {
    room_id?: boolean
    room_number?: boolean
    room_type?: boolean
    availability_status?: boolean
  }


  export type $RoomsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rooms"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      room_id: number
      room_number: string
      room_type: string
      availability_status: boolean
    }, ExtArgs["result"]["rooms"]>
    composites: {}
  }

  type RoomsGetPayload<S extends boolean | null | undefined | RoomsDefaultArgs> = $Result.GetResult<Prisma.$RoomsPayload, S>

  type RoomsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomsCountAggregateInputType | true
    }

  export interface RoomsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rooms'], meta: { name: 'Rooms' } }
    /**
     * Find zero or one Rooms that matches the filter.
     * @param {RoomsFindUniqueArgs} args - Arguments to find a Rooms
     * @example
     * // Get one Rooms
     * const rooms = await prisma.rooms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomsFindUniqueArgs>(args: SelectSubset<T, RoomsFindUniqueArgs<ExtArgs>>): Prisma__RoomsClient<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rooms that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomsFindUniqueOrThrowArgs} args - Arguments to find a Rooms
     * @example
     * // Get one Rooms
     * const rooms = await prisma.rooms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomsFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomsClient<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsFindFirstArgs} args - Arguments to find a Rooms
     * @example
     * // Get one Rooms
     * const rooms = await prisma.rooms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomsFindFirstArgs>(args?: SelectSubset<T, RoomsFindFirstArgs<ExtArgs>>): Prisma__RoomsClient<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rooms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsFindFirstOrThrowArgs} args - Arguments to find a Rooms
     * @example
     * // Get one Rooms
     * const rooms = await prisma.rooms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomsFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomsClient<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.rooms.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.rooms.findMany({ take: 10 })
     * 
     * // Only select the `room_id`
     * const roomsWithRoom_idOnly = await prisma.rooms.findMany({ select: { room_id: true } })
     * 
     */
    findMany<T extends RoomsFindManyArgs>(args?: SelectSubset<T, RoomsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rooms.
     * @param {RoomsCreateArgs} args - Arguments to create a Rooms.
     * @example
     * // Create one Rooms
     * const Rooms = await prisma.rooms.create({
     *   data: {
     *     // ... data to create a Rooms
     *   }
     * })
     * 
     */
    create<T extends RoomsCreateArgs>(args: SelectSubset<T, RoomsCreateArgs<ExtArgs>>): Prisma__RoomsClient<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomsCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const rooms = await prisma.rooms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomsCreateManyArgs>(args?: SelectSubset<T, RoomsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomsCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const rooms = await prisma.rooms.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `room_id`
     * const roomsWithRoom_idOnly = await prisma.rooms.createManyAndReturn({ 
     *   select: { room_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomsCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Rooms.
     * @param {RoomsDeleteArgs} args - Arguments to delete one Rooms.
     * @example
     * // Delete one Rooms
     * const Rooms = await prisma.rooms.delete({
     *   where: {
     *     // ... filter to delete one Rooms
     *   }
     * })
     * 
     */
    delete<T extends RoomsDeleteArgs>(args: SelectSubset<T, RoomsDeleteArgs<ExtArgs>>): Prisma__RoomsClient<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rooms.
     * @param {RoomsUpdateArgs} args - Arguments to update one Rooms.
     * @example
     * // Update one Rooms
     * const rooms = await prisma.rooms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomsUpdateArgs>(args: SelectSubset<T, RoomsUpdateArgs<ExtArgs>>): Prisma__RoomsClient<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomsDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.rooms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomsDeleteManyArgs>(args?: SelectSubset<T, RoomsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const rooms = await prisma.rooms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomsUpdateManyArgs>(args: SelectSubset<T, RoomsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rooms.
     * @param {RoomsUpsertArgs} args - Arguments to update or create a Rooms.
     * @example
     * // Update or create a Rooms
     * const rooms = await prisma.rooms.upsert({
     *   create: {
     *     // ... data to create a Rooms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rooms we want to update
     *   }
     * })
     */
    upsert<T extends RoomsUpsertArgs>(args: SelectSubset<T, RoomsUpsertArgs<ExtArgs>>): Prisma__RoomsClient<$Result.GetResult<Prisma.$RoomsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.rooms.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomsCountArgs>(
      args?: Subset<T, RoomsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomsAggregateArgs>(args: Subset<T, RoomsAggregateArgs>): Prisma.PrismaPromise<GetRoomsAggregateType<T>>

    /**
     * Group by Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomsGroupByArgs['orderBy'] }
        : { orderBy?: RoomsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rooms model
   */
  readonly fields: RoomsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rooms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Rooms model
   */ 
  interface RoomsFieldRefs {
    readonly room_id: FieldRef<"Rooms", 'Int'>
    readonly room_number: FieldRef<"Rooms", 'String'>
    readonly room_type: FieldRef<"Rooms", 'String'>
    readonly availability_status: FieldRef<"Rooms", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Rooms findUnique
   */
  export type RoomsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where: RoomsWhereUniqueInput
  }

  /**
   * Rooms findUniqueOrThrow
   */
  export type RoomsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where: RoomsWhereUniqueInput
  }

  /**
   * Rooms findFirst
   */
  export type RoomsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomsOrderByWithRelationInput | RoomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomsScalarFieldEnum | RoomsScalarFieldEnum[]
  }

  /**
   * Rooms findFirstOrThrow
   */
  export type RoomsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomsOrderByWithRelationInput | RoomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomsScalarFieldEnum | RoomsScalarFieldEnum[]
  }

  /**
   * Rooms findMany
   */
  export type RoomsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomsOrderByWithRelationInput | RoomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomsScalarFieldEnum | RoomsScalarFieldEnum[]
  }

  /**
   * Rooms create
   */
  export type RoomsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * The data needed to create a Rooms.
     */
    data: XOR<RoomsCreateInput, RoomsUncheckedCreateInput>
  }

  /**
   * Rooms createMany
   */
  export type RoomsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomsCreateManyInput | RoomsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rooms createManyAndReturn
   */
  export type RoomsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomsCreateManyInput | RoomsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Rooms update
   */
  export type RoomsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * The data needed to update a Rooms.
     */
    data: XOR<RoomsUpdateInput, RoomsUncheckedUpdateInput>
    /**
     * Choose, which Rooms to update.
     */
    where: RoomsWhereUniqueInput
  }

  /**
   * Rooms updateMany
   */
  export type RoomsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomsUpdateManyMutationInput, RoomsUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomsWhereInput
  }

  /**
   * Rooms upsert
   */
  export type RoomsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * The filter to search for the Rooms to update in case it exists.
     */
    where: RoomsWhereUniqueInput
    /**
     * In case the Rooms found by the `where` argument doesn't exist, create a new Rooms with this data.
     */
    create: XOR<RoomsCreateInput, RoomsUncheckedCreateInput>
    /**
     * In case the Rooms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomsUpdateInput, RoomsUncheckedUpdateInput>
  }

  /**
   * Rooms delete
   */
  export type RoomsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
    /**
     * Filter which Rooms to delete.
     */
    where: RoomsWhereUniqueInput
  }

  /**
   * Rooms deleteMany
   */
  export type RoomsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomsWhereInput
  }

  /**
   * Rooms without action
   */
  export type RoomsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rooms
     */
    select?: RoomsSelect<ExtArgs> | null
  }


  /**
   * Model MedicalHistory
   */

  export type AggregateMedicalHistory = {
    _count: MedicalHistoryCountAggregateOutputType | null
    _avg: MedicalHistoryAvgAggregateOutputType | null
    _sum: MedicalHistorySumAggregateOutputType | null
    _min: MedicalHistoryMinAggregateOutputType | null
    _max: MedicalHistoryMaxAggregateOutputType | null
  }

  export type MedicalHistoryAvgAggregateOutputType = {
    history_id: number | null
    patient_id: number | null
  }

  export type MedicalHistorySumAggregateOutputType = {
    history_id: number | null
    patient_id: number | null
  }

  export type MedicalHistoryMinAggregateOutputType = {
    history_id: number | null
    patient_id: number | null
    treatment: string | null
    treatment_date: Date | null
  }

  export type MedicalHistoryMaxAggregateOutputType = {
    history_id: number | null
    patient_id: number | null
    treatment: string | null
    treatment_date: Date | null
  }

  export type MedicalHistoryCountAggregateOutputType = {
    history_id: number
    patient_id: number
    treatment: number
    treatment_date: number
    _all: number
  }


  export type MedicalHistoryAvgAggregateInputType = {
    history_id?: true
    patient_id?: true
  }

  export type MedicalHistorySumAggregateInputType = {
    history_id?: true
    patient_id?: true
  }

  export type MedicalHistoryMinAggregateInputType = {
    history_id?: true
    patient_id?: true
    treatment?: true
    treatment_date?: true
  }

  export type MedicalHistoryMaxAggregateInputType = {
    history_id?: true
    patient_id?: true
    treatment?: true
    treatment_date?: true
  }

  export type MedicalHistoryCountAggregateInputType = {
    history_id?: true
    patient_id?: true
    treatment?: true
    treatment_date?: true
    _all?: true
  }

  export type MedicalHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalHistory to aggregate.
     */
    where?: MedicalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalHistories to fetch.
     */
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalHistories
    **/
    _count?: true | MedicalHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalHistoryMaxAggregateInputType
  }

  export type GetMedicalHistoryAggregateType<T extends MedicalHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalHistory[P]>
      : GetScalarType<T[P], AggregateMedicalHistory[P]>
  }




  export type MedicalHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalHistoryWhereInput
    orderBy?: MedicalHistoryOrderByWithAggregationInput | MedicalHistoryOrderByWithAggregationInput[]
    by: MedicalHistoryScalarFieldEnum[] | MedicalHistoryScalarFieldEnum
    having?: MedicalHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalHistoryCountAggregateInputType | true
    _avg?: MedicalHistoryAvgAggregateInputType
    _sum?: MedicalHistorySumAggregateInputType
    _min?: MedicalHistoryMinAggregateInputType
    _max?: MedicalHistoryMaxAggregateInputType
  }

  export type MedicalHistoryGroupByOutputType = {
    history_id: number
    patient_id: number
    treatment: string
    treatment_date: Date
    _count: MedicalHistoryCountAggregateOutputType | null
    _avg: MedicalHistoryAvgAggregateOutputType | null
    _sum: MedicalHistorySumAggregateOutputType | null
    _min: MedicalHistoryMinAggregateOutputType | null
    _max: MedicalHistoryMaxAggregateOutputType | null
  }

  type GetMedicalHistoryGroupByPayload<T extends MedicalHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalHistoryGroupByOutputType[P]>
        }
      >
    >


  export type MedicalHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    history_id?: boolean
    patient_id?: boolean
    treatment?: boolean
    treatment_date?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalHistory"]>

  export type MedicalHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    history_id?: boolean
    patient_id?: boolean
    treatment?: boolean
    treatment_date?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalHistory"]>

  export type MedicalHistorySelectScalar = {
    history_id?: boolean
    patient_id?: boolean
    treatment?: boolean
    treatment_date?: boolean
  }

  export type MedicalHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }
  export type MedicalHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }

  export type $MedicalHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalHistory"
    objects: {
      patient: Prisma.$PatientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      history_id: number
      patient_id: number
      treatment: string
      treatment_date: Date
    }, ExtArgs["result"]["medicalHistory"]>
    composites: {}
  }

  type MedicalHistoryGetPayload<S extends boolean | null | undefined | MedicalHistoryDefaultArgs> = $Result.GetResult<Prisma.$MedicalHistoryPayload, S>

  type MedicalHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicalHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicalHistoryCountAggregateInputType | true
    }

  export interface MedicalHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalHistory'], meta: { name: 'MedicalHistory' } }
    /**
     * Find zero or one MedicalHistory that matches the filter.
     * @param {MedicalHistoryFindUniqueArgs} args - Arguments to find a MedicalHistory
     * @example
     * // Get one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalHistoryFindUniqueArgs>(args: SelectSubset<T, MedicalHistoryFindUniqueArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MedicalHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicalHistoryFindUniqueOrThrowArgs} args - Arguments to find a MedicalHistory
     * @example
     * // Get one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MedicalHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryFindFirstArgs} args - Arguments to find a MedicalHistory
     * @example
     * // Get one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalHistoryFindFirstArgs>(args?: SelectSubset<T, MedicalHistoryFindFirstArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MedicalHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryFindFirstOrThrowArgs} args - Arguments to find a MedicalHistory
     * @example
     * // Get one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MedicalHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalHistories
     * const medicalHistories = await prisma.medicalHistory.findMany()
     * 
     * // Get first 10 MedicalHistories
     * const medicalHistories = await prisma.medicalHistory.findMany({ take: 10 })
     * 
     * // Only select the `history_id`
     * const medicalHistoryWithHistory_idOnly = await prisma.medicalHistory.findMany({ select: { history_id: true } })
     * 
     */
    findMany<T extends MedicalHistoryFindManyArgs>(args?: SelectSubset<T, MedicalHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MedicalHistory.
     * @param {MedicalHistoryCreateArgs} args - Arguments to create a MedicalHistory.
     * @example
     * // Create one MedicalHistory
     * const MedicalHistory = await prisma.medicalHistory.create({
     *   data: {
     *     // ... data to create a MedicalHistory
     *   }
     * })
     * 
     */
    create<T extends MedicalHistoryCreateArgs>(args: SelectSubset<T, MedicalHistoryCreateArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MedicalHistories.
     * @param {MedicalHistoryCreateManyArgs} args - Arguments to create many MedicalHistories.
     * @example
     * // Create many MedicalHistories
     * const medicalHistory = await prisma.medicalHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalHistoryCreateManyArgs>(args?: SelectSubset<T, MedicalHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalHistories and returns the data saved in the database.
     * @param {MedicalHistoryCreateManyAndReturnArgs} args - Arguments to create many MedicalHistories.
     * @example
     * // Create many MedicalHistories
     * const medicalHistory = await prisma.medicalHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalHistories and only return the `history_id`
     * const medicalHistoryWithHistory_idOnly = await prisma.medicalHistory.createManyAndReturn({ 
     *   select: { history_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MedicalHistory.
     * @param {MedicalHistoryDeleteArgs} args - Arguments to delete one MedicalHistory.
     * @example
     * // Delete one MedicalHistory
     * const MedicalHistory = await prisma.medicalHistory.delete({
     *   where: {
     *     // ... filter to delete one MedicalHistory
     *   }
     * })
     * 
     */
    delete<T extends MedicalHistoryDeleteArgs>(args: SelectSubset<T, MedicalHistoryDeleteArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MedicalHistory.
     * @param {MedicalHistoryUpdateArgs} args - Arguments to update one MedicalHistory.
     * @example
     * // Update one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalHistoryUpdateArgs>(args: SelectSubset<T, MedicalHistoryUpdateArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MedicalHistories.
     * @param {MedicalHistoryDeleteManyArgs} args - Arguments to filter MedicalHistories to delete.
     * @example
     * // Delete a few MedicalHistories
     * const { count } = await prisma.medicalHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalHistoryDeleteManyArgs>(args?: SelectSubset<T, MedicalHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalHistories
     * const medicalHistory = await prisma.medicalHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalHistoryUpdateManyArgs>(args: SelectSubset<T, MedicalHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalHistory.
     * @param {MedicalHistoryUpsertArgs} args - Arguments to update or create a MedicalHistory.
     * @example
     * // Update or create a MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.upsert({
     *   create: {
     *     // ... data to create a MedicalHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalHistory we want to update
     *   }
     * })
     */
    upsert<T extends MedicalHistoryUpsertArgs>(args: SelectSubset<T, MedicalHistoryUpsertArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MedicalHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryCountArgs} args - Arguments to filter MedicalHistories to count.
     * @example
     * // Count the number of MedicalHistories
     * const count = await prisma.medicalHistory.count({
     *   where: {
     *     // ... the filter for the MedicalHistories we want to count
     *   }
     * })
    **/
    count<T extends MedicalHistoryCountArgs>(
      args?: Subset<T, MedicalHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalHistoryAggregateArgs>(args: Subset<T, MedicalHistoryAggregateArgs>): Prisma.PrismaPromise<GetMedicalHistoryAggregateType<T>>

    /**
     * Group by MedicalHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalHistoryGroupByArgs['orderBy'] }
        : { orderBy?: MedicalHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalHistory model
   */
  readonly fields: MedicalHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientsDefaultArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalHistory model
   */ 
  interface MedicalHistoryFieldRefs {
    readonly history_id: FieldRef<"MedicalHistory", 'Int'>
    readonly patient_id: FieldRef<"MedicalHistory", 'Int'>
    readonly treatment: FieldRef<"MedicalHistory", 'String'>
    readonly treatment_date: FieldRef<"MedicalHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalHistory findUnique
   */
  export type MedicalHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistory to fetch.
     */
    where: MedicalHistoryWhereUniqueInput
  }

  /**
   * MedicalHistory findUniqueOrThrow
   */
  export type MedicalHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistory to fetch.
     */
    where: MedicalHistoryWhereUniqueInput
  }

  /**
   * MedicalHistory findFirst
   */
  export type MedicalHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistory to fetch.
     */
    where?: MedicalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalHistories to fetch.
     */
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalHistories.
     */
    cursor?: MedicalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalHistories.
     */
    distinct?: MedicalHistoryScalarFieldEnum | MedicalHistoryScalarFieldEnum[]
  }

  /**
   * MedicalHistory findFirstOrThrow
   */
  export type MedicalHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistory to fetch.
     */
    where?: MedicalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalHistories to fetch.
     */
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalHistories.
     */
    cursor?: MedicalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalHistories.
     */
    distinct?: MedicalHistoryScalarFieldEnum | MedicalHistoryScalarFieldEnum[]
  }

  /**
   * MedicalHistory findMany
   */
  export type MedicalHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistories to fetch.
     */
    where?: MedicalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalHistories to fetch.
     */
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalHistories.
     */
    cursor?: MedicalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalHistories.
     */
    skip?: number
    distinct?: MedicalHistoryScalarFieldEnum | MedicalHistoryScalarFieldEnum[]
  }

  /**
   * MedicalHistory create
   */
  export type MedicalHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalHistory.
     */
    data: XOR<MedicalHistoryCreateInput, MedicalHistoryUncheckedCreateInput>
  }

  /**
   * MedicalHistory createMany
   */
  export type MedicalHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalHistories.
     */
    data: MedicalHistoryCreateManyInput | MedicalHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalHistory createManyAndReturn
   */
  export type MedicalHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MedicalHistories.
     */
    data: MedicalHistoryCreateManyInput | MedicalHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalHistory update
   */
  export type MedicalHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalHistory.
     */
    data: XOR<MedicalHistoryUpdateInput, MedicalHistoryUncheckedUpdateInput>
    /**
     * Choose, which MedicalHistory to update.
     */
    where: MedicalHistoryWhereUniqueInput
  }

  /**
   * MedicalHistory updateMany
   */
  export type MedicalHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalHistories.
     */
    data: XOR<MedicalHistoryUpdateManyMutationInput, MedicalHistoryUncheckedUpdateManyInput>
    /**
     * Filter which MedicalHistories to update
     */
    where?: MedicalHistoryWhereInput
  }

  /**
   * MedicalHistory upsert
   */
  export type MedicalHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalHistory to update in case it exists.
     */
    where: MedicalHistoryWhereUniqueInput
    /**
     * In case the MedicalHistory found by the `where` argument doesn't exist, create a new MedicalHistory with this data.
     */
    create: XOR<MedicalHistoryCreateInput, MedicalHistoryUncheckedCreateInput>
    /**
     * In case the MedicalHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalHistoryUpdateInput, MedicalHistoryUncheckedUpdateInput>
  }

  /**
   * MedicalHistory delete
   */
  export type MedicalHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter which MedicalHistory to delete.
     */
    where: MedicalHistoryWhereUniqueInput
  }

  /**
   * MedicalHistory deleteMany
   */
  export type MedicalHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalHistories to delete
     */
    where?: MedicalHistoryWhereInput
  }

  /**
   * MedicalHistory without action
   */
  export type MedicalHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Diagnosis
   */

  export type AggregateDiagnosis = {
    _count: DiagnosisCountAggregateOutputType | null
    _avg: DiagnosisAvgAggregateOutputType | null
    _sum: DiagnosisSumAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  export type DiagnosisAvgAggregateOutputType = {
    diagnosis_id: number | null
    patient_id: number | null
    doctor_id: number | null
  }

  export type DiagnosisSumAggregateOutputType = {
    diagnosis_id: number | null
    patient_id: number | null
    doctor_id: number | null
  }

  export type DiagnosisMinAggregateOutputType = {
    diagnosis_id: number | null
    patient_id: number | null
    doctor_id: number | null
    diagnosis_description: string | null
    diagnosis_date: Date | null
  }

  export type DiagnosisMaxAggregateOutputType = {
    diagnosis_id: number | null
    patient_id: number | null
    doctor_id: number | null
    diagnosis_description: string | null
    diagnosis_date: Date | null
  }

  export type DiagnosisCountAggregateOutputType = {
    diagnosis_id: number
    patient_id: number
    doctor_id: number
    diagnosis_description: number
    diagnosis_date: number
    _all: number
  }


  export type DiagnosisAvgAggregateInputType = {
    diagnosis_id?: true
    patient_id?: true
    doctor_id?: true
  }

  export type DiagnosisSumAggregateInputType = {
    diagnosis_id?: true
    patient_id?: true
    doctor_id?: true
  }

  export type DiagnosisMinAggregateInputType = {
    diagnosis_id?: true
    patient_id?: true
    doctor_id?: true
    diagnosis_description?: true
    diagnosis_date?: true
  }

  export type DiagnosisMaxAggregateInputType = {
    diagnosis_id?: true
    patient_id?: true
    doctor_id?: true
    diagnosis_description?: true
    diagnosis_date?: true
  }

  export type DiagnosisCountAggregateInputType = {
    diagnosis_id?: true
    patient_id?: true
    doctor_id?: true
    diagnosis_description?: true
    diagnosis_date?: true
    _all?: true
  }

  export type DiagnosisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnosis to aggregate.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Diagnoses
    **/
    _count?: true | DiagnosisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiagnosisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiagnosisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiagnosisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiagnosisMaxAggregateInputType
  }

  export type GetDiagnosisAggregateType<T extends DiagnosisAggregateArgs> = {
        [P in keyof T & keyof AggregateDiagnosis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiagnosis[P]>
      : GetScalarType<T[P], AggregateDiagnosis[P]>
  }




  export type DiagnosisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiagnosisWhereInput
    orderBy?: DiagnosisOrderByWithAggregationInput | DiagnosisOrderByWithAggregationInput[]
    by: DiagnosisScalarFieldEnum[] | DiagnosisScalarFieldEnum
    having?: DiagnosisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiagnosisCountAggregateInputType | true
    _avg?: DiagnosisAvgAggregateInputType
    _sum?: DiagnosisSumAggregateInputType
    _min?: DiagnosisMinAggregateInputType
    _max?: DiagnosisMaxAggregateInputType
  }

  export type DiagnosisGroupByOutputType = {
    diagnosis_id: number
    patient_id: number
    doctor_id: number
    diagnosis_description: string
    diagnosis_date: Date
    _count: DiagnosisCountAggregateOutputType | null
    _avg: DiagnosisAvgAggregateOutputType | null
    _sum: DiagnosisSumAggregateOutputType | null
    _min: DiagnosisMinAggregateOutputType | null
    _max: DiagnosisMaxAggregateOutputType | null
  }

  type GetDiagnosisGroupByPayload<T extends DiagnosisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiagnosisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiagnosisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
            : GetScalarType<T[P], DiagnosisGroupByOutputType[P]>
        }
      >
    >


  export type DiagnosisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    diagnosis_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    diagnosis_description?: boolean
    diagnosis_date?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    diagnosis_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    diagnosis_description?: boolean
    diagnosis_date?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["diagnosis"]>

  export type DiagnosisSelectScalar = {
    diagnosis_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    diagnosis_description?: boolean
    diagnosis_date?: boolean
  }

  export type DiagnosisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }
  export type DiagnosisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }

  export type $DiagnosisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Diagnosis"
    objects: {
      patient: Prisma.$PatientsPayload<ExtArgs>
      doctor: Prisma.$DoctorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      diagnosis_id: number
      patient_id: number
      doctor_id: number
      diagnosis_description: string
      diagnosis_date: Date
    }, ExtArgs["result"]["diagnosis"]>
    composites: {}
  }

  type DiagnosisGetPayload<S extends boolean | null | undefined | DiagnosisDefaultArgs> = $Result.GetResult<Prisma.$DiagnosisPayload, S>

  type DiagnosisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DiagnosisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DiagnosisCountAggregateInputType | true
    }

  export interface DiagnosisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Diagnosis'], meta: { name: 'Diagnosis' } }
    /**
     * Find zero or one Diagnosis that matches the filter.
     * @param {DiagnosisFindUniqueArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiagnosisFindUniqueArgs>(args: SelectSubset<T, DiagnosisFindUniqueArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Diagnosis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DiagnosisFindUniqueOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiagnosisFindUniqueOrThrowArgs>(args: SelectSubset<T, DiagnosisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiagnosisFindFirstArgs>(args?: SelectSubset<T, DiagnosisFindFirstArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Diagnosis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindFirstOrThrowArgs} args - Arguments to find a Diagnosis
     * @example
     * // Get one Diagnosis
     * const diagnosis = await prisma.diagnosis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiagnosisFindFirstOrThrowArgs>(args?: SelectSubset<T, DiagnosisFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Diagnoses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany()
     * 
     * // Get first 10 Diagnoses
     * const diagnoses = await prisma.diagnosis.findMany({ take: 10 })
     * 
     * // Only select the `diagnosis_id`
     * const diagnosisWithDiagnosis_idOnly = await prisma.diagnosis.findMany({ select: { diagnosis_id: true } })
     * 
     */
    findMany<T extends DiagnosisFindManyArgs>(args?: SelectSubset<T, DiagnosisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Diagnosis.
     * @param {DiagnosisCreateArgs} args - Arguments to create a Diagnosis.
     * @example
     * // Create one Diagnosis
     * const Diagnosis = await prisma.diagnosis.create({
     *   data: {
     *     // ... data to create a Diagnosis
     *   }
     * })
     * 
     */
    create<T extends DiagnosisCreateArgs>(args: SelectSubset<T, DiagnosisCreateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Diagnoses.
     * @param {DiagnosisCreateManyArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiagnosisCreateManyArgs>(args?: SelectSubset<T, DiagnosisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Diagnoses and returns the data saved in the database.
     * @param {DiagnosisCreateManyAndReturnArgs} args - Arguments to create many Diagnoses.
     * @example
     * // Create many Diagnoses
     * const diagnosis = await prisma.diagnosis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Diagnoses and only return the `diagnosis_id`
     * const diagnosisWithDiagnosis_idOnly = await prisma.diagnosis.createManyAndReturn({ 
     *   select: { diagnosis_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiagnosisCreateManyAndReturnArgs>(args?: SelectSubset<T, DiagnosisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Diagnosis.
     * @param {DiagnosisDeleteArgs} args - Arguments to delete one Diagnosis.
     * @example
     * // Delete one Diagnosis
     * const Diagnosis = await prisma.diagnosis.delete({
     *   where: {
     *     // ... filter to delete one Diagnosis
     *   }
     * })
     * 
     */
    delete<T extends DiagnosisDeleteArgs>(args: SelectSubset<T, DiagnosisDeleteArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Diagnosis.
     * @param {DiagnosisUpdateArgs} args - Arguments to update one Diagnosis.
     * @example
     * // Update one Diagnosis
     * const diagnosis = await prisma.diagnosis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiagnosisUpdateArgs>(args: SelectSubset<T, DiagnosisUpdateArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Diagnoses.
     * @param {DiagnosisDeleteManyArgs} args - Arguments to filter Diagnoses to delete.
     * @example
     * // Delete a few Diagnoses
     * const { count } = await prisma.diagnosis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiagnosisDeleteManyArgs>(args?: SelectSubset<T, DiagnosisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Diagnoses
     * const diagnosis = await prisma.diagnosis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiagnosisUpdateManyArgs>(args: SelectSubset<T, DiagnosisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Diagnosis.
     * @param {DiagnosisUpsertArgs} args - Arguments to update or create a Diagnosis.
     * @example
     * // Update or create a Diagnosis
     * const diagnosis = await prisma.diagnosis.upsert({
     *   create: {
     *     // ... data to create a Diagnosis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Diagnosis we want to update
     *   }
     * })
     */
    upsert<T extends DiagnosisUpsertArgs>(args: SelectSubset<T, DiagnosisUpsertArgs<ExtArgs>>): Prisma__DiagnosisClient<$Result.GetResult<Prisma.$DiagnosisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Diagnoses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisCountArgs} args - Arguments to filter Diagnoses to count.
     * @example
     * // Count the number of Diagnoses
     * const count = await prisma.diagnosis.count({
     *   where: {
     *     // ... the filter for the Diagnoses we want to count
     *   }
     * })
    **/
    count<T extends DiagnosisCountArgs>(
      args?: Subset<T, DiagnosisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiagnosisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiagnosisAggregateArgs>(args: Subset<T, DiagnosisAggregateArgs>): Prisma.PrismaPromise<GetDiagnosisAggregateType<T>>

    /**
     * Group by Diagnosis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiagnosisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiagnosisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiagnosisGroupByArgs['orderBy'] }
        : { orderBy?: DiagnosisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiagnosisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiagnosisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Diagnosis model
   */
  readonly fields: DiagnosisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Diagnosis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiagnosisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientsDefaultArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends DoctorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorsDefaultArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Diagnosis model
   */ 
  interface DiagnosisFieldRefs {
    readonly diagnosis_id: FieldRef<"Diagnosis", 'Int'>
    readonly patient_id: FieldRef<"Diagnosis", 'Int'>
    readonly doctor_id: FieldRef<"Diagnosis", 'Int'>
    readonly diagnosis_description: FieldRef<"Diagnosis", 'String'>
    readonly diagnosis_date: FieldRef<"Diagnosis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Diagnosis findUnique
   */
  export type DiagnosisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findUniqueOrThrow
   */
  export type DiagnosisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis findFirst
   */
  export type DiagnosisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findFirstOrThrow
   */
  export type DiagnosisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnosis to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Diagnoses.
     */
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis findMany
   */
  export type DiagnosisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter, which Diagnoses to fetch.
     */
    where?: DiagnosisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Diagnoses to fetch.
     */
    orderBy?: DiagnosisOrderByWithRelationInput | DiagnosisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Diagnoses.
     */
    cursor?: DiagnosisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Diagnoses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Diagnoses.
     */
    skip?: number
    distinct?: DiagnosisScalarFieldEnum | DiagnosisScalarFieldEnum[]
  }

  /**
   * Diagnosis create
   */
  export type DiagnosisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to create a Diagnosis.
     */
    data: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
  }

  /**
   * Diagnosis createMany
   */
  export type DiagnosisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Diagnosis createManyAndReturn
   */
  export type DiagnosisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Diagnoses.
     */
    data: DiagnosisCreateManyInput | DiagnosisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Diagnosis update
   */
  export type DiagnosisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The data needed to update a Diagnosis.
     */
    data: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
    /**
     * Choose, which Diagnosis to update.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis updateMany
   */
  export type DiagnosisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Diagnoses.
     */
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyInput>
    /**
     * Filter which Diagnoses to update
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis upsert
   */
  export type DiagnosisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * The filter to search for the Diagnosis to update in case it exists.
     */
    where: DiagnosisWhereUniqueInput
    /**
     * In case the Diagnosis found by the `where` argument doesn't exist, create a new Diagnosis with this data.
     */
    create: XOR<DiagnosisCreateInput, DiagnosisUncheckedCreateInput>
    /**
     * In case the Diagnosis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiagnosisUpdateInput, DiagnosisUncheckedUpdateInput>
  }

  /**
   * Diagnosis delete
   */
  export type DiagnosisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
    /**
     * Filter which Diagnosis to delete.
     */
    where: DiagnosisWhereUniqueInput
  }

  /**
   * Diagnosis deleteMany
   */
  export type DiagnosisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Diagnoses to delete
     */
    where?: DiagnosisWhereInput
  }

  /**
   * Diagnosis without action
   */
  export type DiagnosisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Diagnosis
     */
    select?: DiagnosisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiagnosisInclude<ExtArgs> | null
  }


  /**
   * Model Medications
   */

  export type AggregateMedications = {
    _count: MedicationsCountAggregateOutputType | null
    _avg: MedicationsAvgAggregateOutputType | null
    _sum: MedicationsSumAggregateOutputType | null
    _min: MedicationsMinAggregateOutputType | null
    _max: MedicationsMaxAggregateOutputType | null
  }

  export type MedicationsAvgAggregateOutputType = {
    medication_id: number | null
  }

  export type MedicationsSumAggregateOutputType = {
    medication_id: number | null
  }

  export type MedicationsMinAggregateOutputType = {
    medication_id: number | null
    medication_name: string | null
    dosage: string | null
    side_effects: string | null
  }

  export type MedicationsMaxAggregateOutputType = {
    medication_id: number | null
    medication_name: string | null
    dosage: string | null
    side_effects: string | null
  }

  export type MedicationsCountAggregateOutputType = {
    medication_id: number
    medication_name: number
    dosage: number
    side_effects: number
    _all: number
  }


  export type MedicationsAvgAggregateInputType = {
    medication_id?: true
  }

  export type MedicationsSumAggregateInputType = {
    medication_id?: true
  }

  export type MedicationsMinAggregateInputType = {
    medication_id?: true
    medication_name?: true
    dosage?: true
    side_effects?: true
  }

  export type MedicationsMaxAggregateInputType = {
    medication_id?: true
    medication_name?: true
    dosage?: true
    side_effects?: true
  }

  export type MedicationsCountAggregateInputType = {
    medication_id?: true
    medication_name?: true
    dosage?: true
    side_effects?: true
    _all?: true
  }

  export type MedicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to aggregate.
     */
    where?: MedicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationsOrderByWithRelationInput | MedicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationsMaxAggregateInputType
  }

  export type GetMedicationsAggregateType<T extends MedicationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMedications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedications[P]>
      : GetScalarType<T[P], AggregateMedications[P]>
  }




  export type MedicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationsWhereInput
    orderBy?: MedicationsOrderByWithAggregationInput | MedicationsOrderByWithAggregationInput[]
    by: MedicationsScalarFieldEnum[] | MedicationsScalarFieldEnum
    having?: MedicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationsCountAggregateInputType | true
    _avg?: MedicationsAvgAggregateInputType
    _sum?: MedicationsSumAggregateInputType
    _min?: MedicationsMinAggregateInputType
    _max?: MedicationsMaxAggregateInputType
  }

  export type MedicationsGroupByOutputType = {
    medication_id: number
    medication_name: string
    dosage: string
    side_effects: string
    _count: MedicationsCountAggregateOutputType | null
    _avg: MedicationsAvgAggregateOutputType | null
    _sum: MedicationsSumAggregateOutputType | null
    _min: MedicationsMinAggregateOutputType | null
    _max: MedicationsMaxAggregateOutputType | null
  }

  type GetMedicationsGroupByPayload<T extends MedicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationsGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationsGroupByOutputType[P]>
        }
      >
    >


  export type MedicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    medication_id?: boolean
    medication_name?: boolean
    dosage?: boolean
    side_effects?: boolean
    treatments?: boolean | Medications$treatmentsArgs<ExtArgs>
    _count?: boolean | MedicationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medications"]>

  export type MedicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    medication_id?: boolean
    medication_name?: boolean
    dosage?: boolean
    side_effects?: boolean
  }, ExtArgs["result"]["medications"]>

  export type MedicationsSelectScalar = {
    medication_id?: boolean
    medication_name?: boolean
    dosage?: boolean
    side_effects?: boolean
  }

  export type MedicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treatments?: boolean | Medications$treatmentsArgs<ExtArgs>
    _count?: boolean | MedicationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MedicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medications"
    objects: {
      treatments: Prisma.$TreatmentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      medication_id: number
      medication_name: string
      dosage: string
      side_effects: string
    }, ExtArgs["result"]["medications"]>
    composites: {}
  }

  type MedicationsGetPayload<S extends boolean | null | undefined | MedicationsDefaultArgs> = $Result.GetResult<Prisma.$MedicationsPayload, S>

  type MedicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicationsCountAggregateInputType | true
    }

  export interface MedicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medications'], meta: { name: 'Medications' } }
    /**
     * Find zero or one Medications that matches the filter.
     * @param {MedicationsFindUniqueArgs} args - Arguments to find a Medications
     * @example
     * // Get one Medications
     * const medications = await prisma.medications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationsFindUniqueArgs>(args: SelectSubset<T, MedicationsFindUniqueArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicationsFindUniqueOrThrowArgs} args - Arguments to find a Medications
     * @example
     * // Get one Medications
     * const medications = await prisma.medications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationsFindFirstArgs} args - Arguments to find a Medications
     * @example
     * // Get one Medications
     * const medications = await prisma.medications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationsFindFirstArgs>(args?: SelectSubset<T, MedicationsFindFirstArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationsFindFirstOrThrowArgs} args - Arguments to find a Medications
     * @example
     * // Get one Medications
     * const medications = await prisma.medications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medications.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medications.findMany({ take: 10 })
     * 
     * // Only select the `medication_id`
     * const medicationsWithMedication_idOnly = await prisma.medications.findMany({ select: { medication_id: true } })
     * 
     */
    findMany<T extends MedicationsFindManyArgs>(args?: SelectSubset<T, MedicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medications.
     * @param {MedicationsCreateArgs} args - Arguments to create a Medications.
     * @example
     * // Create one Medications
     * const Medications = await prisma.medications.create({
     *   data: {
     *     // ... data to create a Medications
     *   }
     * })
     * 
     */
    create<T extends MedicationsCreateArgs>(args: SelectSubset<T, MedicationsCreateArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medications.
     * @param {MedicationsCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medications = await prisma.medications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationsCreateManyArgs>(args?: SelectSubset<T, MedicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medications and returns the data saved in the database.
     * @param {MedicationsCreateManyAndReturnArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medications = await prisma.medications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medications and only return the `medication_id`
     * const medicationsWithMedication_idOnly = await prisma.medications.createManyAndReturn({ 
     *   select: { medication_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medications.
     * @param {MedicationsDeleteArgs} args - Arguments to delete one Medications.
     * @example
     * // Delete one Medications
     * const Medications = await prisma.medications.delete({
     *   where: {
     *     // ... filter to delete one Medications
     *   }
     * })
     * 
     */
    delete<T extends MedicationsDeleteArgs>(args: SelectSubset<T, MedicationsDeleteArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medications.
     * @param {MedicationsUpdateArgs} args - Arguments to update one Medications.
     * @example
     * // Update one Medications
     * const medications = await prisma.medications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationsUpdateArgs>(args: SelectSubset<T, MedicationsUpdateArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medications.
     * @param {MedicationsDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationsDeleteManyArgs>(args?: SelectSubset<T, MedicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medications = await prisma.medications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationsUpdateManyArgs>(args: SelectSubset<T, MedicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medications.
     * @param {MedicationsUpsertArgs} args - Arguments to update or create a Medications.
     * @example
     * // Update or create a Medications
     * const medications = await prisma.medications.upsert({
     *   create: {
     *     // ... data to create a Medications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medications we want to update
     *   }
     * })
     */
    upsert<T extends MedicationsUpsertArgs>(args: SelectSubset<T, MedicationsUpsertArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationsCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medications.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationsCountArgs>(
      args?: Subset<T, MedicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationsAggregateArgs>(args: Subset<T, MedicationsAggregateArgs>): Prisma.PrismaPromise<GetMedicationsAggregateType<T>>

    /**
     * Group by Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationsGroupByArgs['orderBy'] }
        : { orderBy?: MedicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medications model
   */
  readonly fields: MedicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    treatments<T extends Medications$treatmentsArgs<ExtArgs> = {}>(args?: Subset<T, Medications$treatmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medications model
   */ 
  interface MedicationsFieldRefs {
    readonly medication_id: FieldRef<"Medications", 'Int'>
    readonly medication_name: FieldRef<"Medications", 'String'>
    readonly dosage: FieldRef<"Medications", 'String'>
    readonly side_effects: FieldRef<"Medications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Medications findUnique
   */
  export type MedicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where: MedicationsWhereUniqueInput
  }

  /**
   * Medications findUniqueOrThrow
   */
  export type MedicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where: MedicationsWhereUniqueInput
  }

  /**
   * Medications findFirst
   */
  export type MedicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationsOrderByWithRelationInput | MedicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationsScalarFieldEnum | MedicationsScalarFieldEnum[]
  }

  /**
   * Medications findFirstOrThrow
   */
  export type MedicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationsOrderByWithRelationInput | MedicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationsScalarFieldEnum | MedicationsScalarFieldEnum[]
  }

  /**
   * Medications findMany
   */
  export type MedicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationsOrderByWithRelationInput | MedicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationsScalarFieldEnum | MedicationsScalarFieldEnum[]
  }

  /**
   * Medications create
   */
  export type MedicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Medications.
     */
    data: XOR<MedicationsCreateInput, MedicationsUncheckedCreateInput>
  }

  /**
   * Medications createMany
   */
  export type MedicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationsCreateManyInput | MedicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medications createManyAndReturn
   */
  export type MedicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Medications.
     */
    data: MedicationsCreateManyInput | MedicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medications update
   */
  export type MedicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Medications.
     */
    data: XOR<MedicationsUpdateInput, MedicationsUncheckedUpdateInput>
    /**
     * Choose, which Medications to update.
     */
    where: MedicationsWhereUniqueInput
  }

  /**
   * Medications updateMany
   */
  export type MedicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationsUpdateManyMutationInput, MedicationsUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationsWhereInput
  }

  /**
   * Medications upsert
   */
  export type MedicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Medications to update in case it exists.
     */
    where: MedicationsWhereUniqueInput
    /**
     * In case the Medications found by the `where` argument doesn't exist, create a new Medications with this data.
     */
    create: XOR<MedicationsCreateInput, MedicationsUncheckedCreateInput>
    /**
     * In case the Medications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationsUpdateInput, MedicationsUncheckedUpdateInput>
  }

  /**
   * Medications delete
   */
  export type MedicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
    /**
     * Filter which Medications to delete.
     */
    where: MedicationsWhereUniqueInput
  }

  /**
   * Medications deleteMany
   */
  export type MedicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationsWhereInput
  }

  /**
   * Medications.treatments
   */
  export type Medications$treatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    where?: TreatmentsWhereInput
    orderBy?: TreatmentsOrderByWithRelationInput | TreatmentsOrderByWithRelationInput[]
    cursor?: TreatmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TreatmentsScalarFieldEnum | TreatmentsScalarFieldEnum[]
  }

  /**
   * Medications without action
   */
  export type MedicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medications
     */
    select?: MedicationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationsInclude<ExtArgs> | null
  }


  /**
   * Model Treatments
   */

  export type AggregateTreatments = {
    _count: TreatmentsCountAggregateOutputType | null
    _avg: TreatmentsAvgAggregateOutputType | null
    _sum: TreatmentsSumAggregateOutputType | null
    _min: TreatmentsMinAggregateOutputType | null
    _max: TreatmentsMaxAggregateOutputType | null
  }

  export type TreatmentsAvgAggregateOutputType = {
    treatment_id: number | null
    patient_id: number | null
    doctor_id: number | null
    medication_id: number | null
  }

  export type TreatmentsSumAggregateOutputType = {
    treatment_id: number | null
    patient_id: number | null
    doctor_id: number | null
    medication_id: number | null
  }

  export type TreatmentsMinAggregateOutputType = {
    treatment_id: number | null
    patient_id: number | null
    doctor_id: number | null
    medication_id: number | null
    treatment_description: string | null
    treatment_date: Date | null
  }

  export type TreatmentsMaxAggregateOutputType = {
    treatment_id: number | null
    patient_id: number | null
    doctor_id: number | null
    medication_id: number | null
    treatment_description: string | null
    treatment_date: Date | null
  }

  export type TreatmentsCountAggregateOutputType = {
    treatment_id: number
    patient_id: number
    doctor_id: number
    medication_id: number
    treatment_description: number
    treatment_date: number
    _all: number
  }


  export type TreatmentsAvgAggregateInputType = {
    treatment_id?: true
    patient_id?: true
    doctor_id?: true
    medication_id?: true
  }

  export type TreatmentsSumAggregateInputType = {
    treatment_id?: true
    patient_id?: true
    doctor_id?: true
    medication_id?: true
  }

  export type TreatmentsMinAggregateInputType = {
    treatment_id?: true
    patient_id?: true
    doctor_id?: true
    medication_id?: true
    treatment_description?: true
    treatment_date?: true
  }

  export type TreatmentsMaxAggregateInputType = {
    treatment_id?: true
    patient_id?: true
    doctor_id?: true
    medication_id?: true
    treatment_description?: true
    treatment_date?: true
  }

  export type TreatmentsCountAggregateInputType = {
    treatment_id?: true
    patient_id?: true
    doctor_id?: true
    medication_id?: true
    treatment_description?: true
    treatment_date?: true
    _all?: true
  }

  export type TreatmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Treatments to aggregate.
     */
    where?: TreatmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentsOrderByWithRelationInput | TreatmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreatmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Treatments
    **/
    _count?: true | TreatmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreatmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreatmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreatmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreatmentsMaxAggregateInputType
  }

  export type GetTreatmentsAggregateType<T extends TreatmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateTreatments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreatments[P]>
      : GetScalarType<T[P], AggregateTreatments[P]>
  }




  export type TreatmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreatmentsWhereInput
    orderBy?: TreatmentsOrderByWithAggregationInput | TreatmentsOrderByWithAggregationInput[]
    by: TreatmentsScalarFieldEnum[] | TreatmentsScalarFieldEnum
    having?: TreatmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreatmentsCountAggregateInputType | true
    _avg?: TreatmentsAvgAggregateInputType
    _sum?: TreatmentsSumAggregateInputType
    _min?: TreatmentsMinAggregateInputType
    _max?: TreatmentsMaxAggregateInputType
  }

  export type TreatmentsGroupByOutputType = {
    treatment_id: number
    patient_id: number
    doctor_id: number
    medication_id: number
    treatment_description: string
    treatment_date: Date
    _count: TreatmentsCountAggregateOutputType | null
    _avg: TreatmentsAvgAggregateOutputType | null
    _sum: TreatmentsSumAggregateOutputType | null
    _min: TreatmentsMinAggregateOutputType | null
    _max: TreatmentsMaxAggregateOutputType | null
  }

  type GetTreatmentsGroupByPayload<T extends TreatmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreatmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreatmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreatmentsGroupByOutputType[P]>
            : GetScalarType<T[P], TreatmentsGroupByOutputType[P]>
        }
      >
    >


  export type TreatmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    treatment_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    medication_id?: boolean
    treatment_description?: boolean
    treatment_date?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
    medication?: boolean | MedicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatments"]>

  export type TreatmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    treatment_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    medication_id?: boolean
    treatment_description?: boolean
    treatment_date?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
    medication?: boolean | MedicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treatments"]>

  export type TreatmentsSelectScalar = {
    treatment_id?: boolean
    patient_id?: boolean
    doctor_id?: boolean
    medication_id?: boolean
    treatment_description?: boolean
    treatment_date?: boolean
  }

  export type TreatmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
    medication?: boolean | MedicationsDefaultArgs<ExtArgs>
  }
  export type TreatmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
    medication?: boolean | MedicationsDefaultArgs<ExtArgs>
  }

  export type $TreatmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Treatments"
    objects: {
      patient: Prisma.$PatientsPayload<ExtArgs>
      doctor: Prisma.$DoctorsPayload<ExtArgs>
      medication: Prisma.$MedicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      treatment_id: number
      patient_id: number
      doctor_id: number
      medication_id: number
      treatment_description: string
      treatment_date: Date
    }, ExtArgs["result"]["treatments"]>
    composites: {}
  }

  type TreatmentsGetPayload<S extends boolean | null | undefined | TreatmentsDefaultArgs> = $Result.GetResult<Prisma.$TreatmentsPayload, S>

  type TreatmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TreatmentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TreatmentsCountAggregateInputType | true
    }

  export interface TreatmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Treatments'], meta: { name: 'Treatments' } }
    /**
     * Find zero or one Treatments that matches the filter.
     * @param {TreatmentsFindUniqueArgs} args - Arguments to find a Treatments
     * @example
     * // Get one Treatments
     * const treatments = await prisma.treatments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreatmentsFindUniqueArgs>(args: SelectSubset<T, TreatmentsFindUniqueArgs<ExtArgs>>): Prisma__TreatmentsClient<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Treatments that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TreatmentsFindUniqueOrThrowArgs} args - Arguments to find a Treatments
     * @example
     * // Get one Treatments
     * const treatments = await prisma.treatments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreatmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, TreatmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreatmentsClient<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Treatments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentsFindFirstArgs} args - Arguments to find a Treatments
     * @example
     * // Get one Treatments
     * const treatments = await prisma.treatments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreatmentsFindFirstArgs>(args?: SelectSubset<T, TreatmentsFindFirstArgs<ExtArgs>>): Prisma__TreatmentsClient<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Treatments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentsFindFirstOrThrowArgs} args - Arguments to find a Treatments
     * @example
     * // Get one Treatments
     * const treatments = await prisma.treatments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreatmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, TreatmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreatmentsClient<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Treatments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treatments
     * const treatments = await prisma.treatments.findMany()
     * 
     * // Get first 10 Treatments
     * const treatments = await prisma.treatments.findMany({ take: 10 })
     * 
     * // Only select the `treatment_id`
     * const treatmentsWithTreatment_idOnly = await prisma.treatments.findMany({ select: { treatment_id: true } })
     * 
     */
    findMany<T extends TreatmentsFindManyArgs>(args?: SelectSubset<T, TreatmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Treatments.
     * @param {TreatmentsCreateArgs} args - Arguments to create a Treatments.
     * @example
     * // Create one Treatments
     * const Treatments = await prisma.treatments.create({
     *   data: {
     *     // ... data to create a Treatments
     *   }
     * })
     * 
     */
    create<T extends TreatmentsCreateArgs>(args: SelectSubset<T, TreatmentsCreateArgs<ExtArgs>>): Prisma__TreatmentsClient<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Treatments.
     * @param {TreatmentsCreateManyArgs} args - Arguments to create many Treatments.
     * @example
     * // Create many Treatments
     * const treatments = await prisma.treatments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreatmentsCreateManyArgs>(args?: SelectSubset<T, TreatmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Treatments and returns the data saved in the database.
     * @param {TreatmentsCreateManyAndReturnArgs} args - Arguments to create many Treatments.
     * @example
     * // Create many Treatments
     * const treatments = await prisma.treatments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Treatments and only return the `treatment_id`
     * const treatmentsWithTreatment_idOnly = await prisma.treatments.createManyAndReturn({ 
     *   select: { treatment_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreatmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, TreatmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Treatments.
     * @param {TreatmentsDeleteArgs} args - Arguments to delete one Treatments.
     * @example
     * // Delete one Treatments
     * const Treatments = await prisma.treatments.delete({
     *   where: {
     *     // ... filter to delete one Treatments
     *   }
     * })
     * 
     */
    delete<T extends TreatmentsDeleteArgs>(args: SelectSubset<T, TreatmentsDeleteArgs<ExtArgs>>): Prisma__TreatmentsClient<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Treatments.
     * @param {TreatmentsUpdateArgs} args - Arguments to update one Treatments.
     * @example
     * // Update one Treatments
     * const treatments = await prisma.treatments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreatmentsUpdateArgs>(args: SelectSubset<T, TreatmentsUpdateArgs<ExtArgs>>): Prisma__TreatmentsClient<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Treatments.
     * @param {TreatmentsDeleteManyArgs} args - Arguments to filter Treatments to delete.
     * @example
     * // Delete a few Treatments
     * const { count } = await prisma.treatments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreatmentsDeleteManyArgs>(args?: SelectSubset<T, TreatmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treatments
     * const treatments = await prisma.treatments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreatmentsUpdateManyArgs>(args: SelectSubset<T, TreatmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Treatments.
     * @param {TreatmentsUpsertArgs} args - Arguments to update or create a Treatments.
     * @example
     * // Update or create a Treatments
     * const treatments = await prisma.treatments.upsert({
     *   create: {
     *     // ... data to create a Treatments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treatments we want to update
     *   }
     * })
     */
    upsert<T extends TreatmentsUpsertArgs>(args: SelectSubset<T, TreatmentsUpsertArgs<ExtArgs>>): Prisma__TreatmentsClient<$Result.GetResult<Prisma.$TreatmentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentsCountArgs} args - Arguments to filter Treatments to count.
     * @example
     * // Count the number of Treatments
     * const count = await prisma.treatments.count({
     *   where: {
     *     // ... the filter for the Treatments we want to count
     *   }
     * })
    **/
    count<T extends TreatmentsCountArgs>(
      args?: Subset<T, TreatmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreatmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreatmentsAggregateArgs>(args: Subset<T, TreatmentsAggregateArgs>): Prisma.PrismaPromise<GetTreatmentsAggregateType<T>>

    /**
     * Group by Treatments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreatmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreatmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreatmentsGroupByArgs['orderBy'] }
        : { orderBy?: TreatmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreatmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreatmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Treatments model
   */
  readonly fields: TreatmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Treatments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreatmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientsDefaultArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends DoctorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorsDefaultArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    medication<T extends MedicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicationsDefaultArgs<ExtArgs>>): Prisma__MedicationsClient<$Result.GetResult<Prisma.$MedicationsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Treatments model
   */ 
  interface TreatmentsFieldRefs {
    readonly treatment_id: FieldRef<"Treatments", 'Int'>
    readonly patient_id: FieldRef<"Treatments", 'Int'>
    readonly doctor_id: FieldRef<"Treatments", 'Int'>
    readonly medication_id: FieldRef<"Treatments", 'Int'>
    readonly treatment_description: FieldRef<"Treatments", 'String'>
    readonly treatment_date: FieldRef<"Treatments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Treatments findUnique
   */
  export type TreatmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * Filter, which Treatments to fetch.
     */
    where: TreatmentsWhereUniqueInput
  }

  /**
   * Treatments findUniqueOrThrow
   */
  export type TreatmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * Filter, which Treatments to fetch.
     */
    where: TreatmentsWhereUniqueInput
  }

  /**
   * Treatments findFirst
   */
  export type TreatmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * Filter, which Treatments to fetch.
     */
    where?: TreatmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentsOrderByWithRelationInput | TreatmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treatments.
     */
    cursor?: TreatmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treatments.
     */
    distinct?: TreatmentsScalarFieldEnum | TreatmentsScalarFieldEnum[]
  }

  /**
   * Treatments findFirstOrThrow
   */
  export type TreatmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * Filter, which Treatments to fetch.
     */
    where?: TreatmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentsOrderByWithRelationInput | TreatmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Treatments.
     */
    cursor?: TreatmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Treatments.
     */
    distinct?: TreatmentsScalarFieldEnum | TreatmentsScalarFieldEnum[]
  }

  /**
   * Treatments findMany
   */
  export type TreatmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * Filter, which Treatments to fetch.
     */
    where?: TreatmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Treatments to fetch.
     */
    orderBy?: TreatmentsOrderByWithRelationInput | TreatmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Treatments.
     */
    cursor?: TreatmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Treatments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Treatments.
     */
    skip?: number
    distinct?: TreatmentsScalarFieldEnum | TreatmentsScalarFieldEnum[]
  }

  /**
   * Treatments create
   */
  export type TreatmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Treatments.
     */
    data: XOR<TreatmentsCreateInput, TreatmentsUncheckedCreateInput>
  }

  /**
   * Treatments createMany
   */
  export type TreatmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Treatments.
     */
    data: TreatmentsCreateManyInput | TreatmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Treatments createManyAndReturn
   */
  export type TreatmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Treatments.
     */
    data: TreatmentsCreateManyInput | TreatmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Treatments update
   */
  export type TreatmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Treatments.
     */
    data: XOR<TreatmentsUpdateInput, TreatmentsUncheckedUpdateInput>
    /**
     * Choose, which Treatments to update.
     */
    where: TreatmentsWhereUniqueInput
  }

  /**
   * Treatments updateMany
   */
  export type TreatmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Treatments.
     */
    data: XOR<TreatmentsUpdateManyMutationInput, TreatmentsUncheckedUpdateManyInput>
    /**
     * Filter which Treatments to update
     */
    where?: TreatmentsWhereInput
  }

  /**
   * Treatments upsert
   */
  export type TreatmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Treatments to update in case it exists.
     */
    where: TreatmentsWhereUniqueInput
    /**
     * In case the Treatments found by the `where` argument doesn't exist, create a new Treatments with this data.
     */
    create: XOR<TreatmentsCreateInput, TreatmentsUncheckedCreateInput>
    /**
     * In case the Treatments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreatmentsUpdateInput, TreatmentsUncheckedUpdateInput>
  }

  /**
   * Treatments delete
   */
  export type TreatmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
    /**
     * Filter which Treatments to delete.
     */
    where: TreatmentsWhereUniqueInput
  }

  /**
   * Treatments deleteMany
   */
  export type TreatmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Treatments to delete
     */
    where?: TreatmentsWhereInput
  }

  /**
   * Treatments without action
   */
  export type TreatmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treatments
     */
    select?: TreatmentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TreatmentsInclude<ExtArgs> | null
  }


  /**
   * Model Insurance
   */

  export type AggregateInsurance = {
    _count: InsuranceCountAggregateOutputType | null
    _avg: InsuranceAvgAggregateOutputType | null
    _sum: InsuranceSumAggregateOutputType | null
    _min: InsuranceMinAggregateOutputType | null
    _max: InsuranceMaxAggregateOutputType | null
  }

  export type InsuranceAvgAggregateOutputType = {
    insurance_id: number | null
    patient_id: number | null
    coverage_amount: number | null
  }

  export type InsuranceSumAggregateOutputType = {
    insurance_id: number | null
    patient_id: number | null
    coverage_amount: number | null
  }

  export type InsuranceMinAggregateOutputType = {
    insurance_id: number | null
    patient_id: number | null
    provider_name: string | null
    policy_number: string | null
    coverage_amount: number | null
  }

  export type InsuranceMaxAggregateOutputType = {
    insurance_id: number | null
    patient_id: number | null
    provider_name: string | null
    policy_number: string | null
    coverage_amount: number | null
  }

  export type InsuranceCountAggregateOutputType = {
    insurance_id: number
    patient_id: number
    provider_name: number
    policy_number: number
    coverage_amount: number
    _all: number
  }


  export type InsuranceAvgAggregateInputType = {
    insurance_id?: true
    patient_id?: true
    coverage_amount?: true
  }

  export type InsuranceSumAggregateInputType = {
    insurance_id?: true
    patient_id?: true
    coverage_amount?: true
  }

  export type InsuranceMinAggregateInputType = {
    insurance_id?: true
    patient_id?: true
    provider_name?: true
    policy_number?: true
    coverage_amount?: true
  }

  export type InsuranceMaxAggregateInputType = {
    insurance_id?: true
    patient_id?: true
    provider_name?: true
    policy_number?: true
    coverage_amount?: true
  }

  export type InsuranceCountAggregateInputType = {
    insurance_id?: true
    patient_id?: true
    provider_name?: true
    policy_number?: true
    coverage_amount?: true
    _all?: true
  }

  export type InsuranceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insurance to aggregate.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: InsuranceOrderByWithRelationInput | InsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insurances
    **/
    _count?: true | InsuranceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsuranceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsuranceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsuranceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsuranceMaxAggregateInputType
  }

  export type GetInsuranceAggregateType<T extends InsuranceAggregateArgs> = {
        [P in keyof T & keyof AggregateInsurance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsurance[P]>
      : GetScalarType<T[P], AggregateInsurance[P]>
  }




  export type InsuranceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceWhereInput
    orderBy?: InsuranceOrderByWithAggregationInput | InsuranceOrderByWithAggregationInput[]
    by: InsuranceScalarFieldEnum[] | InsuranceScalarFieldEnum
    having?: InsuranceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsuranceCountAggregateInputType | true
    _avg?: InsuranceAvgAggregateInputType
    _sum?: InsuranceSumAggregateInputType
    _min?: InsuranceMinAggregateInputType
    _max?: InsuranceMaxAggregateInputType
  }

  export type InsuranceGroupByOutputType = {
    insurance_id: number
    patient_id: number
    provider_name: string
    policy_number: string
    coverage_amount: number
    _count: InsuranceCountAggregateOutputType | null
    _avg: InsuranceAvgAggregateOutputType | null
    _sum: InsuranceSumAggregateOutputType | null
    _min: InsuranceMinAggregateOutputType | null
    _max: InsuranceMaxAggregateOutputType | null
  }

  type GetInsuranceGroupByPayload<T extends InsuranceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsuranceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsuranceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsuranceGroupByOutputType[P]>
            : GetScalarType<T[P], InsuranceGroupByOutputType[P]>
        }
      >
    >


  export type InsuranceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    insurance_id?: boolean
    patient_id?: boolean
    provider_name?: boolean
    policy_number?: boolean
    coverage_amount?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insurance"]>

  export type InsuranceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    insurance_id?: boolean
    patient_id?: boolean
    provider_name?: boolean
    policy_number?: boolean
    coverage_amount?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insurance"]>

  export type InsuranceSelectScalar = {
    insurance_id?: boolean
    patient_id?: boolean
    provider_name?: boolean
    policy_number?: boolean
    coverage_amount?: boolean
  }

  export type InsuranceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }
  export type InsuranceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }

  export type $InsurancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Insurance"
    objects: {
      patient: Prisma.$PatientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      insurance_id: number
      patient_id: number
      provider_name: string
      policy_number: string
      coverage_amount: number
    }, ExtArgs["result"]["insurance"]>
    composites: {}
  }

  type InsuranceGetPayload<S extends boolean | null | undefined | InsuranceDefaultArgs> = $Result.GetResult<Prisma.$InsurancePayload, S>

  type InsuranceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsuranceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsuranceCountAggregateInputType | true
    }

  export interface InsuranceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insurance'], meta: { name: 'Insurance' } }
    /**
     * Find zero or one Insurance that matches the filter.
     * @param {InsuranceFindUniqueArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsuranceFindUniqueArgs>(args: SelectSubset<T, InsuranceFindUniqueArgs<ExtArgs>>): Prisma__InsuranceClient<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Insurance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsuranceFindUniqueOrThrowArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsuranceFindUniqueOrThrowArgs>(args: SelectSubset<T, InsuranceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsuranceClient<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Insurance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindFirstArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsuranceFindFirstArgs>(args?: SelectSubset<T, InsuranceFindFirstArgs<ExtArgs>>): Prisma__InsuranceClient<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Insurance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindFirstOrThrowArgs} args - Arguments to find a Insurance
     * @example
     * // Get one Insurance
     * const insurance = await prisma.insurance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsuranceFindFirstOrThrowArgs>(args?: SelectSubset<T, InsuranceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsuranceClient<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Insurances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insurances
     * const insurances = await prisma.insurance.findMany()
     * 
     * // Get first 10 Insurances
     * const insurances = await prisma.insurance.findMany({ take: 10 })
     * 
     * // Only select the `insurance_id`
     * const insuranceWithInsurance_idOnly = await prisma.insurance.findMany({ select: { insurance_id: true } })
     * 
     */
    findMany<T extends InsuranceFindManyArgs>(args?: SelectSubset<T, InsuranceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Insurance.
     * @param {InsuranceCreateArgs} args - Arguments to create a Insurance.
     * @example
     * // Create one Insurance
     * const Insurance = await prisma.insurance.create({
     *   data: {
     *     // ... data to create a Insurance
     *   }
     * })
     * 
     */
    create<T extends InsuranceCreateArgs>(args: SelectSubset<T, InsuranceCreateArgs<ExtArgs>>): Prisma__InsuranceClient<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Insurances.
     * @param {InsuranceCreateManyArgs} args - Arguments to create many Insurances.
     * @example
     * // Create many Insurances
     * const insurance = await prisma.insurance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsuranceCreateManyArgs>(args?: SelectSubset<T, InsuranceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Insurances and returns the data saved in the database.
     * @param {InsuranceCreateManyAndReturnArgs} args - Arguments to create many Insurances.
     * @example
     * // Create many Insurances
     * const insurance = await prisma.insurance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Insurances and only return the `insurance_id`
     * const insuranceWithInsurance_idOnly = await prisma.insurance.createManyAndReturn({ 
     *   select: { insurance_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsuranceCreateManyAndReturnArgs>(args?: SelectSubset<T, InsuranceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Insurance.
     * @param {InsuranceDeleteArgs} args - Arguments to delete one Insurance.
     * @example
     * // Delete one Insurance
     * const Insurance = await prisma.insurance.delete({
     *   where: {
     *     // ... filter to delete one Insurance
     *   }
     * })
     * 
     */
    delete<T extends InsuranceDeleteArgs>(args: SelectSubset<T, InsuranceDeleteArgs<ExtArgs>>): Prisma__InsuranceClient<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Insurance.
     * @param {InsuranceUpdateArgs} args - Arguments to update one Insurance.
     * @example
     * // Update one Insurance
     * const insurance = await prisma.insurance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsuranceUpdateArgs>(args: SelectSubset<T, InsuranceUpdateArgs<ExtArgs>>): Prisma__InsuranceClient<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Insurances.
     * @param {InsuranceDeleteManyArgs} args - Arguments to filter Insurances to delete.
     * @example
     * // Delete a few Insurances
     * const { count } = await prisma.insurance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsuranceDeleteManyArgs>(args?: SelectSubset<T, InsuranceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insurances
     * const insurance = await prisma.insurance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsuranceUpdateManyArgs>(args: SelectSubset<T, InsuranceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insurance.
     * @param {InsuranceUpsertArgs} args - Arguments to update or create a Insurance.
     * @example
     * // Update or create a Insurance
     * const insurance = await prisma.insurance.upsert({
     *   create: {
     *     // ... data to create a Insurance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insurance we want to update
     *   }
     * })
     */
    upsert<T extends InsuranceUpsertArgs>(args: SelectSubset<T, InsuranceUpsertArgs<ExtArgs>>): Prisma__InsuranceClient<$Result.GetResult<Prisma.$InsurancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Insurances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceCountArgs} args - Arguments to filter Insurances to count.
     * @example
     * // Count the number of Insurances
     * const count = await prisma.insurance.count({
     *   where: {
     *     // ... the filter for the Insurances we want to count
     *   }
     * })
    **/
    count<T extends InsuranceCountArgs>(
      args?: Subset<T, InsuranceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsuranceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsuranceAggregateArgs>(args: Subset<T, InsuranceAggregateArgs>): Prisma.PrismaPromise<GetInsuranceAggregateType<T>>

    /**
     * Group by Insurance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsuranceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsuranceGroupByArgs['orderBy'] }
        : { orderBy?: InsuranceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsuranceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsuranceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Insurance model
   */
  readonly fields: InsuranceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Insurance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsuranceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientsDefaultArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Insurance model
   */ 
  interface InsuranceFieldRefs {
    readonly insurance_id: FieldRef<"Insurance", 'Int'>
    readonly patient_id: FieldRef<"Insurance", 'Int'>
    readonly provider_name: FieldRef<"Insurance", 'String'>
    readonly policy_number: FieldRef<"Insurance", 'String'>
    readonly coverage_amount: FieldRef<"Insurance", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Insurance findUnique
   */
  export type InsuranceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where: InsuranceWhereUniqueInput
  }

  /**
   * Insurance findUniqueOrThrow
   */
  export type InsuranceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where: InsuranceWhereUniqueInput
  }

  /**
   * Insurance findFirst
   */
  export type InsuranceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: InsuranceOrderByWithRelationInput | InsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insurances.
     */
    distinct?: InsuranceScalarFieldEnum | InsuranceScalarFieldEnum[]
  }

  /**
   * Insurance findFirstOrThrow
   */
  export type InsuranceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurance to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: InsuranceOrderByWithRelationInput | InsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insurances.
     */
    distinct?: InsuranceScalarFieldEnum | InsuranceScalarFieldEnum[]
  }

  /**
   * Insurance findMany
   */
  export type InsuranceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter, which Insurances to fetch.
     */
    where?: InsuranceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insurances to fetch.
     */
    orderBy?: InsuranceOrderByWithRelationInput | InsuranceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insurances.
     */
    cursor?: InsuranceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insurances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insurances.
     */
    skip?: number
    distinct?: InsuranceScalarFieldEnum | InsuranceScalarFieldEnum[]
  }

  /**
   * Insurance create
   */
  export type InsuranceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The data needed to create a Insurance.
     */
    data: XOR<InsuranceCreateInput, InsuranceUncheckedCreateInput>
  }

  /**
   * Insurance createMany
   */
  export type InsuranceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insurances.
     */
    data: InsuranceCreateManyInput | InsuranceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Insurance createManyAndReturn
   */
  export type InsuranceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Insurances.
     */
    data: InsuranceCreateManyInput | InsuranceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Insurance update
   */
  export type InsuranceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The data needed to update a Insurance.
     */
    data: XOR<InsuranceUpdateInput, InsuranceUncheckedUpdateInput>
    /**
     * Choose, which Insurance to update.
     */
    where: InsuranceWhereUniqueInput
  }

  /**
   * Insurance updateMany
   */
  export type InsuranceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insurances.
     */
    data: XOR<InsuranceUpdateManyMutationInput, InsuranceUncheckedUpdateManyInput>
    /**
     * Filter which Insurances to update
     */
    where?: InsuranceWhereInput
  }

  /**
   * Insurance upsert
   */
  export type InsuranceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * The filter to search for the Insurance to update in case it exists.
     */
    where: InsuranceWhereUniqueInput
    /**
     * In case the Insurance found by the `where` argument doesn't exist, create a new Insurance with this data.
     */
    create: XOR<InsuranceCreateInput, InsuranceUncheckedCreateInput>
    /**
     * In case the Insurance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsuranceUpdateInput, InsuranceUncheckedUpdateInput>
  }

  /**
   * Insurance delete
   */
  export type InsuranceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
    /**
     * Filter which Insurance to delete.
     */
    where: InsuranceWhereUniqueInput
  }

  /**
   * Insurance deleteMany
   */
  export type InsuranceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insurances to delete
     */
    where?: InsuranceWhereInput
  }

  /**
   * Insurance without action
   */
  export type InsuranceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insurance
     */
    select?: InsuranceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceInclude<ExtArgs> | null
  }


  /**
   * Model LabTests
   */

  export type AggregateLabTests = {
    _count: LabTestsCountAggregateOutputType | null
    _avg: LabTestsAvgAggregateOutputType | null
    _sum: LabTestsSumAggregateOutputType | null
    _min: LabTestsMinAggregateOutputType | null
    _max: LabTestsMaxAggregateOutputType | null
  }

  export type LabTestsAvgAggregateOutputType = {
    test_id: number | null
    patient_id: number | null
    doctor_id: number | null
  }

  export type LabTestsSumAggregateOutputType = {
    test_id: number | null
    patient_id: number | null
    doctor_id: number | null
  }

  export type LabTestsMinAggregateOutputType = {
    test_id: number | null
    patient_id: number | null
    test_name: string | null
    test_result: string | null
    test_date: Date | null
    doctor_id: number | null
  }

  export type LabTestsMaxAggregateOutputType = {
    test_id: number | null
    patient_id: number | null
    test_name: string | null
    test_result: string | null
    test_date: Date | null
    doctor_id: number | null
  }

  export type LabTestsCountAggregateOutputType = {
    test_id: number
    patient_id: number
    test_name: number
    test_result: number
    test_date: number
    doctor_id: number
    _all: number
  }


  export type LabTestsAvgAggregateInputType = {
    test_id?: true
    patient_id?: true
    doctor_id?: true
  }

  export type LabTestsSumAggregateInputType = {
    test_id?: true
    patient_id?: true
    doctor_id?: true
  }

  export type LabTestsMinAggregateInputType = {
    test_id?: true
    patient_id?: true
    test_name?: true
    test_result?: true
    test_date?: true
    doctor_id?: true
  }

  export type LabTestsMaxAggregateInputType = {
    test_id?: true
    patient_id?: true
    test_name?: true
    test_result?: true
    test_date?: true
    doctor_id?: true
  }

  export type LabTestsCountAggregateInputType = {
    test_id?: true
    patient_id?: true
    test_name?: true
    test_result?: true
    test_date?: true
    doctor_id?: true
    _all?: true
  }

  export type LabTestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTests to aggregate.
     */
    where?: LabTestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestsOrderByWithRelationInput | LabTestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabTestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabTests
    **/
    _count?: true | LabTestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabTestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabTestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabTestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabTestsMaxAggregateInputType
  }

  export type GetLabTestsAggregateType<T extends LabTestsAggregateArgs> = {
        [P in keyof T & keyof AggregateLabTests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabTests[P]>
      : GetScalarType<T[P], AggregateLabTests[P]>
  }




  export type LabTestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTestsWhereInput
    orderBy?: LabTestsOrderByWithAggregationInput | LabTestsOrderByWithAggregationInput[]
    by: LabTestsScalarFieldEnum[] | LabTestsScalarFieldEnum
    having?: LabTestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabTestsCountAggregateInputType | true
    _avg?: LabTestsAvgAggregateInputType
    _sum?: LabTestsSumAggregateInputType
    _min?: LabTestsMinAggregateInputType
    _max?: LabTestsMaxAggregateInputType
  }

  export type LabTestsGroupByOutputType = {
    test_id: number
    patient_id: number
    test_name: string
    test_result: string
    test_date: Date
    doctor_id: number
    _count: LabTestsCountAggregateOutputType | null
    _avg: LabTestsAvgAggregateOutputType | null
    _sum: LabTestsSumAggregateOutputType | null
    _min: LabTestsMinAggregateOutputType | null
    _max: LabTestsMaxAggregateOutputType | null
  }

  type GetLabTestsGroupByPayload<T extends LabTestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabTestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabTestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabTestsGroupByOutputType[P]>
            : GetScalarType<T[P], LabTestsGroupByOutputType[P]>
        }
      >
    >


  export type LabTestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    test_id?: boolean
    patient_id?: boolean
    test_name?: boolean
    test_result?: boolean
    test_date?: boolean
    doctor_id?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTests"]>

  export type LabTestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    test_id?: boolean
    patient_id?: boolean
    test_name?: boolean
    test_result?: boolean
    test_date?: boolean
    doctor_id?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTests"]>

  export type LabTestsSelectScalar = {
    test_id?: boolean
    patient_id?: boolean
    test_name?: boolean
    test_result?: boolean
    test_date?: boolean
    doctor_id?: boolean
  }

  export type LabTestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }
  export type LabTestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
    doctor?: boolean | DoctorsDefaultArgs<ExtArgs>
  }

  export type $LabTestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabTests"
    objects: {
      patient: Prisma.$PatientsPayload<ExtArgs>
      doctor: Prisma.$DoctorsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      test_id: number
      patient_id: number
      test_name: string
      test_result: string
      test_date: Date
      doctor_id: number
    }, ExtArgs["result"]["labTests"]>
    composites: {}
  }

  type LabTestsGetPayload<S extends boolean | null | undefined | LabTestsDefaultArgs> = $Result.GetResult<Prisma.$LabTestsPayload, S>

  type LabTestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LabTestsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LabTestsCountAggregateInputType | true
    }

  export interface LabTestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabTests'], meta: { name: 'LabTests' } }
    /**
     * Find zero or one LabTests that matches the filter.
     * @param {LabTestsFindUniqueArgs} args - Arguments to find a LabTests
     * @example
     * // Get one LabTests
     * const labTests = await prisma.labTests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabTestsFindUniqueArgs>(args: SelectSubset<T, LabTestsFindUniqueArgs<ExtArgs>>): Prisma__LabTestsClient<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LabTests that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LabTestsFindUniqueOrThrowArgs} args - Arguments to find a LabTests
     * @example
     * // Get one LabTests
     * const labTests = await prisma.labTests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabTestsFindUniqueOrThrowArgs>(args: SelectSubset<T, LabTestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabTestsClient<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LabTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestsFindFirstArgs} args - Arguments to find a LabTests
     * @example
     * // Get one LabTests
     * const labTests = await prisma.labTests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabTestsFindFirstArgs>(args?: SelectSubset<T, LabTestsFindFirstArgs<ExtArgs>>): Prisma__LabTestsClient<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LabTests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestsFindFirstOrThrowArgs} args - Arguments to find a LabTests
     * @example
     * // Get one LabTests
     * const labTests = await prisma.labTests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabTestsFindFirstOrThrowArgs>(args?: SelectSubset<T, LabTestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabTestsClient<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LabTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabTests
     * const labTests = await prisma.labTests.findMany()
     * 
     * // Get first 10 LabTests
     * const labTests = await prisma.labTests.findMany({ take: 10 })
     * 
     * // Only select the `test_id`
     * const labTestsWithTest_idOnly = await prisma.labTests.findMany({ select: { test_id: true } })
     * 
     */
    findMany<T extends LabTestsFindManyArgs>(args?: SelectSubset<T, LabTestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LabTests.
     * @param {LabTestsCreateArgs} args - Arguments to create a LabTests.
     * @example
     * // Create one LabTests
     * const LabTests = await prisma.labTests.create({
     *   data: {
     *     // ... data to create a LabTests
     *   }
     * })
     * 
     */
    create<T extends LabTestsCreateArgs>(args: SelectSubset<T, LabTestsCreateArgs<ExtArgs>>): Prisma__LabTestsClient<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LabTests.
     * @param {LabTestsCreateManyArgs} args - Arguments to create many LabTests.
     * @example
     * // Create many LabTests
     * const labTests = await prisma.labTests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabTestsCreateManyArgs>(args?: SelectSubset<T, LabTestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabTests and returns the data saved in the database.
     * @param {LabTestsCreateManyAndReturnArgs} args - Arguments to create many LabTests.
     * @example
     * // Create many LabTests
     * const labTests = await prisma.labTests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabTests and only return the `test_id`
     * const labTestsWithTest_idOnly = await prisma.labTests.createManyAndReturn({ 
     *   select: { test_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabTestsCreateManyAndReturnArgs>(args?: SelectSubset<T, LabTestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LabTests.
     * @param {LabTestsDeleteArgs} args - Arguments to delete one LabTests.
     * @example
     * // Delete one LabTests
     * const LabTests = await prisma.labTests.delete({
     *   where: {
     *     // ... filter to delete one LabTests
     *   }
     * })
     * 
     */
    delete<T extends LabTestsDeleteArgs>(args: SelectSubset<T, LabTestsDeleteArgs<ExtArgs>>): Prisma__LabTestsClient<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LabTests.
     * @param {LabTestsUpdateArgs} args - Arguments to update one LabTests.
     * @example
     * // Update one LabTests
     * const labTests = await prisma.labTests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabTestsUpdateArgs>(args: SelectSubset<T, LabTestsUpdateArgs<ExtArgs>>): Prisma__LabTestsClient<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LabTests.
     * @param {LabTestsDeleteManyArgs} args - Arguments to filter LabTests to delete.
     * @example
     * // Delete a few LabTests
     * const { count } = await prisma.labTests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabTestsDeleteManyArgs>(args?: SelectSubset<T, LabTestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabTests
     * const labTests = await prisma.labTests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabTestsUpdateManyArgs>(args: SelectSubset<T, LabTestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LabTests.
     * @param {LabTestsUpsertArgs} args - Arguments to update or create a LabTests.
     * @example
     * // Update or create a LabTests
     * const labTests = await prisma.labTests.upsert({
     *   create: {
     *     // ... data to create a LabTests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabTests we want to update
     *   }
     * })
     */
    upsert<T extends LabTestsUpsertArgs>(args: SelectSubset<T, LabTestsUpsertArgs<ExtArgs>>): Prisma__LabTestsClient<$Result.GetResult<Prisma.$LabTestsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestsCountArgs} args - Arguments to filter LabTests to count.
     * @example
     * // Count the number of LabTests
     * const count = await prisma.labTests.count({
     *   where: {
     *     // ... the filter for the LabTests we want to count
     *   }
     * })
    **/
    count<T extends LabTestsCountArgs>(
      args?: Subset<T, LabTestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabTestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabTestsAggregateArgs>(args: Subset<T, LabTestsAggregateArgs>): Prisma.PrismaPromise<GetLabTestsAggregateType<T>>

    /**
     * Group by LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabTestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabTestsGroupByArgs['orderBy'] }
        : { orderBy?: LabTestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabTestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabTestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabTests model
   */
  readonly fields: LabTestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabTests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabTestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientsDefaultArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends DoctorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorsDefaultArgs<ExtArgs>>): Prisma__DoctorsClient<$Result.GetResult<Prisma.$DoctorsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabTests model
   */ 
  interface LabTestsFieldRefs {
    readonly test_id: FieldRef<"LabTests", 'Int'>
    readonly patient_id: FieldRef<"LabTests", 'Int'>
    readonly test_name: FieldRef<"LabTests", 'String'>
    readonly test_result: FieldRef<"LabTests", 'String'>
    readonly test_date: FieldRef<"LabTests", 'DateTime'>
    readonly doctor_id: FieldRef<"LabTests", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LabTests findUnique
   */
  export type LabTestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * Filter, which LabTests to fetch.
     */
    where: LabTestsWhereUniqueInput
  }

  /**
   * LabTests findUniqueOrThrow
   */
  export type LabTestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * Filter, which LabTests to fetch.
     */
    where: LabTestsWhereUniqueInput
  }

  /**
   * LabTests findFirst
   */
  export type LabTestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * Filter, which LabTests to fetch.
     */
    where?: LabTestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestsOrderByWithRelationInput | LabTestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTests.
     */
    cursor?: LabTestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTests.
     */
    distinct?: LabTestsScalarFieldEnum | LabTestsScalarFieldEnum[]
  }

  /**
   * LabTests findFirstOrThrow
   */
  export type LabTestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * Filter, which LabTests to fetch.
     */
    where?: LabTestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestsOrderByWithRelationInput | LabTestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTests.
     */
    cursor?: LabTestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTests.
     */
    distinct?: LabTestsScalarFieldEnum | LabTestsScalarFieldEnum[]
  }

  /**
   * LabTests findMany
   */
  export type LabTestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * Filter, which LabTests to fetch.
     */
    where?: LabTestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestsOrderByWithRelationInput | LabTestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabTests.
     */
    cursor?: LabTestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    distinct?: LabTestsScalarFieldEnum | LabTestsScalarFieldEnum[]
  }

  /**
   * LabTests create
   */
  export type LabTestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * The data needed to create a LabTests.
     */
    data: XOR<LabTestsCreateInput, LabTestsUncheckedCreateInput>
  }

  /**
   * LabTests createMany
   */
  export type LabTestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabTests.
     */
    data: LabTestsCreateManyInput | LabTestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabTests createManyAndReturn
   */
  export type LabTestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LabTests.
     */
    data: LabTestsCreateManyInput | LabTestsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabTests update
   */
  export type LabTestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * The data needed to update a LabTests.
     */
    data: XOR<LabTestsUpdateInput, LabTestsUncheckedUpdateInput>
    /**
     * Choose, which LabTests to update.
     */
    where: LabTestsWhereUniqueInput
  }

  /**
   * LabTests updateMany
   */
  export type LabTestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabTests.
     */
    data: XOR<LabTestsUpdateManyMutationInput, LabTestsUncheckedUpdateManyInput>
    /**
     * Filter which LabTests to update
     */
    where?: LabTestsWhereInput
  }

  /**
   * LabTests upsert
   */
  export type LabTestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * The filter to search for the LabTests to update in case it exists.
     */
    where: LabTestsWhereUniqueInput
    /**
     * In case the LabTests found by the `where` argument doesn't exist, create a new LabTests with this data.
     */
    create: XOR<LabTestsCreateInput, LabTestsUncheckedCreateInput>
    /**
     * In case the LabTests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabTestsUpdateInput, LabTestsUncheckedUpdateInput>
  }

  /**
   * LabTests delete
   */
  export type LabTestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
    /**
     * Filter which LabTests to delete.
     */
    where: LabTestsWhereUniqueInput
  }

  /**
   * LabTests deleteMany
   */
  export type LabTestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTests to delete
     */
    where?: LabTestsWhereInput
  }

  /**
   * LabTests without action
   */
  export type LabTestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTests
     */
    select?: LabTestsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestsInclude<ExtArgs> | null
  }


  /**
   * Model Bills
   */

  export type AggregateBills = {
    _count: BillsCountAggregateOutputType | null
    _avg: BillsAvgAggregateOutputType | null
    _sum: BillsSumAggregateOutputType | null
    _min: BillsMinAggregateOutputType | null
    _max: BillsMaxAggregateOutputType | null
  }

  export type BillsAvgAggregateOutputType = {
    bill_id: number | null
    patient_id: number | null
    total_amount: number | null
    amount_paid: number | null
  }

  export type BillsSumAggregateOutputType = {
    bill_id: number | null
    patient_id: number | null
    total_amount: number | null
    amount_paid: number | null
  }

  export type BillsMinAggregateOutputType = {
    bill_id: number | null
    patient_id: number | null
    total_amount: number | null
    billing_date: Date | null
    insurance_covered: boolean | null
    amount_paid: number | null
  }

  export type BillsMaxAggregateOutputType = {
    bill_id: number | null
    patient_id: number | null
    total_amount: number | null
    billing_date: Date | null
    insurance_covered: boolean | null
    amount_paid: number | null
  }

  export type BillsCountAggregateOutputType = {
    bill_id: number
    patient_id: number
    total_amount: number
    billing_date: number
    insurance_covered: number
    amount_paid: number
    _all: number
  }


  export type BillsAvgAggregateInputType = {
    bill_id?: true
    patient_id?: true
    total_amount?: true
    amount_paid?: true
  }

  export type BillsSumAggregateInputType = {
    bill_id?: true
    patient_id?: true
    total_amount?: true
    amount_paid?: true
  }

  export type BillsMinAggregateInputType = {
    bill_id?: true
    patient_id?: true
    total_amount?: true
    billing_date?: true
    insurance_covered?: true
    amount_paid?: true
  }

  export type BillsMaxAggregateInputType = {
    bill_id?: true
    patient_id?: true
    total_amount?: true
    billing_date?: true
    insurance_covered?: true
    amount_paid?: true
  }

  export type BillsCountAggregateInputType = {
    bill_id?: true
    patient_id?: true
    total_amount?: true
    billing_date?: true
    insurance_covered?: true
    amount_paid?: true
    _all?: true
  }

  export type BillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to aggregate.
     */
    where?: BillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bills
    **/
    _count?: true | BillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BillsMaxAggregateInputType
  }

  export type GetBillsAggregateType<T extends BillsAggregateArgs> = {
        [P in keyof T & keyof AggregateBills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBills[P]>
      : GetScalarType<T[P], AggregateBills[P]>
  }




  export type BillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BillsWhereInput
    orderBy?: BillsOrderByWithAggregationInput | BillsOrderByWithAggregationInput[]
    by: BillsScalarFieldEnum[] | BillsScalarFieldEnum
    having?: BillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BillsCountAggregateInputType | true
    _avg?: BillsAvgAggregateInputType
    _sum?: BillsSumAggregateInputType
    _min?: BillsMinAggregateInputType
    _max?: BillsMaxAggregateInputType
  }

  export type BillsGroupByOutputType = {
    bill_id: number
    patient_id: number
    total_amount: number
    billing_date: Date
    insurance_covered: boolean
    amount_paid: number
    _count: BillsCountAggregateOutputType | null
    _avg: BillsAvgAggregateOutputType | null
    _sum: BillsSumAggregateOutputType | null
    _min: BillsMinAggregateOutputType | null
    _max: BillsMaxAggregateOutputType | null
  }

  type GetBillsGroupByPayload<T extends BillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BillsGroupByOutputType[P]>
            : GetScalarType<T[P], BillsGroupByOutputType[P]>
        }
      >
    >


  export type BillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bill_id?: boolean
    patient_id?: boolean
    total_amount?: boolean
    billing_date?: boolean
    insurance_covered?: boolean
    amount_paid?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bills"]>

  export type BillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    bill_id?: boolean
    patient_id?: boolean
    total_amount?: boolean
    billing_date?: boolean
    insurance_covered?: boolean
    amount_paid?: boolean
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bills"]>

  export type BillsSelectScalar = {
    bill_id?: boolean
    patient_id?: boolean
    total_amount?: boolean
    billing_date?: boolean
    insurance_covered?: boolean
    amount_paid?: boolean
  }

  export type BillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }
  export type BillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientsDefaultArgs<ExtArgs>
  }

  export type $BillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bills"
    objects: {
      patient: Prisma.$PatientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      bill_id: number
      patient_id: number
      total_amount: number
      billing_date: Date
      insurance_covered: boolean
      amount_paid: number
    }, ExtArgs["result"]["bills"]>
    composites: {}
  }

  type BillsGetPayload<S extends boolean | null | undefined | BillsDefaultArgs> = $Result.GetResult<Prisma.$BillsPayload, S>

  type BillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BillsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BillsCountAggregateInputType | true
    }

  export interface BillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bills'], meta: { name: 'Bills' } }
    /**
     * Find zero or one Bills that matches the filter.
     * @param {BillsFindUniqueArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BillsFindUniqueArgs>(args: SelectSubset<T, BillsFindUniqueArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bills that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BillsFindUniqueOrThrowArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BillsFindUniqueOrThrowArgs>(args: SelectSubset<T, BillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsFindFirstArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BillsFindFirstArgs>(args?: SelectSubset<T, BillsFindFirstArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsFindFirstOrThrowArgs} args - Arguments to find a Bills
     * @example
     * // Get one Bills
     * const bills = await prisma.bills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BillsFindFirstOrThrowArgs>(args?: SelectSubset<T, BillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills
     * const bills = await prisma.bills.findMany()
     * 
     * // Get first 10 Bills
     * const bills = await prisma.bills.findMany({ take: 10 })
     * 
     * // Only select the `bill_id`
     * const billsWithBill_idOnly = await prisma.bills.findMany({ select: { bill_id: true } })
     * 
     */
    findMany<T extends BillsFindManyArgs>(args?: SelectSubset<T, BillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bills.
     * @param {BillsCreateArgs} args - Arguments to create a Bills.
     * @example
     * // Create one Bills
     * const Bills = await prisma.bills.create({
     *   data: {
     *     // ... data to create a Bills
     *   }
     * })
     * 
     */
    create<T extends BillsCreateArgs>(args: SelectSubset<T, BillsCreateArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bills.
     * @param {BillsCreateManyArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bills = await prisma.bills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BillsCreateManyArgs>(args?: SelectSubset<T, BillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bills and returns the data saved in the database.
     * @param {BillsCreateManyAndReturnArgs} args - Arguments to create many Bills.
     * @example
     * // Create many Bills
     * const bills = await prisma.bills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bills and only return the `bill_id`
     * const billsWithBill_idOnly = await prisma.bills.createManyAndReturn({ 
     *   select: { bill_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BillsCreateManyAndReturnArgs>(args?: SelectSubset<T, BillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bills.
     * @param {BillsDeleteArgs} args - Arguments to delete one Bills.
     * @example
     * // Delete one Bills
     * const Bills = await prisma.bills.delete({
     *   where: {
     *     // ... filter to delete one Bills
     *   }
     * })
     * 
     */
    delete<T extends BillsDeleteArgs>(args: SelectSubset<T, BillsDeleteArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bills.
     * @param {BillsUpdateArgs} args - Arguments to update one Bills.
     * @example
     * // Update one Bills
     * const bills = await prisma.bills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BillsUpdateArgs>(args: SelectSubset<T, BillsUpdateArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bills.
     * @param {BillsDeleteManyArgs} args - Arguments to filter Bills to delete.
     * @example
     * // Delete a few Bills
     * const { count } = await prisma.bills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BillsDeleteManyArgs>(args?: SelectSubset<T, BillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills
     * const bills = await prisma.bills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BillsUpdateManyArgs>(args: SelectSubset<T, BillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bills.
     * @param {BillsUpsertArgs} args - Arguments to update or create a Bills.
     * @example
     * // Update or create a Bills
     * const bills = await prisma.bills.upsert({
     *   create: {
     *     // ... data to create a Bills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bills we want to update
     *   }
     * })
     */
    upsert<T extends BillsUpsertArgs>(args: SelectSubset<T, BillsUpsertArgs<ExtArgs>>): Prisma__BillsClient<$Result.GetResult<Prisma.$BillsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsCountArgs} args - Arguments to filter Bills to count.
     * @example
     * // Count the number of Bills
     * const count = await prisma.bills.count({
     *   where: {
     *     // ... the filter for the Bills we want to count
     *   }
     * })
    **/
    count<T extends BillsCountArgs>(
      args?: Subset<T, BillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BillsAggregateArgs>(args: Subset<T, BillsAggregateArgs>): Prisma.PrismaPromise<GetBillsAggregateType<T>>

    /**
     * Group by Bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BillsGroupByArgs['orderBy'] }
        : { orderBy?: BillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bills model
   */
  readonly fields: BillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientsDefaultArgs<ExtArgs>>): Prisma__PatientsClient<$Result.GetResult<Prisma.$PatientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bills model
   */ 
  interface BillsFieldRefs {
    readonly bill_id: FieldRef<"Bills", 'Int'>
    readonly patient_id: FieldRef<"Bills", 'Int'>
    readonly total_amount: FieldRef<"Bills", 'Float'>
    readonly billing_date: FieldRef<"Bills", 'DateTime'>
    readonly insurance_covered: FieldRef<"Bills", 'Boolean'>
    readonly amount_paid: FieldRef<"Bills", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Bills findUnique
   */
  export type BillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where: BillsWhereUniqueInput
  }

  /**
   * Bills findUniqueOrThrow
   */
  export type BillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where: BillsWhereUniqueInput
  }

  /**
   * Bills findFirst
   */
  export type BillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Bills findFirstOrThrow
   */
  export type BillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bills.
     */
    cursor?: BillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bills.
     */
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Bills findMany
   */
  export type BillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter, which Bills to fetch.
     */
    where?: BillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bills to fetch.
     */
    orderBy?: BillsOrderByWithRelationInput | BillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bills.
     */
    cursor?: BillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bills.
     */
    skip?: number
    distinct?: BillsScalarFieldEnum | BillsScalarFieldEnum[]
  }

  /**
   * Bills create
   */
  export type BillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * The data needed to create a Bills.
     */
    data: XOR<BillsCreateInput, BillsUncheckedCreateInput>
  }

  /**
   * Bills createMany
   */
  export type BillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bills.
     */
    data: BillsCreateManyInput | BillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bills createManyAndReturn
   */
  export type BillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bills.
     */
    data: BillsCreateManyInput | BillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bills update
   */
  export type BillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * The data needed to update a Bills.
     */
    data: XOR<BillsUpdateInput, BillsUncheckedUpdateInput>
    /**
     * Choose, which Bills to update.
     */
    where: BillsWhereUniqueInput
  }

  /**
   * Bills updateMany
   */
  export type BillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bills.
     */
    data: XOR<BillsUpdateManyMutationInput, BillsUncheckedUpdateManyInput>
    /**
     * Filter which Bills to update
     */
    where?: BillsWhereInput
  }

  /**
   * Bills upsert
   */
  export type BillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * The filter to search for the Bills to update in case it exists.
     */
    where: BillsWhereUniqueInput
    /**
     * In case the Bills found by the `where` argument doesn't exist, create a new Bills with this data.
     */
    create: XOR<BillsCreateInput, BillsUncheckedCreateInput>
    /**
     * In case the Bills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BillsUpdateInput, BillsUncheckedUpdateInput>
  }

  /**
   * Bills delete
   */
  export type BillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
    /**
     * Filter which Bills to delete.
     */
    where: BillsWhereUniqueInput
  }

  /**
   * Bills deleteMany
   */
  export type BillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bills to delete
     */
    where?: BillsWhereInput
  }

  /**
   * Bills without action
   */
  export type BillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bills
     */
    select?: BillsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BillsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PatientsScalarFieldEnum: {
    patient_id: 'patient_id',
    first_name: 'first_name',
    last_name: 'last_name',
    date_of_birth: 'date_of_birth',
    gender: 'gender',
    contact_number: 'contact_number',
    address: 'address'
  };

  export type PatientsScalarFieldEnum = (typeof PatientsScalarFieldEnum)[keyof typeof PatientsScalarFieldEnum]


  export const DoctorsScalarFieldEnum: {
    doctor_id: 'doctor_id',
    first_name: 'first_name',
    last_name: 'last_name',
    specialty: 'specialty',
    contact_number: 'contact_number',
    department_id: 'department_id'
  };

  export type DoctorsScalarFieldEnum = (typeof DoctorsScalarFieldEnum)[keyof typeof DoctorsScalarFieldEnum]


  export const DepartmentsScalarFieldEnum: {
    department_id: 'department_id',
    department_name: 'department_name'
  };

  export type DepartmentsScalarFieldEnum = (typeof DepartmentsScalarFieldEnum)[keyof typeof DepartmentsScalarFieldEnum]


  export const AppointmentsScalarFieldEnum: {
    appointment_id: 'appointment_id',
    patient_id: 'patient_id',
    doctor_id: 'doctor_id',
    appointment_date: 'appointment_date',
    reason_for_visit: 'reason_for_visit'
  };

  export type AppointmentsScalarFieldEnum = (typeof AppointmentsScalarFieldEnum)[keyof typeof AppointmentsScalarFieldEnum]


  export const RoomsScalarFieldEnum: {
    room_id: 'room_id',
    room_number: 'room_number',
    room_type: 'room_type',
    availability_status: 'availability_status'
  };

  export type RoomsScalarFieldEnum = (typeof RoomsScalarFieldEnum)[keyof typeof RoomsScalarFieldEnum]


  export const MedicalHistoryScalarFieldEnum: {
    history_id: 'history_id',
    patient_id: 'patient_id',
    treatment: 'treatment',
    treatment_date: 'treatment_date'
  };

  export type MedicalHistoryScalarFieldEnum = (typeof MedicalHistoryScalarFieldEnum)[keyof typeof MedicalHistoryScalarFieldEnum]


  export const DiagnosisScalarFieldEnum: {
    diagnosis_id: 'diagnosis_id',
    patient_id: 'patient_id',
    doctor_id: 'doctor_id',
    diagnosis_description: 'diagnosis_description',
    diagnosis_date: 'diagnosis_date'
  };

  export type DiagnosisScalarFieldEnum = (typeof DiagnosisScalarFieldEnum)[keyof typeof DiagnosisScalarFieldEnum]


  export const MedicationsScalarFieldEnum: {
    medication_id: 'medication_id',
    medication_name: 'medication_name',
    dosage: 'dosage',
    side_effects: 'side_effects'
  };

  export type MedicationsScalarFieldEnum = (typeof MedicationsScalarFieldEnum)[keyof typeof MedicationsScalarFieldEnum]


  export const TreatmentsScalarFieldEnum: {
    treatment_id: 'treatment_id',
    patient_id: 'patient_id',
    doctor_id: 'doctor_id',
    medication_id: 'medication_id',
    treatment_description: 'treatment_description',
    treatment_date: 'treatment_date'
  };

  export type TreatmentsScalarFieldEnum = (typeof TreatmentsScalarFieldEnum)[keyof typeof TreatmentsScalarFieldEnum]


  export const InsuranceScalarFieldEnum: {
    insurance_id: 'insurance_id',
    patient_id: 'patient_id',
    provider_name: 'provider_name',
    policy_number: 'policy_number',
    coverage_amount: 'coverage_amount'
  };

  export type InsuranceScalarFieldEnum = (typeof InsuranceScalarFieldEnum)[keyof typeof InsuranceScalarFieldEnum]


  export const LabTestsScalarFieldEnum: {
    test_id: 'test_id',
    patient_id: 'patient_id',
    test_name: 'test_name',
    test_result: 'test_result',
    test_date: 'test_date',
    doctor_id: 'doctor_id'
  };

  export type LabTestsScalarFieldEnum = (typeof LabTestsScalarFieldEnum)[keyof typeof LabTestsScalarFieldEnum]


  export const BillsScalarFieldEnum: {
    bill_id: 'bill_id',
    patient_id: 'patient_id',
    total_amount: 'total_amount',
    billing_date: 'billing_date',
    insurance_covered: 'insurance_covered',
    amount_paid: 'amount_paid'
  };

  export type BillsScalarFieldEnum = (typeof BillsScalarFieldEnum)[keyof typeof BillsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type PatientsWhereInput = {
    AND?: PatientsWhereInput | PatientsWhereInput[]
    OR?: PatientsWhereInput[]
    NOT?: PatientsWhereInput | PatientsWhereInput[]
    patient_id?: IntFilter<"Patients"> | number
    first_name?: StringFilter<"Patients"> | string
    last_name?: StringFilter<"Patients"> | string
    date_of_birth?: DateTimeFilter<"Patients"> | Date | string
    gender?: StringFilter<"Patients"> | string
    contact_number?: StringFilter<"Patients"> | string
    address?: StringFilter<"Patients"> | string
    appointments?: AppointmentsListRelationFilter
    medicalHistory?: MedicalHistoryListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
    treatments?: TreatmentsListRelationFilter
    insurance?: InsuranceListRelationFilter
    labTests?: LabTestsListRelationFilter
    bills?: BillsListRelationFilter
  }

  export type PatientsOrderByWithRelationInput = {
    patient_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    contact_number?: SortOrder
    address?: SortOrder
    appointments?: AppointmentsOrderByRelationAggregateInput
    medicalHistory?: MedicalHistoryOrderByRelationAggregateInput
    diagnosis?: DiagnosisOrderByRelationAggregateInput
    treatments?: TreatmentsOrderByRelationAggregateInput
    insurance?: InsuranceOrderByRelationAggregateInput
    labTests?: LabTestsOrderByRelationAggregateInput
    bills?: BillsOrderByRelationAggregateInput
  }

  export type PatientsWhereUniqueInput = Prisma.AtLeast<{
    patient_id?: number
    AND?: PatientsWhereInput | PatientsWhereInput[]
    OR?: PatientsWhereInput[]
    NOT?: PatientsWhereInput | PatientsWhereInput[]
    first_name?: StringFilter<"Patients"> | string
    last_name?: StringFilter<"Patients"> | string
    date_of_birth?: DateTimeFilter<"Patients"> | Date | string
    gender?: StringFilter<"Patients"> | string
    contact_number?: StringFilter<"Patients"> | string
    address?: StringFilter<"Patients"> | string
    appointments?: AppointmentsListRelationFilter
    medicalHistory?: MedicalHistoryListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
    treatments?: TreatmentsListRelationFilter
    insurance?: InsuranceListRelationFilter
    labTests?: LabTestsListRelationFilter
    bills?: BillsListRelationFilter
  }, "patient_id">

  export type PatientsOrderByWithAggregationInput = {
    patient_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    contact_number?: SortOrder
    address?: SortOrder
    _count?: PatientsCountOrderByAggregateInput
    _avg?: PatientsAvgOrderByAggregateInput
    _max?: PatientsMaxOrderByAggregateInput
    _min?: PatientsMinOrderByAggregateInput
    _sum?: PatientsSumOrderByAggregateInput
  }

  export type PatientsScalarWhereWithAggregatesInput = {
    AND?: PatientsScalarWhereWithAggregatesInput | PatientsScalarWhereWithAggregatesInput[]
    OR?: PatientsScalarWhereWithAggregatesInput[]
    NOT?: PatientsScalarWhereWithAggregatesInput | PatientsScalarWhereWithAggregatesInput[]
    patient_id?: IntWithAggregatesFilter<"Patients"> | number
    first_name?: StringWithAggregatesFilter<"Patients"> | string
    last_name?: StringWithAggregatesFilter<"Patients"> | string
    date_of_birth?: DateTimeWithAggregatesFilter<"Patients"> | Date | string
    gender?: StringWithAggregatesFilter<"Patients"> | string
    contact_number?: StringWithAggregatesFilter<"Patients"> | string
    address?: StringWithAggregatesFilter<"Patients"> | string
  }

  export type DoctorsWhereInput = {
    AND?: DoctorsWhereInput | DoctorsWhereInput[]
    OR?: DoctorsWhereInput[]
    NOT?: DoctorsWhereInput | DoctorsWhereInput[]
    doctor_id?: IntFilter<"Doctors"> | number
    first_name?: StringFilter<"Doctors"> | string
    last_name?: StringFilter<"Doctors"> | string
    specialty?: StringFilter<"Doctors"> | string
    contact_number?: StringFilter<"Doctors"> | string
    department_id?: IntFilter<"Doctors"> | number
    department?: XOR<DepartmentsRelationFilter, DepartmentsWhereInput>
    appointments?: AppointmentsListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
    treatments?: TreatmentsListRelationFilter
    labTests?: LabTestsListRelationFilter
  }

  export type DoctorsOrderByWithRelationInput = {
    doctor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    specialty?: SortOrder
    contact_number?: SortOrder
    department_id?: SortOrder
    department?: DepartmentsOrderByWithRelationInput
    appointments?: AppointmentsOrderByRelationAggregateInput
    diagnosis?: DiagnosisOrderByRelationAggregateInput
    treatments?: TreatmentsOrderByRelationAggregateInput
    labTests?: LabTestsOrderByRelationAggregateInput
  }

  export type DoctorsWhereUniqueInput = Prisma.AtLeast<{
    doctor_id?: number
    AND?: DoctorsWhereInput | DoctorsWhereInput[]
    OR?: DoctorsWhereInput[]
    NOT?: DoctorsWhereInput | DoctorsWhereInput[]
    first_name?: StringFilter<"Doctors"> | string
    last_name?: StringFilter<"Doctors"> | string
    specialty?: StringFilter<"Doctors"> | string
    contact_number?: StringFilter<"Doctors"> | string
    department_id?: IntFilter<"Doctors"> | number
    department?: XOR<DepartmentsRelationFilter, DepartmentsWhereInput>
    appointments?: AppointmentsListRelationFilter
    diagnosis?: DiagnosisListRelationFilter
    treatments?: TreatmentsListRelationFilter
    labTests?: LabTestsListRelationFilter
  }, "doctor_id">

  export type DoctorsOrderByWithAggregationInput = {
    doctor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    specialty?: SortOrder
    contact_number?: SortOrder
    department_id?: SortOrder
    _count?: DoctorsCountOrderByAggregateInput
    _avg?: DoctorsAvgOrderByAggregateInput
    _max?: DoctorsMaxOrderByAggregateInput
    _min?: DoctorsMinOrderByAggregateInput
    _sum?: DoctorsSumOrderByAggregateInput
  }

  export type DoctorsScalarWhereWithAggregatesInput = {
    AND?: DoctorsScalarWhereWithAggregatesInput | DoctorsScalarWhereWithAggregatesInput[]
    OR?: DoctorsScalarWhereWithAggregatesInput[]
    NOT?: DoctorsScalarWhereWithAggregatesInput | DoctorsScalarWhereWithAggregatesInput[]
    doctor_id?: IntWithAggregatesFilter<"Doctors"> | number
    first_name?: StringWithAggregatesFilter<"Doctors"> | string
    last_name?: StringWithAggregatesFilter<"Doctors"> | string
    specialty?: StringWithAggregatesFilter<"Doctors"> | string
    contact_number?: StringWithAggregatesFilter<"Doctors"> | string
    department_id?: IntWithAggregatesFilter<"Doctors"> | number
  }

  export type DepartmentsWhereInput = {
    AND?: DepartmentsWhereInput | DepartmentsWhereInput[]
    OR?: DepartmentsWhereInput[]
    NOT?: DepartmentsWhereInput | DepartmentsWhereInput[]
    department_id?: IntFilter<"Departments"> | number
    department_name?: StringFilter<"Departments"> | string
    doctors?: DoctorsListRelationFilter
  }

  export type DepartmentsOrderByWithRelationInput = {
    department_id?: SortOrder
    department_name?: SortOrder
    doctors?: DoctorsOrderByRelationAggregateInput
  }

  export type DepartmentsWhereUniqueInput = Prisma.AtLeast<{
    department_id?: number
    AND?: DepartmentsWhereInput | DepartmentsWhereInput[]
    OR?: DepartmentsWhereInput[]
    NOT?: DepartmentsWhereInput | DepartmentsWhereInput[]
    department_name?: StringFilter<"Departments"> | string
    doctors?: DoctorsListRelationFilter
  }, "department_id">

  export type DepartmentsOrderByWithAggregationInput = {
    department_id?: SortOrder
    department_name?: SortOrder
    _count?: DepartmentsCountOrderByAggregateInput
    _avg?: DepartmentsAvgOrderByAggregateInput
    _max?: DepartmentsMaxOrderByAggregateInput
    _min?: DepartmentsMinOrderByAggregateInput
    _sum?: DepartmentsSumOrderByAggregateInput
  }

  export type DepartmentsScalarWhereWithAggregatesInput = {
    AND?: DepartmentsScalarWhereWithAggregatesInput | DepartmentsScalarWhereWithAggregatesInput[]
    OR?: DepartmentsScalarWhereWithAggregatesInput[]
    NOT?: DepartmentsScalarWhereWithAggregatesInput | DepartmentsScalarWhereWithAggregatesInput[]
    department_id?: IntWithAggregatesFilter<"Departments"> | number
    department_name?: StringWithAggregatesFilter<"Departments"> | string
  }

  export type AppointmentsWhereInput = {
    AND?: AppointmentsWhereInput | AppointmentsWhereInput[]
    OR?: AppointmentsWhereInput[]
    NOT?: AppointmentsWhereInput | AppointmentsWhereInput[]
    appointment_id?: IntFilter<"Appointments"> | number
    patient_id?: IntFilter<"Appointments"> | number
    doctor_id?: IntFilter<"Appointments"> | number
    appointment_date?: DateTimeFilter<"Appointments"> | Date | string
    reason_for_visit?: StringFilter<"Appointments"> | string
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
    doctor?: XOR<DoctorsRelationFilter, DoctorsWhereInput>
  }

  export type AppointmentsOrderByWithRelationInput = {
    appointment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointment_date?: SortOrder
    reason_for_visit?: SortOrder
    patient?: PatientsOrderByWithRelationInput
    doctor?: DoctorsOrderByWithRelationInput
  }

  export type AppointmentsWhereUniqueInput = Prisma.AtLeast<{
    appointment_id?: number
    AND?: AppointmentsWhereInput | AppointmentsWhereInput[]
    OR?: AppointmentsWhereInput[]
    NOT?: AppointmentsWhereInput | AppointmentsWhereInput[]
    patient_id?: IntFilter<"Appointments"> | number
    doctor_id?: IntFilter<"Appointments"> | number
    appointment_date?: DateTimeFilter<"Appointments"> | Date | string
    reason_for_visit?: StringFilter<"Appointments"> | string
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
    doctor?: XOR<DoctorsRelationFilter, DoctorsWhereInput>
  }, "appointment_id">

  export type AppointmentsOrderByWithAggregationInput = {
    appointment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointment_date?: SortOrder
    reason_for_visit?: SortOrder
    _count?: AppointmentsCountOrderByAggregateInput
    _avg?: AppointmentsAvgOrderByAggregateInput
    _max?: AppointmentsMaxOrderByAggregateInput
    _min?: AppointmentsMinOrderByAggregateInput
    _sum?: AppointmentsSumOrderByAggregateInput
  }

  export type AppointmentsScalarWhereWithAggregatesInput = {
    AND?: AppointmentsScalarWhereWithAggregatesInput | AppointmentsScalarWhereWithAggregatesInput[]
    OR?: AppointmentsScalarWhereWithAggregatesInput[]
    NOT?: AppointmentsScalarWhereWithAggregatesInput | AppointmentsScalarWhereWithAggregatesInput[]
    appointment_id?: IntWithAggregatesFilter<"Appointments"> | number
    patient_id?: IntWithAggregatesFilter<"Appointments"> | number
    doctor_id?: IntWithAggregatesFilter<"Appointments"> | number
    appointment_date?: DateTimeWithAggregatesFilter<"Appointments"> | Date | string
    reason_for_visit?: StringWithAggregatesFilter<"Appointments"> | string
  }

  export type RoomsWhereInput = {
    AND?: RoomsWhereInput | RoomsWhereInput[]
    OR?: RoomsWhereInput[]
    NOT?: RoomsWhereInput | RoomsWhereInput[]
    room_id?: IntFilter<"Rooms"> | number
    room_number?: StringFilter<"Rooms"> | string
    room_type?: StringFilter<"Rooms"> | string
    availability_status?: BoolFilter<"Rooms"> | boolean
  }

  export type RoomsOrderByWithRelationInput = {
    room_id?: SortOrder
    room_number?: SortOrder
    room_type?: SortOrder
    availability_status?: SortOrder
  }

  export type RoomsWhereUniqueInput = Prisma.AtLeast<{
    room_id?: number
    AND?: RoomsWhereInput | RoomsWhereInput[]
    OR?: RoomsWhereInput[]
    NOT?: RoomsWhereInput | RoomsWhereInput[]
    room_number?: StringFilter<"Rooms"> | string
    room_type?: StringFilter<"Rooms"> | string
    availability_status?: BoolFilter<"Rooms"> | boolean
  }, "room_id">

  export type RoomsOrderByWithAggregationInput = {
    room_id?: SortOrder
    room_number?: SortOrder
    room_type?: SortOrder
    availability_status?: SortOrder
    _count?: RoomsCountOrderByAggregateInput
    _avg?: RoomsAvgOrderByAggregateInput
    _max?: RoomsMaxOrderByAggregateInput
    _min?: RoomsMinOrderByAggregateInput
    _sum?: RoomsSumOrderByAggregateInput
  }

  export type RoomsScalarWhereWithAggregatesInput = {
    AND?: RoomsScalarWhereWithAggregatesInput | RoomsScalarWhereWithAggregatesInput[]
    OR?: RoomsScalarWhereWithAggregatesInput[]
    NOT?: RoomsScalarWhereWithAggregatesInput | RoomsScalarWhereWithAggregatesInput[]
    room_id?: IntWithAggregatesFilter<"Rooms"> | number
    room_number?: StringWithAggregatesFilter<"Rooms"> | string
    room_type?: StringWithAggregatesFilter<"Rooms"> | string
    availability_status?: BoolWithAggregatesFilter<"Rooms"> | boolean
  }

  export type MedicalHistoryWhereInput = {
    AND?: MedicalHistoryWhereInput | MedicalHistoryWhereInput[]
    OR?: MedicalHistoryWhereInput[]
    NOT?: MedicalHistoryWhereInput | MedicalHistoryWhereInput[]
    history_id?: IntFilter<"MedicalHistory"> | number
    patient_id?: IntFilter<"MedicalHistory"> | number
    treatment?: StringFilter<"MedicalHistory"> | string
    treatment_date?: DateTimeFilter<"MedicalHistory"> | Date | string
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
  }

  export type MedicalHistoryOrderByWithRelationInput = {
    history_id?: SortOrder
    patient_id?: SortOrder
    treatment?: SortOrder
    treatment_date?: SortOrder
    patient?: PatientsOrderByWithRelationInput
  }

  export type MedicalHistoryWhereUniqueInput = Prisma.AtLeast<{
    history_id?: number
    AND?: MedicalHistoryWhereInput | MedicalHistoryWhereInput[]
    OR?: MedicalHistoryWhereInput[]
    NOT?: MedicalHistoryWhereInput | MedicalHistoryWhereInput[]
    patient_id?: IntFilter<"MedicalHistory"> | number
    treatment?: StringFilter<"MedicalHistory"> | string
    treatment_date?: DateTimeFilter<"MedicalHistory"> | Date | string
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
  }, "history_id">

  export type MedicalHistoryOrderByWithAggregationInput = {
    history_id?: SortOrder
    patient_id?: SortOrder
    treatment?: SortOrder
    treatment_date?: SortOrder
    _count?: MedicalHistoryCountOrderByAggregateInput
    _avg?: MedicalHistoryAvgOrderByAggregateInput
    _max?: MedicalHistoryMaxOrderByAggregateInput
    _min?: MedicalHistoryMinOrderByAggregateInput
    _sum?: MedicalHistorySumOrderByAggregateInput
  }

  export type MedicalHistoryScalarWhereWithAggregatesInput = {
    AND?: MedicalHistoryScalarWhereWithAggregatesInput | MedicalHistoryScalarWhereWithAggregatesInput[]
    OR?: MedicalHistoryScalarWhereWithAggregatesInput[]
    NOT?: MedicalHistoryScalarWhereWithAggregatesInput | MedicalHistoryScalarWhereWithAggregatesInput[]
    history_id?: IntWithAggregatesFilter<"MedicalHistory"> | number
    patient_id?: IntWithAggregatesFilter<"MedicalHistory"> | number
    treatment?: StringWithAggregatesFilter<"MedicalHistory"> | string
    treatment_date?: DateTimeWithAggregatesFilter<"MedicalHistory"> | Date | string
  }

  export type DiagnosisWhereInput = {
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    diagnosis_id?: IntFilter<"Diagnosis"> | number
    patient_id?: IntFilter<"Diagnosis"> | number
    doctor_id?: IntFilter<"Diagnosis"> | number
    diagnosis_description?: StringFilter<"Diagnosis"> | string
    diagnosis_date?: DateTimeFilter<"Diagnosis"> | Date | string
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
    doctor?: XOR<DoctorsRelationFilter, DoctorsWhereInput>
  }

  export type DiagnosisOrderByWithRelationInput = {
    diagnosis_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    diagnosis_description?: SortOrder
    diagnosis_date?: SortOrder
    patient?: PatientsOrderByWithRelationInput
    doctor?: DoctorsOrderByWithRelationInput
  }

  export type DiagnosisWhereUniqueInput = Prisma.AtLeast<{
    diagnosis_id?: number
    AND?: DiagnosisWhereInput | DiagnosisWhereInput[]
    OR?: DiagnosisWhereInput[]
    NOT?: DiagnosisWhereInput | DiagnosisWhereInput[]
    patient_id?: IntFilter<"Diagnosis"> | number
    doctor_id?: IntFilter<"Diagnosis"> | number
    diagnosis_description?: StringFilter<"Diagnosis"> | string
    diagnosis_date?: DateTimeFilter<"Diagnosis"> | Date | string
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
    doctor?: XOR<DoctorsRelationFilter, DoctorsWhereInput>
  }, "diagnosis_id">

  export type DiagnosisOrderByWithAggregationInput = {
    diagnosis_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    diagnosis_description?: SortOrder
    diagnosis_date?: SortOrder
    _count?: DiagnosisCountOrderByAggregateInput
    _avg?: DiagnosisAvgOrderByAggregateInput
    _max?: DiagnosisMaxOrderByAggregateInput
    _min?: DiagnosisMinOrderByAggregateInput
    _sum?: DiagnosisSumOrderByAggregateInput
  }

  export type DiagnosisScalarWhereWithAggregatesInput = {
    AND?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    OR?: DiagnosisScalarWhereWithAggregatesInput[]
    NOT?: DiagnosisScalarWhereWithAggregatesInput | DiagnosisScalarWhereWithAggregatesInput[]
    diagnosis_id?: IntWithAggregatesFilter<"Diagnosis"> | number
    patient_id?: IntWithAggregatesFilter<"Diagnosis"> | number
    doctor_id?: IntWithAggregatesFilter<"Diagnosis"> | number
    diagnosis_description?: StringWithAggregatesFilter<"Diagnosis"> | string
    diagnosis_date?: DateTimeWithAggregatesFilter<"Diagnosis"> | Date | string
  }

  export type MedicationsWhereInput = {
    AND?: MedicationsWhereInput | MedicationsWhereInput[]
    OR?: MedicationsWhereInput[]
    NOT?: MedicationsWhereInput | MedicationsWhereInput[]
    medication_id?: IntFilter<"Medications"> | number
    medication_name?: StringFilter<"Medications"> | string
    dosage?: StringFilter<"Medications"> | string
    side_effects?: StringFilter<"Medications"> | string
    treatments?: TreatmentsListRelationFilter
  }

  export type MedicationsOrderByWithRelationInput = {
    medication_id?: SortOrder
    medication_name?: SortOrder
    dosage?: SortOrder
    side_effects?: SortOrder
    treatments?: TreatmentsOrderByRelationAggregateInput
  }

  export type MedicationsWhereUniqueInput = Prisma.AtLeast<{
    medication_id?: number
    AND?: MedicationsWhereInput | MedicationsWhereInput[]
    OR?: MedicationsWhereInput[]
    NOT?: MedicationsWhereInput | MedicationsWhereInput[]
    medication_name?: StringFilter<"Medications"> | string
    dosage?: StringFilter<"Medications"> | string
    side_effects?: StringFilter<"Medications"> | string
    treatments?: TreatmentsListRelationFilter
  }, "medication_id">

  export type MedicationsOrderByWithAggregationInput = {
    medication_id?: SortOrder
    medication_name?: SortOrder
    dosage?: SortOrder
    side_effects?: SortOrder
    _count?: MedicationsCountOrderByAggregateInput
    _avg?: MedicationsAvgOrderByAggregateInput
    _max?: MedicationsMaxOrderByAggregateInput
    _min?: MedicationsMinOrderByAggregateInput
    _sum?: MedicationsSumOrderByAggregateInput
  }

  export type MedicationsScalarWhereWithAggregatesInput = {
    AND?: MedicationsScalarWhereWithAggregatesInput | MedicationsScalarWhereWithAggregatesInput[]
    OR?: MedicationsScalarWhereWithAggregatesInput[]
    NOT?: MedicationsScalarWhereWithAggregatesInput | MedicationsScalarWhereWithAggregatesInput[]
    medication_id?: IntWithAggregatesFilter<"Medications"> | number
    medication_name?: StringWithAggregatesFilter<"Medications"> | string
    dosage?: StringWithAggregatesFilter<"Medications"> | string
    side_effects?: StringWithAggregatesFilter<"Medications"> | string
  }

  export type TreatmentsWhereInput = {
    AND?: TreatmentsWhereInput | TreatmentsWhereInput[]
    OR?: TreatmentsWhereInput[]
    NOT?: TreatmentsWhereInput | TreatmentsWhereInput[]
    treatment_id?: IntFilter<"Treatments"> | number
    patient_id?: IntFilter<"Treatments"> | number
    doctor_id?: IntFilter<"Treatments"> | number
    medication_id?: IntFilter<"Treatments"> | number
    treatment_description?: StringFilter<"Treatments"> | string
    treatment_date?: DateTimeFilter<"Treatments"> | Date | string
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
    doctor?: XOR<DoctorsRelationFilter, DoctorsWhereInput>
    medication?: XOR<MedicationsRelationFilter, MedicationsWhereInput>
  }

  export type TreatmentsOrderByWithRelationInput = {
    treatment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    medication_id?: SortOrder
    treatment_description?: SortOrder
    treatment_date?: SortOrder
    patient?: PatientsOrderByWithRelationInput
    doctor?: DoctorsOrderByWithRelationInput
    medication?: MedicationsOrderByWithRelationInput
  }

  export type TreatmentsWhereUniqueInput = Prisma.AtLeast<{
    treatment_id?: number
    AND?: TreatmentsWhereInput | TreatmentsWhereInput[]
    OR?: TreatmentsWhereInput[]
    NOT?: TreatmentsWhereInput | TreatmentsWhereInput[]
    patient_id?: IntFilter<"Treatments"> | number
    doctor_id?: IntFilter<"Treatments"> | number
    medication_id?: IntFilter<"Treatments"> | number
    treatment_description?: StringFilter<"Treatments"> | string
    treatment_date?: DateTimeFilter<"Treatments"> | Date | string
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
    doctor?: XOR<DoctorsRelationFilter, DoctorsWhereInput>
    medication?: XOR<MedicationsRelationFilter, MedicationsWhereInput>
  }, "treatment_id">

  export type TreatmentsOrderByWithAggregationInput = {
    treatment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    medication_id?: SortOrder
    treatment_description?: SortOrder
    treatment_date?: SortOrder
    _count?: TreatmentsCountOrderByAggregateInput
    _avg?: TreatmentsAvgOrderByAggregateInput
    _max?: TreatmentsMaxOrderByAggregateInput
    _min?: TreatmentsMinOrderByAggregateInput
    _sum?: TreatmentsSumOrderByAggregateInput
  }

  export type TreatmentsScalarWhereWithAggregatesInput = {
    AND?: TreatmentsScalarWhereWithAggregatesInput | TreatmentsScalarWhereWithAggregatesInput[]
    OR?: TreatmentsScalarWhereWithAggregatesInput[]
    NOT?: TreatmentsScalarWhereWithAggregatesInput | TreatmentsScalarWhereWithAggregatesInput[]
    treatment_id?: IntWithAggregatesFilter<"Treatments"> | number
    patient_id?: IntWithAggregatesFilter<"Treatments"> | number
    doctor_id?: IntWithAggregatesFilter<"Treatments"> | number
    medication_id?: IntWithAggregatesFilter<"Treatments"> | number
    treatment_description?: StringWithAggregatesFilter<"Treatments"> | string
    treatment_date?: DateTimeWithAggregatesFilter<"Treatments"> | Date | string
  }

  export type InsuranceWhereInput = {
    AND?: InsuranceWhereInput | InsuranceWhereInput[]
    OR?: InsuranceWhereInput[]
    NOT?: InsuranceWhereInput | InsuranceWhereInput[]
    insurance_id?: IntFilter<"Insurance"> | number
    patient_id?: IntFilter<"Insurance"> | number
    provider_name?: StringFilter<"Insurance"> | string
    policy_number?: StringFilter<"Insurance"> | string
    coverage_amount?: FloatFilter<"Insurance"> | number
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
  }

  export type InsuranceOrderByWithRelationInput = {
    insurance_id?: SortOrder
    patient_id?: SortOrder
    provider_name?: SortOrder
    policy_number?: SortOrder
    coverage_amount?: SortOrder
    patient?: PatientsOrderByWithRelationInput
  }

  export type InsuranceWhereUniqueInput = Prisma.AtLeast<{
    insurance_id?: number
    AND?: InsuranceWhereInput | InsuranceWhereInput[]
    OR?: InsuranceWhereInput[]
    NOT?: InsuranceWhereInput | InsuranceWhereInput[]
    patient_id?: IntFilter<"Insurance"> | number
    provider_name?: StringFilter<"Insurance"> | string
    policy_number?: StringFilter<"Insurance"> | string
    coverage_amount?: FloatFilter<"Insurance"> | number
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
  }, "insurance_id">

  export type InsuranceOrderByWithAggregationInput = {
    insurance_id?: SortOrder
    patient_id?: SortOrder
    provider_name?: SortOrder
    policy_number?: SortOrder
    coverage_amount?: SortOrder
    _count?: InsuranceCountOrderByAggregateInput
    _avg?: InsuranceAvgOrderByAggregateInput
    _max?: InsuranceMaxOrderByAggregateInput
    _min?: InsuranceMinOrderByAggregateInput
    _sum?: InsuranceSumOrderByAggregateInput
  }

  export type InsuranceScalarWhereWithAggregatesInput = {
    AND?: InsuranceScalarWhereWithAggregatesInput | InsuranceScalarWhereWithAggregatesInput[]
    OR?: InsuranceScalarWhereWithAggregatesInput[]
    NOT?: InsuranceScalarWhereWithAggregatesInput | InsuranceScalarWhereWithAggregatesInput[]
    insurance_id?: IntWithAggregatesFilter<"Insurance"> | number
    patient_id?: IntWithAggregatesFilter<"Insurance"> | number
    provider_name?: StringWithAggregatesFilter<"Insurance"> | string
    policy_number?: StringWithAggregatesFilter<"Insurance"> | string
    coverage_amount?: FloatWithAggregatesFilter<"Insurance"> | number
  }

  export type LabTestsWhereInput = {
    AND?: LabTestsWhereInput | LabTestsWhereInput[]
    OR?: LabTestsWhereInput[]
    NOT?: LabTestsWhereInput | LabTestsWhereInput[]
    test_id?: IntFilter<"LabTests"> | number
    patient_id?: IntFilter<"LabTests"> | number
    test_name?: StringFilter<"LabTests"> | string
    test_result?: StringFilter<"LabTests"> | string
    test_date?: DateTimeFilter<"LabTests"> | Date | string
    doctor_id?: IntFilter<"LabTests"> | number
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
    doctor?: XOR<DoctorsRelationFilter, DoctorsWhereInput>
  }

  export type LabTestsOrderByWithRelationInput = {
    test_id?: SortOrder
    patient_id?: SortOrder
    test_name?: SortOrder
    test_result?: SortOrder
    test_date?: SortOrder
    doctor_id?: SortOrder
    patient?: PatientsOrderByWithRelationInput
    doctor?: DoctorsOrderByWithRelationInput
  }

  export type LabTestsWhereUniqueInput = Prisma.AtLeast<{
    test_id?: number
    AND?: LabTestsWhereInput | LabTestsWhereInput[]
    OR?: LabTestsWhereInput[]
    NOT?: LabTestsWhereInput | LabTestsWhereInput[]
    patient_id?: IntFilter<"LabTests"> | number
    test_name?: StringFilter<"LabTests"> | string
    test_result?: StringFilter<"LabTests"> | string
    test_date?: DateTimeFilter<"LabTests"> | Date | string
    doctor_id?: IntFilter<"LabTests"> | number
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
    doctor?: XOR<DoctorsRelationFilter, DoctorsWhereInput>
  }, "test_id">

  export type LabTestsOrderByWithAggregationInput = {
    test_id?: SortOrder
    patient_id?: SortOrder
    test_name?: SortOrder
    test_result?: SortOrder
    test_date?: SortOrder
    doctor_id?: SortOrder
    _count?: LabTestsCountOrderByAggregateInput
    _avg?: LabTestsAvgOrderByAggregateInput
    _max?: LabTestsMaxOrderByAggregateInput
    _min?: LabTestsMinOrderByAggregateInput
    _sum?: LabTestsSumOrderByAggregateInput
  }

  export type LabTestsScalarWhereWithAggregatesInput = {
    AND?: LabTestsScalarWhereWithAggregatesInput | LabTestsScalarWhereWithAggregatesInput[]
    OR?: LabTestsScalarWhereWithAggregatesInput[]
    NOT?: LabTestsScalarWhereWithAggregatesInput | LabTestsScalarWhereWithAggregatesInput[]
    test_id?: IntWithAggregatesFilter<"LabTests"> | number
    patient_id?: IntWithAggregatesFilter<"LabTests"> | number
    test_name?: StringWithAggregatesFilter<"LabTests"> | string
    test_result?: StringWithAggregatesFilter<"LabTests"> | string
    test_date?: DateTimeWithAggregatesFilter<"LabTests"> | Date | string
    doctor_id?: IntWithAggregatesFilter<"LabTests"> | number
  }

  export type BillsWhereInput = {
    AND?: BillsWhereInput | BillsWhereInput[]
    OR?: BillsWhereInput[]
    NOT?: BillsWhereInput | BillsWhereInput[]
    bill_id?: IntFilter<"Bills"> | number
    patient_id?: IntFilter<"Bills"> | number
    total_amount?: FloatFilter<"Bills"> | number
    billing_date?: DateTimeFilter<"Bills"> | Date | string
    insurance_covered?: BoolFilter<"Bills"> | boolean
    amount_paid?: FloatFilter<"Bills"> | number
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
  }

  export type BillsOrderByWithRelationInput = {
    bill_id?: SortOrder
    patient_id?: SortOrder
    total_amount?: SortOrder
    billing_date?: SortOrder
    insurance_covered?: SortOrder
    amount_paid?: SortOrder
    patient?: PatientsOrderByWithRelationInput
  }

  export type BillsWhereUniqueInput = Prisma.AtLeast<{
    bill_id?: number
    AND?: BillsWhereInput | BillsWhereInput[]
    OR?: BillsWhereInput[]
    NOT?: BillsWhereInput | BillsWhereInput[]
    patient_id?: IntFilter<"Bills"> | number
    total_amount?: FloatFilter<"Bills"> | number
    billing_date?: DateTimeFilter<"Bills"> | Date | string
    insurance_covered?: BoolFilter<"Bills"> | boolean
    amount_paid?: FloatFilter<"Bills"> | number
    patient?: XOR<PatientsRelationFilter, PatientsWhereInput>
  }, "bill_id">

  export type BillsOrderByWithAggregationInput = {
    bill_id?: SortOrder
    patient_id?: SortOrder
    total_amount?: SortOrder
    billing_date?: SortOrder
    insurance_covered?: SortOrder
    amount_paid?: SortOrder
    _count?: BillsCountOrderByAggregateInput
    _avg?: BillsAvgOrderByAggregateInput
    _max?: BillsMaxOrderByAggregateInput
    _min?: BillsMinOrderByAggregateInput
    _sum?: BillsSumOrderByAggregateInput
  }

  export type BillsScalarWhereWithAggregatesInput = {
    AND?: BillsScalarWhereWithAggregatesInput | BillsScalarWhereWithAggregatesInput[]
    OR?: BillsScalarWhereWithAggregatesInput[]
    NOT?: BillsScalarWhereWithAggregatesInput | BillsScalarWhereWithAggregatesInput[]
    bill_id?: IntWithAggregatesFilter<"Bills"> | number
    patient_id?: IntWithAggregatesFilter<"Bills"> | number
    total_amount?: FloatWithAggregatesFilter<"Bills"> | number
    billing_date?: DateTimeWithAggregatesFilter<"Bills"> | Date | string
    insurance_covered?: BoolWithAggregatesFilter<"Bills"> | boolean
    amount_paid?: FloatWithAggregatesFilter<"Bills"> | number
  }

  export type PatientsCreateInput = {
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsCreateNestedManyWithoutPatientInput
    insurance?: InsuranceCreateNestedManyWithoutPatientInput
    labTests?: LabTestsCreateNestedManyWithoutPatientInput
    bills?: BillsCreateNestedManyWithoutPatientInput
  }

  export type PatientsUncheckedCreateInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutPatientInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPatientInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutPatientInput
    bills?: BillsUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientsUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUpdateManyWithoutPatientNestedInput
    bills?: BillsUpdateManyWithoutPatientNestedInput
  }

  export type PatientsUncheckedUpdateInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUncheckedUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutPatientNestedInput
    bills?: BillsUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientsCreateManyInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
  }

  export type PatientsUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type PatientsUncheckedUpdateManyInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorsCreateInput = {
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department: DepartmentsCreateNestedOneWithoutDoctorsInput
    appointments?: AppointmentsCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsUncheckedCreateInput = {
    doctor_id?: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department_id: number
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department?: DepartmentsUpdateOneRequiredWithoutDoctorsNestedInput
    appointments?: AppointmentsUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorsUncheckedUpdateInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    appointments?: AppointmentsUncheckedUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorsCreateManyInput = {
    doctor_id?: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department_id: number
  }

  export type DoctorsUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
  }

  export type DoctorsUncheckedUpdateManyInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
  }

  export type DepartmentsCreateInput = {
    department_name: string
    doctors?: DoctorsCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentsUncheckedCreateInput = {
    department_id?: number
    department_name: string
    doctors?: DoctorsUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentsUpdateInput = {
    department_name?: StringFieldUpdateOperationsInput | string
    doctors?: DoctorsUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentsUncheckedUpdateInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    department_name?: StringFieldUpdateOperationsInput | string
    doctors?: DoctorsUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentsCreateManyInput = {
    department_id?: number
    department_name: string
  }

  export type DepartmentsUpdateManyMutationInput = {
    department_name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentsUncheckedUpdateManyInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    department_name?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentsCreateInput = {
    appointment_date: Date | string
    reason_for_visit: string
    patient: PatientsCreateNestedOneWithoutAppointmentsInput
    doctor: DoctorsCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentsUncheckedCreateInput = {
    appointment_id?: number
    patient_id: number
    doctor_id: number
    appointment_date: Date | string
    reason_for_visit: string
  }

  export type AppointmentsUpdateInput = {
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
    patient?: PatientsUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: DoctorsUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentsUncheckedUpdateInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentsCreateManyInput = {
    appointment_id?: number
    patient_id: number
    doctor_id: number
    appointment_date: Date | string
    reason_for_visit: string
  }

  export type AppointmentsUpdateManyMutationInput = {
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentsUncheckedUpdateManyInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
  }

  export type RoomsCreateInput = {
    room_number: string
    room_type: string
    availability_status: boolean
  }

  export type RoomsUncheckedCreateInput = {
    room_id?: number
    room_number: string
    room_type: string
    availability_status: boolean
  }

  export type RoomsUpdateInput = {
    room_number?: StringFieldUpdateOperationsInput | string
    room_type?: StringFieldUpdateOperationsInput | string
    availability_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomsUncheckedUpdateInput = {
    room_id?: IntFieldUpdateOperationsInput | number
    room_number?: StringFieldUpdateOperationsInput | string
    room_type?: StringFieldUpdateOperationsInput | string
    availability_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomsCreateManyInput = {
    room_id?: number
    room_number: string
    room_type: string
    availability_status: boolean
  }

  export type RoomsUpdateManyMutationInput = {
    room_number?: StringFieldUpdateOperationsInput | string
    room_type?: StringFieldUpdateOperationsInput | string
    availability_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RoomsUncheckedUpdateManyInput = {
    room_id?: IntFieldUpdateOperationsInput | number
    room_number?: StringFieldUpdateOperationsInput | string
    room_type?: StringFieldUpdateOperationsInput | string
    availability_status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalHistoryCreateInput = {
    treatment: string
    treatment_date: Date | string
    patient: PatientsCreateNestedOneWithoutMedicalHistoryInput
  }

  export type MedicalHistoryUncheckedCreateInput = {
    history_id?: number
    patient_id: number
    treatment: string
    treatment_date: Date | string
  }

  export type MedicalHistoryUpdateInput = {
    treatment?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientsUpdateOneRequiredWithoutMedicalHistoryNestedInput
  }

  export type MedicalHistoryUncheckedUpdateInput = {
    history_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    treatment?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalHistoryCreateManyInput = {
    history_id?: number
    patient_id: number
    treatment: string
    treatment_date: Date | string
  }

  export type MedicalHistoryUpdateManyMutationInput = {
    treatment?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalHistoryUncheckedUpdateManyInput = {
    history_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    treatment?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisCreateInput = {
    diagnosis_description: string
    diagnosis_date: Date | string
    patient: PatientsCreateNestedOneWithoutDiagnosisInput
    doctor: DoctorsCreateNestedOneWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateInput = {
    diagnosis_id?: number
    patient_id: number
    doctor_id: number
    diagnosis_description: string
    diagnosis_date: Date | string
  }

  export type DiagnosisUpdateInput = {
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientsUpdateOneRequiredWithoutDiagnosisNestedInput
    doctor?: DoctorsUpdateOneRequiredWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateInput = {
    diagnosis_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisCreateManyInput = {
    diagnosis_id?: number
    patient_id: number
    doctor_id: number
    diagnosis_description: string
    diagnosis_date: Date | string
  }

  export type DiagnosisUpdateManyMutationInput = {
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyInput = {
    diagnosis_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationsCreateInput = {
    medication_name: string
    dosage: string
    side_effects: string
    treatments?: TreatmentsCreateNestedManyWithoutMedicationInput
  }

  export type MedicationsUncheckedCreateInput = {
    medication_id?: number
    medication_name: string
    dosage: string
    side_effects: string
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationsUpdateInput = {
    medication_name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    side_effects?: StringFieldUpdateOperationsInput | string
    treatments?: TreatmentsUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationsUncheckedUpdateInput = {
    medication_id?: IntFieldUpdateOperationsInput | number
    medication_name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    side_effects?: StringFieldUpdateOperationsInput | string
    treatments?: TreatmentsUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationsCreateManyInput = {
    medication_id?: number
    medication_name: string
    dosage: string
    side_effects: string
  }

  export type MedicationsUpdateManyMutationInput = {
    medication_name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    side_effects?: StringFieldUpdateOperationsInput | string
  }

  export type MedicationsUncheckedUpdateManyInput = {
    medication_id?: IntFieldUpdateOperationsInput | number
    medication_name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    side_effects?: StringFieldUpdateOperationsInput | string
  }

  export type TreatmentsCreateInput = {
    treatment_description: string
    treatment_date: Date | string
    patient: PatientsCreateNestedOneWithoutTreatmentsInput
    doctor: DoctorsCreateNestedOneWithoutTreatmentsInput
    medication: MedicationsCreateNestedOneWithoutTreatmentsInput
  }

  export type TreatmentsUncheckedCreateInput = {
    treatment_id?: number
    patient_id: number
    doctor_id: number
    medication_id: number
    treatment_description: string
    treatment_date: Date | string
  }

  export type TreatmentsUpdateInput = {
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientsUpdateOneRequiredWithoutTreatmentsNestedInput
    doctor?: DoctorsUpdateOneRequiredWithoutTreatmentsNestedInput
    medication?: MedicationsUpdateOneRequiredWithoutTreatmentsNestedInput
  }

  export type TreatmentsUncheckedUpdateInput = {
    treatment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    medication_id?: IntFieldUpdateOperationsInput | number
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentsCreateManyInput = {
    treatment_id?: number
    patient_id: number
    doctor_id: number
    medication_id: number
    treatment_description: string
    treatment_date: Date | string
  }

  export type TreatmentsUpdateManyMutationInput = {
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentsUncheckedUpdateManyInput = {
    treatment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    medication_id?: IntFieldUpdateOperationsInput | number
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceCreateInput = {
    provider_name: string
    policy_number: string
    coverage_amount: number
    patient: PatientsCreateNestedOneWithoutInsuranceInput
  }

  export type InsuranceUncheckedCreateInput = {
    insurance_id?: number
    patient_id: number
    provider_name: string
    policy_number: string
    coverage_amount: number
  }

  export type InsuranceUpdateInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    policy_number?: StringFieldUpdateOperationsInput | string
    coverage_amount?: FloatFieldUpdateOperationsInput | number
    patient?: PatientsUpdateOneRequiredWithoutInsuranceNestedInput
  }

  export type InsuranceUncheckedUpdateInput = {
    insurance_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    policy_number?: StringFieldUpdateOperationsInput | string
    coverage_amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InsuranceCreateManyInput = {
    insurance_id?: number
    patient_id: number
    provider_name: string
    policy_number: string
    coverage_amount: number
  }

  export type InsuranceUpdateManyMutationInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    policy_number?: StringFieldUpdateOperationsInput | string
    coverage_amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InsuranceUncheckedUpdateManyInput = {
    insurance_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    policy_number?: StringFieldUpdateOperationsInput | string
    coverage_amount?: FloatFieldUpdateOperationsInput | number
  }

  export type LabTestsCreateInput = {
    test_name: string
    test_result: string
    test_date: Date | string
    patient: PatientsCreateNestedOneWithoutLabTestsInput
    doctor: DoctorsCreateNestedOneWithoutLabTestsInput
  }

  export type LabTestsUncheckedCreateInput = {
    test_id?: number
    patient_id: number
    test_name: string
    test_result: string
    test_date: Date | string
    doctor_id: number
  }

  export type LabTestsUpdateInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientsUpdateOneRequiredWithoutLabTestsNestedInput
    doctor?: DoctorsUpdateOneRequiredWithoutLabTestsNestedInput
  }

  export type LabTestsUncheckedUpdateInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor_id?: IntFieldUpdateOperationsInput | number
  }

  export type LabTestsCreateManyInput = {
    test_id?: number
    patient_id: number
    test_name: string
    test_result: string
    test_date: Date | string
    doctor_id: number
  }

  export type LabTestsUpdateManyMutationInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestsUncheckedUpdateManyInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor_id?: IntFieldUpdateOperationsInput | number
  }

  export type BillsCreateInput = {
    total_amount: number
    billing_date: Date | string
    insurance_covered: boolean
    amount_paid: number
    patient: PatientsCreateNestedOneWithoutBillsInput
  }

  export type BillsUncheckedCreateInput = {
    bill_id?: number
    patient_id: number
    total_amount: number
    billing_date: Date | string
    insurance_covered: boolean
    amount_paid: number
  }

  export type BillsUpdateInput = {
    total_amount?: FloatFieldUpdateOperationsInput | number
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance_covered?: BoolFieldUpdateOperationsInput | boolean
    amount_paid?: FloatFieldUpdateOperationsInput | number
    patient?: PatientsUpdateOneRequiredWithoutBillsNestedInput
  }

  export type BillsUncheckedUpdateInput = {
    bill_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance_covered?: BoolFieldUpdateOperationsInput | boolean
    amount_paid?: FloatFieldUpdateOperationsInput | number
  }

  export type BillsCreateManyInput = {
    bill_id?: number
    patient_id: number
    total_amount: number
    billing_date: Date | string
    insurance_covered: boolean
    amount_paid: number
  }

  export type BillsUpdateManyMutationInput = {
    total_amount?: FloatFieldUpdateOperationsInput | number
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance_covered?: BoolFieldUpdateOperationsInput | boolean
    amount_paid?: FloatFieldUpdateOperationsInput | number
  }

  export type BillsUncheckedUpdateManyInput = {
    bill_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance_covered?: BoolFieldUpdateOperationsInput | boolean
    amount_paid?: FloatFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AppointmentsListRelationFilter = {
    every?: AppointmentsWhereInput
    some?: AppointmentsWhereInput
    none?: AppointmentsWhereInput
  }

  export type MedicalHistoryListRelationFilter = {
    every?: MedicalHistoryWhereInput
    some?: MedicalHistoryWhereInput
    none?: MedicalHistoryWhereInput
  }

  export type DiagnosisListRelationFilter = {
    every?: DiagnosisWhereInput
    some?: DiagnosisWhereInput
    none?: DiagnosisWhereInput
  }

  export type TreatmentsListRelationFilter = {
    every?: TreatmentsWhereInput
    some?: TreatmentsWhereInput
    none?: TreatmentsWhereInput
  }

  export type InsuranceListRelationFilter = {
    every?: InsuranceWhereInput
    some?: InsuranceWhereInput
    none?: InsuranceWhereInput
  }

  export type LabTestsListRelationFilter = {
    every?: LabTestsWhereInput
    some?: LabTestsWhereInput
    none?: LabTestsWhereInput
  }

  export type BillsListRelationFilter = {
    every?: BillsWhereInput
    some?: BillsWhereInput
    none?: BillsWhereInput
  }

  export type AppointmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiagnosisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TreatmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsuranceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabTestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientsCountOrderByAggregateInput = {
    patient_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    contact_number?: SortOrder
    address?: SortOrder
  }

  export type PatientsAvgOrderByAggregateInput = {
    patient_id?: SortOrder
  }

  export type PatientsMaxOrderByAggregateInput = {
    patient_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    contact_number?: SortOrder
    address?: SortOrder
  }

  export type PatientsMinOrderByAggregateInput = {
    patient_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    date_of_birth?: SortOrder
    gender?: SortOrder
    contact_number?: SortOrder
    address?: SortOrder
  }

  export type PatientsSumOrderByAggregateInput = {
    patient_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DepartmentsRelationFilter = {
    is?: DepartmentsWhereInput
    isNot?: DepartmentsWhereInput
  }

  export type DoctorsCountOrderByAggregateInput = {
    doctor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    specialty?: SortOrder
    contact_number?: SortOrder
    department_id?: SortOrder
  }

  export type DoctorsAvgOrderByAggregateInput = {
    doctor_id?: SortOrder
    department_id?: SortOrder
  }

  export type DoctorsMaxOrderByAggregateInput = {
    doctor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    specialty?: SortOrder
    contact_number?: SortOrder
    department_id?: SortOrder
  }

  export type DoctorsMinOrderByAggregateInput = {
    doctor_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    specialty?: SortOrder
    contact_number?: SortOrder
    department_id?: SortOrder
  }

  export type DoctorsSumOrderByAggregateInput = {
    doctor_id?: SortOrder
    department_id?: SortOrder
  }

  export type DoctorsListRelationFilter = {
    every?: DoctorsWhereInput
    some?: DoctorsWhereInput
    none?: DoctorsWhereInput
  }

  export type DoctorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentsCountOrderByAggregateInput = {
    department_id?: SortOrder
    department_name?: SortOrder
  }

  export type DepartmentsAvgOrderByAggregateInput = {
    department_id?: SortOrder
  }

  export type DepartmentsMaxOrderByAggregateInput = {
    department_id?: SortOrder
    department_name?: SortOrder
  }

  export type DepartmentsMinOrderByAggregateInput = {
    department_id?: SortOrder
    department_name?: SortOrder
  }

  export type DepartmentsSumOrderByAggregateInput = {
    department_id?: SortOrder
  }

  export type PatientsRelationFilter = {
    is?: PatientsWhereInput
    isNot?: PatientsWhereInput
  }

  export type DoctorsRelationFilter = {
    is?: DoctorsWhereInput
    isNot?: DoctorsWhereInput
  }

  export type AppointmentsCountOrderByAggregateInput = {
    appointment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointment_date?: SortOrder
    reason_for_visit?: SortOrder
  }

  export type AppointmentsAvgOrderByAggregateInput = {
    appointment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
  }

  export type AppointmentsMaxOrderByAggregateInput = {
    appointment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointment_date?: SortOrder
    reason_for_visit?: SortOrder
  }

  export type AppointmentsMinOrderByAggregateInput = {
    appointment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    appointment_date?: SortOrder
    reason_for_visit?: SortOrder
  }

  export type AppointmentsSumOrderByAggregateInput = {
    appointment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RoomsCountOrderByAggregateInput = {
    room_id?: SortOrder
    room_number?: SortOrder
    room_type?: SortOrder
    availability_status?: SortOrder
  }

  export type RoomsAvgOrderByAggregateInput = {
    room_id?: SortOrder
  }

  export type RoomsMaxOrderByAggregateInput = {
    room_id?: SortOrder
    room_number?: SortOrder
    room_type?: SortOrder
    availability_status?: SortOrder
  }

  export type RoomsMinOrderByAggregateInput = {
    room_id?: SortOrder
    room_number?: SortOrder
    room_type?: SortOrder
    availability_status?: SortOrder
  }

  export type RoomsSumOrderByAggregateInput = {
    room_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MedicalHistoryCountOrderByAggregateInput = {
    history_id?: SortOrder
    patient_id?: SortOrder
    treatment?: SortOrder
    treatment_date?: SortOrder
  }

  export type MedicalHistoryAvgOrderByAggregateInput = {
    history_id?: SortOrder
    patient_id?: SortOrder
  }

  export type MedicalHistoryMaxOrderByAggregateInput = {
    history_id?: SortOrder
    patient_id?: SortOrder
    treatment?: SortOrder
    treatment_date?: SortOrder
  }

  export type MedicalHistoryMinOrderByAggregateInput = {
    history_id?: SortOrder
    patient_id?: SortOrder
    treatment?: SortOrder
    treatment_date?: SortOrder
  }

  export type MedicalHistorySumOrderByAggregateInput = {
    history_id?: SortOrder
    patient_id?: SortOrder
  }

  export type DiagnosisCountOrderByAggregateInput = {
    diagnosis_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    diagnosis_description?: SortOrder
    diagnosis_date?: SortOrder
  }

  export type DiagnosisAvgOrderByAggregateInput = {
    diagnosis_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
  }

  export type DiagnosisMaxOrderByAggregateInput = {
    diagnosis_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    diagnosis_description?: SortOrder
    diagnosis_date?: SortOrder
  }

  export type DiagnosisMinOrderByAggregateInput = {
    diagnosis_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    diagnosis_description?: SortOrder
    diagnosis_date?: SortOrder
  }

  export type DiagnosisSumOrderByAggregateInput = {
    diagnosis_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
  }

  export type MedicationsCountOrderByAggregateInput = {
    medication_id?: SortOrder
    medication_name?: SortOrder
    dosage?: SortOrder
    side_effects?: SortOrder
  }

  export type MedicationsAvgOrderByAggregateInput = {
    medication_id?: SortOrder
  }

  export type MedicationsMaxOrderByAggregateInput = {
    medication_id?: SortOrder
    medication_name?: SortOrder
    dosage?: SortOrder
    side_effects?: SortOrder
  }

  export type MedicationsMinOrderByAggregateInput = {
    medication_id?: SortOrder
    medication_name?: SortOrder
    dosage?: SortOrder
    side_effects?: SortOrder
  }

  export type MedicationsSumOrderByAggregateInput = {
    medication_id?: SortOrder
  }

  export type MedicationsRelationFilter = {
    is?: MedicationsWhereInput
    isNot?: MedicationsWhereInput
  }

  export type TreatmentsCountOrderByAggregateInput = {
    treatment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    medication_id?: SortOrder
    treatment_description?: SortOrder
    treatment_date?: SortOrder
  }

  export type TreatmentsAvgOrderByAggregateInput = {
    treatment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    medication_id?: SortOrder
  }

  export type TreatmentsMaxOrderByAggregateInput = {
    treatment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    medication_id?: SortOrder
    treatment_description?: SortOrder
    treatment_date?: SortOrder
  }

  export type TreatmentsMinOrderByAggregateInput = {
    treatment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    medication_id?: SortOrder
    treatment_description?: SortOrder
    treatment_date?: SortOrder
  }

  export type TreatmentsSumOrderByAggregateInput = {
    treatment_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
    medication_id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InsuranceCountOrderByAggregateInput = {
    insurance_id?: SortOrder
    patient_id?: SortOrder
    provider_name?: SortOrder
    policy_number?: SortOrder
    coverage_amount?: SortOrder
  }

  export type InsuranceAvgOrderByAggregateInput = {
    insurance_id?: SortOrder
    patient_id?: SortOrder
    coverage_amount?: SortOrder
  }

  export type InsuranceMaxOrderByAggregateInput = {
    insurance_id?: SortOrder
    patient_id?: SortOrder
    provider_name?: SortOrder
    policy_number?: SortOrder
    coverage_amount?: SortOrder
  }

  export type InsuranceMinOrderByAggregateInput = {
    insurance_id?: SortOrder
    patient_id?: SortOrder
    provider_name?: SortOrder
    policy_number?: SortOrder
    coverage_amount?: SortOrder
  }

  export type InsuranceSumOrderByAggregateInput = {
    insurance_id?: SortOrder
    patient_id?: SortOrder
    coverage_amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LabTestsCountOrderByAggregateInput = {
    test_id?: SortOrder
    patient_id?: SortOrder
    test_name?: SortOrder
    test_result?: SortOrder
    test_date?: SortOrder
    doctor_id?: SortOrder
  }

  export type LabTestsAvgOrderByAggregateInput = {
    test_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
  }

  export type LabTestsMaxOrderByAggregateInput = {
    test_id?: SortOrder
    patient_id?: SortOrder
    test_name?: SortOrder
    test_result?: SortOrder
    test_date?: SortOrder
    doctor_id?: SortOrder
  }

  export type LabTestsMinOrderByAggregateInput = {
    test_id?: SortOrder
    patient_id?: SortOrder
    test_name?: SortOrder
    test_result?: SortOrder
    test_date?: SortOrder
    doctor_id?: SortOrder
  }

  export type LabTestsSumOrderByAggregateInput = {
    test_id?: SortOrder
    patient_id?: SortOrder
    doctor_id?: SortOrder
  }

  export type BillsCountOrderByAggregateInput = {
    bill_id?: SortOrder
    patient_id?: SortOrder
    total_amount?: SortOrder
    billing_date?: SortOrder
    insurance_covered?: SortOrder
    amount_paid?: SortOrder
  }

  export type BillsAvgOrderByAggregateInput = {
    bill_id?: SortOrder
    patient_id?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
  }

  export type BillsMaxOrderByAggregateInput = {
    bill_id?: SortOrder
    patient_id?: SortOrder
    total_amount?: SortOrder
    billing_date?: SortOrder
    insurance_covered?: SortOrder
    amount_paid?: SortOrder
  }

  export type BillsMinOrderByAggregateInput = {
    bill_id?: SortOrder
    patient_id?: SortOrder
    total_amount?: SortOrder
    billing_date?: SortOrder
    insurance_covered?: SortOrder
    amount_paid?: SortOrder
  }

  export type BillsSumOrderByAggregateInput = {
    bill_id?: SortOrder
    patient_id?: SortOrder
    total_amount?: SortOrder
    amount_paid?: SortOrder
  }

  export type AppointmentsCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentsCreateWithoutPatientInput, AppointmentsUncheckedCreateWithoutPatientInput> | AppointmentsCreateWithoutPatientInput[] | AppointmentsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentsCreateOrConnectWithoutPatientInput | AppointmentsCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentsCreateManyPatientInputEnvelope
    connect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
  }

  export type MedicalHistoryCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput> | MedicalHistoryCreateWithoutPatientInput[] | MedicalHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalHistoryCreateOrConnectWithoutPatientInput | MedicalHistoryCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalHistoryCreateManyPatientInputEnvelope
    connect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
  }

  export type DiagnosisCreateNestedManyWithoutPatientInput = {
    create?: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput> | DiagnosisCreateWithoutPatientInput[] | DiagnosisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutPatientInput | DiagnosisCreateOrConnectWithoutPatientInput[]
    createMany?: DiagnosisCreateManyPatientInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type TreatmentsCreateNestedManyWithoutPatientInput = {
    create?: XOR<TreatmentsCreateWithoutPatientInput, TreatmentsUncheckedCreateWithoutPatientInput> | TreatmentsCreateWithoutPatientInput[] | TreatmentsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutPatientInput | TreatmentsCreateOrConnectWithoutPatientInput[]
    createMany?: TreatmentsCreateManyPatientInputEnvelope
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
  }

  export type InsuranceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InsuranceCreateWithoutPatientInput, InsuranceUncheckedCreateWithoutPatientInput> | InsuranceCreateWithoutPatientInput[] | InsuranceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InsuranceCreateOrConnectWithoutPatientInput | InsuranceCreateOrConnectWithoutPatientInput[]
    createMany?: InsuranceCreateManyPatientInputEnvelope
    connect?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
  }

  export type LabTestsCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabTestsCreateWithoutPatientInput, LabTestsUncheckedCreateWithoutPatientInput> | LabTestsCreateWithoutPatientInput[] | LabTestsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabTestsCreateOrConnectWithoutPatientInput | LabTestsCreateOrConnectWithoutPatientInput[]
    createMany?: LabTestsCreateManyPatientInputEnvelope
    connect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
  }

  export type BillsCreateNestedManyWithoutPatientInput = {
    create?: XOR<BillsCreateWithoutPatientInput, BillsUncheckedCreateWithoutPatientInput> | BillsCreateWithoutPatientInput[] | BillsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutPatientInput | BillsCreateOrConnectWithoutPatientInput[]
    createMany?: BillsCreateManyPatientInputEnvelope
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
  }

  export type AppointmentsUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentsCreateWithoutPatientInput, AppointmentsUncheckedCreateWithoutPatientInput> | AppointmentsCreateWithoutPatientInput[] | AppointmentsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentsCreateOrConnectWithoutPatientInput | AppointmentsCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentsCreateManyPatientInputEnvelope
    connect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
  }

  export type MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput> | MedicalHistoryCreateWithoutPatientInput[] | MedicalHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalHistoryCreateOrConnectWithoutPatientInput | MedicalHistoryCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalHistoryCreateManyPatientInputEnvelope
    connect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
  }

  export type DiagnosisUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput> | DiagnosisCreateWithoutPatientInput[] | DiagnosisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutPatientInput | DiagnosisCreateOrConnectWithoutPatientInput[]
    createMany?: DiagnosisCreateManyPatientInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type TreatmentsUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<TreatmentsCreateWithoutPatientInput, TreatmentsUncheckedCreateWithoutPatientInput> | TreatmentsCreateWithoutPatientInput[] | TreatmentsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutPatientInput | TreatmentsCreateOrConnectWithoutPatientInput[]
    createMany?: TreatmentsCreateManyPatientInputEnvelope
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
  }

  export type InsuranceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InsuranceCreateWithoutPatientInput, InsuranceUncheckedCreateWithoutPatientInput> | InsuranceCreateWithoutPatientInput[] | InsuranceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InsuranceCreateOrConnectWithoutPatientInput | InsuranceCreateOrConnectWithoutPatientInput[]
    createMany?: InsuranceCreateManyPatientInputEnvelope
    connect?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
  }

  export type LabTestsUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<LabTestsCreateWithoutPatientInput, LabTestsUncheckedCreateWithoutPatientInput> | LabTestsCreateWithoutPatientInput[] | LabTestsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabTestsCreateOrConnectWithoutPatientInput | LabTestsCreateOrConnectWithoutPatientInput[]
    createMany?: LabTestsCreateManyPatientInputEnvelope
    connect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
  }

  export type BillsUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<BillsCreateWithoutPatientInput, BillsUncheckedCreateWithoutPatientInput> | BillsCreateWithoutPatientInput[] | BillsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutPatientInput | BillsCreateOrConnectWithoutPatientInput[]
    createMany?: BillsCreateManyPatientInputEnvelope
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AppointmentsUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentsCreateWithoutPatientInput, AppointmentsUncheckedCreateWithoutPatientInput> | AppointmentsCreateWithoutPatientInput[] | AppointmentsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentsCreateOrConnectWithoutPatientInput | AppointmentsCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentsUpsertWithWhereUniqueWithoutPatientInput | AppointmentsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentsCreateManyPatientInputEnvelope
    set?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    disconnect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    delete?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    connect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    update?: AppointmentsUpdateWithWhereUniqueWithoutPatientInput | AppointmentsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentsUpdateManyWithWhereWithoutPatientInput | AppointmentsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentsScalarWhereInput | AppointmentsScalarWhereInput[]
  }

  export type MedicalHistoryUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput> | MedicalHistoryCreateWithoutPatientInput[] | MedicalHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalHistoryCreateOrConnectWithoutPatientInput | MedicalHistoryCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput | MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalHistoryCreateManyPatientInputEnvelope
    set?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    disconnect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    delete?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    connect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    update?: MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput | MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalHistoryUpdateManyWithWhereWithoutPatientInput | MedicalHistoryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalHistoryScalarWhereInput | MedicalHistoryScalarWhereInput[]
  }

  export type DiagnosisUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput> | DiagnosisCreateWithoutPatientInput[] | DiagnosisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutPatientInput | DiagnosisCreateOrConnectWithoutPatientInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutPatientInput | DiagnosisUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DiagnosisCreateManyPatientInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutPatientInput | DiagnosisUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutPatientInput | DiagnosisUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type TreatmentsUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TreatmentsCreateWithoutPatientInput, TreatmentsUncheckedCreateWithoutPatientInput> | TreatmentsCreateWithoutPatientInput[] | TreatmentsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutPatientInput | TreatmentsCreateOrConnectWithoutPatientInput[]
    upsert?: TreatmentsUpsertWithWhereUniqueWithoutPatientInput | TreatmentsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TreatmentsCreateManyPatientInputEnvelope
    set?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    disconnect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    delete?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    update?: TreatmentsUpdateWithWhereUniqueWithoutPatientInput | TreatmentsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TreatmentsUpdateManyWithWhereWithoutPatientInput | TreatmentsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TreatmentsScalarWhereInput | TreatmentsScalarWhereInput[]
  }

  export type InsuranceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InsuranceCreateWithoutPatientInput, InsuranceUncheckedCreateWithoutPatientInput> | InsuranceCreateWithoutPatientInput[] | InsuranceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InsuranceCreateOrConnectWithoutPatientInput | InsuranceCreateOrConnectWithoutPatientInput[]
    upsert?: InsuranceUpsertWithWhereUniqueWithoutPatientInput | InsuranceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InsuranceCreateManyPatientInputEnvelope
    set?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
    disconnect?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
    delete?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
    connect?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
    update?: InsuranceUpdateWithWhereUniqueWithoutPatientInput | InsuranceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InsuranceUpdateManyWithWhereWithoutPatientInput | InsuranceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InsuranceScalarWhereInput | InsuranceScalarWhereInput[]
  }

  export type LabTestsUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabTestsCreateWithoutPatientInput, LabTestsUncheckedCreateWithoutPatientInput> | LabTestsCreateWithoutPatientInput[] | LabTestsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabTestsCreateOrConnectWithoutPatientInput | LabTestsCreateOrConnectWithoutPatientInput[]
    upsert?: LabTestsUpsertWithWhereUniqueWithoutPatientInput | LabTestsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabTestsCreateManyPatientInputEnvelope
    set?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    disconnect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    delete?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    connect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    update?: LabTestsUpdateWithWhereUniqueWithoutPatientInput | LabTestsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabTestsUpdateManyWithWhereWithoutPatientInput | LabTestsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabTestsScalarWhereInput | LabTestsScalarWhereInput[]
  }

  export type BillsUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BillsCreateWithoutPatientInput, BillsUncheckedCreateWithoutPatientInput> | BillsCreateWithoutPatientInput[] | BillsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutPatientInput | BillsCreateOrConnectWithoutPatientInput[]
    upsert?: BillsUpsertWithWhereUniqueWithoutPatientInput | BillsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BillsCreateManyPatientInputEnvelope
    set?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    disconnect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    delete?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    update?: BillsUpdateWithWhereUniqueWithoutPatientInput | BillsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BillsUpdateManyWithWhereWithoutPatientInput | BillsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BillsScalarWhereInput | BillsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppointmentsUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentsCreateWithoutPatientInput, AppointmentsUncheckedCreateWithoutPatientInput> | AppointmentsCreateWithoutPatientInput[] | AppointmentsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentsCreateOrConnectWithoutPatientInput | AppointmentsCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentsUpsertWithWhereUniqueWithoutPatientInput | AppointmentsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentsCreateManyPatientInputEnvelope
    set?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    disconnect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    delete?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    connect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    update?: AppointmentsUpdateWithWhereUniqueWithoutPatientInput | AppointmentsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentsUpdateManyWithWhereWithoutPatientInput | AppointmentsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentsScalarWhereInput | AppointmentsScalarWhereInput[]
  }

  export type MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput> | MedicalHistoryCreateWithoutPatientInput[] | MedicalHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalHistoryCreateOrConnectWithoutPatientInput | MedicalHistoryCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput | MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalHistoryCreateManyPatientInputEnvelope
    set?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    disconnect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    delete?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    connect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    update?: MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput | MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalHistoryUpdateManyWithWhereWithoutPatientInput | MedicalHistoryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalHistoryScalarWhereInput | MedicalHistoryScalarWhereInput[]
  }

  export type DiagnosisUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput> | DiagnosisCreateWithoutPatientInput[] | DiagnosisUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutPatientInput | DiagnosisCreateOrConnectWithoutPatientInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutPatientInput | DiagnosisUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: DiagnosisCreateManyPatientInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutPatientInput | DiagnosisUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutPatientInput | DiagnosisUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type TreatmentsUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<TreatmentsCreateWithoutPatientInput, TreatmentsUncheckedCreateWithoutPatientInput> | TreatmentsCreateWithoutPatientInput[] | TreatmentsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutPatientInput | TreatmentsCreateOrConnectWithoutPatientInput[]
    upsert?: TreatmentsUpsertWithWhereUniqueWithoutPatientInput | TreatmentsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: TreatmentsCreateManyPatientInputEnvelope
    set?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    disconnect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    delete?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    update?: TreatmentsUpdateWithWhereUniqueWithoutPatientInput | TreatmentsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: TreatmentsUpdateManyWithWhereWithoutPatientInput | TreatmentsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: TreatmentsScalarWhereInput | TreatmentsScalarWhereInput[]
  }

  export type InsuranceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InsuranceCreateWithoutPatientInput, InsuranceUncheckedCreateWithoutPatientInput> | InsuranceCreateWithoutPatientInput[] | InsuranceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InsuranceCreateOrConnectWithoutPatientInput | InsuranceCreateOrConnectWithoutPatientInput[]
    upsert?: InsuranceUpsertWithWhereUniqueWithoutPatientInput | InsuranceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InsuranceCreateManyPatientInputEnvelope
    set?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
    disconnect?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
    delete?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
    connect?: InsuranceWhereUniqueInput | InsuranceWhereUniqueInput[]
    update?: InsuranceUpdateWithWhereUniqueWithoutPatientInput | InsuranceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InsuranceUpdateManyWithWhereWithoutPatientInput | InsuranceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InsuranceScalarWhereInput | InsuranceScalarWhereInput[]
  }

  export type LabTestsUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<LabTestsCreateWithoutPatientInput, LabTestsUncheckedCreateWithoutPatientInput> | LabTestsCreateWithoutPatientInput[] | LabTestsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: LabTestsCreateOrConnectWithoutPatientInput | LabTestsCreateOrConnectWithoutPatientInput[]
    upsert?: LabTestsUpsertWithWhereUniqueWithoutPatientInput | LabTestsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: LabTestsCreateManyPatientInputEnvelope
    set?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    disconnect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    delete?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    connect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    update?: LabTestsUpdateWithWhereUniqueWithoutPatientInput | LabTestsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: LabTestsUpdateManyWithWhereWithoutPatientInput | LabTestsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: LabTestsScalarWhereInput | LabTestsScalarWhereInput[]
  }

  export type BillsUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<BillsCreateWithoutPatientInput, BillsUncheckedCreateWithoutPatientInput> | BillsCreateWithoutPatientInput[] | BillsUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: BillsCreateOrConnectWithoutPatientInput | BillsCreateOrConnectWithoutPatientInput[]
    upsert?: BillsUpsertWithWhereUniqueWithoutPatientInput | BillsUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: BillsCreateManyPatientInputEnvelope
    set?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    disconnect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    delete?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    connect?: BillsWhereUniqueInput | BillsWhereUniqueInput[]
    update?: BillsUpdateWithWhereUniqueWithoutPatientInput | BillsUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: BillsUpdateManyWithWhereWithoutPatientInput | BillsUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: BillsScalarWhereInput | BillsScalarWhereInput[]
  }

  export type DepartmentsCreateNestedOneWithoutDoctorsInput = {
    create?: XOR<DepartmentsCreateWithoutDoctorsInput, DepartmentsUncheckedCreateWithoutDoctorsInput>
    connectOrCreate?: DepartmentsCreateOrConnectWithoutDoctorsInput
    connect?: DepartmentsWhereUniqueInput
  }

  export type AppointmentsCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentsCreateWithoutDoctorInput, AppointmentsUncheckedCreateWithoutDoctorInput> | AppointmentsCreateWithoutDoctorInput[] | AppointmentsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentsCreateOrConnectWithoutDoctorInput | AppointmentsCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentsCreateManyDoctorInputEnvelope
    connect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
  }

  export type DiagnosisCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type TreatmentsCreateNestedManyWithoutDoctorInput = {
    create?: XOR<TreatmentsCreateWithoutDoctorInput, TreatmentsUncheckedCreateWithoutDoctorInput> | TreatmentsCreateWithoutDoctorInput[] | TreatmentsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutDoctorInput | TreatmentsCreateOrConnectWithoutDoctorInput[]
    createMany?: TreatmentsCreateManyDoctorInputEnvelope
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
  }

  export type LabTestsCreateNestedManyWithoutDoctorInput = {
    create?: XOR<LabTestsCreateWithoutDoctorInput, LabTestsUncheckedCreateWithoutDoctorInput> | LabTestsCreateWithoutDoctorInput[] | LabTestsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabTestsCreateOrConnectWithoutDoctorInput | LabTestsCreateOrConnectWithoutDoctorInput[]
    createMany?: LabTestsCreateManyDoctorInputEnvelope
    connect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
  }

  export type AppointmentsUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentsCreateWithoutDoctorInput, AppointmentsUncheckedCreateWithoutDoctorInput> | AppointmentsCreateWithoutDoctorInput[] | AppointmentsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentsCreateOrConnectWithoutDoctorInput | AppointmentsCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentsCreateManyDoctorInputEnvelope
    connect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
  }

  export type DiagnosisUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
  }

  export type TreatmentsUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<TreatmentsCreateWithoutDoctorInput, TreatmentsUncheckedCreateWithoutDoctorInput> | TreatmentsCreateWithoutDoctorInput[] | TreatmentsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutDoctorInput | TreatmentsCreateOrConnectWithoutDoctorInput[]
    createMany?: TreatmentsCreateManyDoctorInputEnvelope
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
  }

  export type LabTestsUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<LabTestsCreateWithoutDoctorInput, LabTestsUncheckedCreateWithoutDoctorInput> | LabTestsCreateWithoutDoctorInput[] | LabTestsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabTestsCreateOrConnectWithoutDoctorInput | LabTestsCreateOrConnectWithoutDoctorInput[]
    createMany?: LabTestsCreateManyDoctorInputEnvelope
    connect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
  }

  export type DepartmentsUpdateOneRequiredWithoutDoctorsNestedInput = {
    create?: XOR<DepartmentsCreateWithoutDoctorsInput, DepartmentsUncheckedCreateWithoutDoctorsInput>
    connectOrCreate?: DepartmentsCreateOrConnectWithoutDoctorsInput
    upsert?: DepartmentsUpsertWithoutDoctorsInput
    connect?: DepartmentsWhereUniqueInput
    update?: XOR<XOR<DepartmentsUpdateToOneWithWhereWithoutDoctorsInput, DepartmentsUpdateWithoutDoctorsInput>, DepartmentsUncheckedUpdateWithoutDoctorsInput>
  }

  export type AppointmentsUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentsCreateWithoutDoctorInput, AppointmentsUncheckedCreateWithoutDoctorInput> | AppointmentsCreateWithoutDoctorInput[] | AppointmentsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentsCreateOrConnectWithoutDoctorInput | AppointmentsCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentsUpsertWithWhereUniqueWithoutDoctorInput | AppointmentsUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentsCreateManyDoctorInputEnvelope
    set?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    disconnect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    delete?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    connect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    update?: AppointmentsUpdateWithWhereUniqueWithoutDoctorInput | AppointmentsUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentsUpdateManyWithWhereWithoutDoctorInput | AppointmentsUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentsScalarWhereInput | AppointmentsScalarWhereInput[]
  }

  export type DiagnosisUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutDoctorInput | DiagnosisUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutDoctorInput | DiagnosisUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutDoctorInput | DiagnosisUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type TreatmentsUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<TreatmentsCreateWithoutDoctorInput, TreatmentsUncheckedCreateWithoutDoctorInput> | TreatmentsCreateWithoutDoctorInput[] | TreatmentsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutDoctorInput | TreatmentsCreateOrConnectWithoutDoctorInput[]
    upsert?: TreatmentsUpsertWithWhereUniqueWithoutDoctorInput | TreatmentsUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: TreatmentsCreateManyDoctorInputEnvelope
    set?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    disconnect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    delete?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    update?: TreatmentsUpdateWithWhereUniqueWithoutDoctorInput | TreatmentsUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: TreatmentsUpdateManyWithWhereWithoutDoctorInput | TreatmentsUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: TreatmentsScalarWhereInput | TreatmentsScalarWhereInput[]
  }

  export type LabTestsUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<LabTestsCreateWithoutDoctorInput, LabTestsUncheckedCreateWithoutDoctorInput> | LabTestsCreateWithoutDoctorInput[] | LabTestsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabTestsCreateOrConnectWithoutDoctorInput | LabTestsCreateOrConnectWithoutDoctorInput[]
    upsert?: LabTestsUpsertWithWhereUniqueWithoutDoctorInput | LabTestsUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: LabTestsCreateManyDoctorInputEnvelope
    set?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    disconnect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    delete?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    connect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    update?: LabTestsUpdateWithWhereUniqueWithoutDoctorInput | LabTestsUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: LabTestsUpdateManyWithWhereWithoutDoctorInput | LabTestsUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: LabTestsScalarWhereInput | LabTestsScalarWhereInput[]
  }

  export type AppointmentsUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentsCreateWithoutDoctorInput, AppointmentsUncheckedCreateWithoutDoctorInput> | AppointmentsCreateWithoutDoctorInput[] | AppointmentsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentsCreateOrConnectWithoutDoctorInput | AppointmentsCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentsUpsertWithWhereUniqueWithoutDoctorInput | AppointmentsUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentsCreateManyDoctorInputEnvelope
    set?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    disconnect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    delete?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    connect?: AppointmentsWhereUniqueInput | AppointmentsWhereUniqueInput[]
    update?: AppointmentsUpdateWithWhereUniqueWithoutDoctorInput | AppointmentsUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentsUpdateManyWithWhereWithoutDoctorInput | AppointmentsUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentsScalarWhereInput | AppointmentsScalarWhereInput[]
  }

  export type DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput> | DiagnosisCreateWithoutDoctorInput[] | DiagnosisUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DiagnosisCreateOrConnectWithoutDoctorInput | DiagnosisCreateOrConnectWithoutDoctorInput[]
    upsert?: DiagnosisUpsertWithWhereUniqueWithoutDoctorInput | DiagnosisUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DiagnosisCreateManyDoctorInputEnvelope
    set?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    disconnect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    delete?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    connect?: DiagnosisWhereUniqueInput | DiagnosisWhereUniqueInput[]
    update?: DiagnosisUpdateWithWhereUniqueWithoutDoctorInput | DiagnosisUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DiagnosisUpdateManyWithWhereWithoutDoctorInput | DiagnosisUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
  }

  export type TreatmentsUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<TreatmentsCreateWithoutDoctorInput, TreatmentsUncheckedCreateWithoutDoctorInput> | TreatmentsCreateWithoutDoctorInput[] | TreatmentsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutDoctorInput | TreatmentsCreateOrConnectWithoutDoctorInput[]
    upsert?: TreatmentsUpsertWithWhereUniqueWithoutDoctorInput | TreatmentsUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: TreatmentsCreateManyDoctorInputEnvelope
    set?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    disconnect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    delete?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    update?: TreatmentsUpdateWithWhereUniqueWithoutDoctorInput | TreatmentsUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: TreatmentsUpdateManyWithWhereWithoutDoctorInput | TreatmentsUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: TreatmentsScalarWhereInput | TreatmentsScalarWhereInput[]
  }

  export type LabTestsUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<LabTestsCreateWithoutDoctorInput, LabTestsUncheckedCreateWithoutDoctorInput> | LabTestsCreateWithoutDoctorInput[] | LabTestsUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: LabTestsCreateOrConnectWithoutDoctorInput | LabTestsCreateOrConnectWithoutDoctorInput[]
    upsert?: LabTestsUpsertWithWhereUniqueWithoutDoctorInput | LabTestsUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: LabTestsCreateManyDoctorInputEnvelope
    set?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    disconnect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    delete?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    connect?: LabTestsWhereUniqueInput | LabTestsWhereUniqueInput[]
    update?: LabTestsUpdateWithWhereUniqueWithoutDoctorInput | LabTestsUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: LabTestsUpdateManyWithWhereWithoutDoctorInput | LabTestsUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: LabTestsScalarWhereInput | LabTestsScalarWhereInput[]
  }

  export type DoctorsCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DoctorsCreateWithoutDepartmentInput, DoctorsUncheckedCreateWithoutDepartmentInput> | DoctorsCreateWithoutDepartmentInput[] | DoctorsUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DoctorsCreateOrConnectWithoutDepartmentInput | DoctorsCreateOrConnectWithoutDepartmentInput[]
    createMany?: DoctorsCreateManyDepartmentInputEnvelope
    connect?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
  }

  export type DoctorsUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<DoctorsCreateWithoutDepartmentInput, DoctorsUncheckedCreateWithoutDepartmentInput> | DoctorsCreateWithoutDepartmentInput[] | DoctorsUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DoctorsCreateOrConnectWithoutDepartmentInput | DoctorsCreateOrConnectWithoutDepartmentInput[]
    createMany?: DoctorsCreateManyDepartmentInputEnvelope
    connect?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
  }

  export type DoctorsUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DoctorsCreateWithoutDepartmentInput, DoctorsUncheckedCreateWithoutDepartmentInput> | DoctorsCreateWithoutDepartmentInput[] | DoctorsUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DoctorsCreateOrConnectWithoutDepartmentInput | DoctorsCreateOrConnectWithoutDepartmentInput[]
    upsert?: DoctorsUpsertWithWhereUniqueWithoutDepartmentInput | DoctorsUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DoctorsCreateManyDepartmentInputEnvelope
    set?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
    disconnect?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
    delete?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
    connect?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
    update?: DoctorsUpdateWithWhereUniqueWithoutDepartmentInput | DoctorsUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DoctorsUpdateManyWithWhereWithoutDepartmentInput | DoctorsUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DoctorsScalarWhereInput | DoctorsScalarWhereInput[]
  }

  export type DoctorsUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<DoctorsCreateWithoutDepartmentInput, DoctorsUncheckedCreateWithoutDepartmentInput> | DoctorsCreateWithoutDepartmentInput[] | DoctorsUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: DoctorsCreateOrConnectWithoutDepartmentInput | DoctorsCreateOrConnectWithoutDepartmentInput[]
    upsert?: DoctorsUpsertWithWhereUniqueWithoutDepartmentInput | DoctorsUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: DoctorsCreateManyDepartmentInputEnvelope
    set?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
    disconnect?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
    delete?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
    connect?: DoctorsWhereUniqueInput | DoctorsWhereUniqueInput[]
    update?: DoctorsUpdateWithWhereUniqueWithoutDepartmentInput | DoctorsUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: DoctorsUpdateManyWithWhereWithoutDepartmentInput | DoctorsUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: DoctorsScalarWhereInput | DoctorsScalarWhereInput[]
  }

  export type PatientsCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientsCreateWithoutAppointmentsInput, PatientsUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutAppointmentsInput
    connect?: PatientsWhereUniqueInput
  }

  export type DoctorsCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DoctorsCreateWithoutAppointmentsInput, DoctorsUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorsCreateOrConnectWithoutAppointmentsInput
    connect?: DoctorsWhereUniqueInput
  }

  export type PatientsUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientsCreateWithoutAppointmentsInput, PatientsUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientsUpsertWithoutAppointmentsInput
    connect?: PatientsWhereUniqueInput
    update?: XOR<XOR<PatientsUpdateToOneWithWhereWithoutAppointmentsInput, PatientsUpdateWithoutAppointmentsInput>, PatientsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorsUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<DoctorsCreateWithoutAppointmentsInput, DoctorsUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorsCreateOrConnectWithoutAppointmentsInput
    upsert?: DoctorsUpsertWithoutAppointmentsInput
    connect?: DoctorsWhereUniqueInput
    update?: XOR<XOR<DoctorsUpdateToOneWithWhereWithoutAppointmentsInput, DoctorsUpdateWithoutAppointmentsInput>, DoctorsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PatientsCreateNestedOneWithoutMedicalHistoryInput = {
    create?: XOR<PatientsCreateWithoutMedicalHistoryInput, PatientsUncheckedCreateWithoutMedicalHistoryInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutMedicalHistoryInput
    connect?: PatientsWhereUniqueInput
  }

  export type PatientsUpdateOneRequiredWithoutMedicalHistoryNestedInput = {
    create?: XOR<PatientsCreateWithoutMedicalHistoryInput, PatientsUncheckedCreateWithoutMedicalHistoryInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutMedicalHistoryInput
    upsert?: PatientsUpsertWithoutMedicalHistoryInput
    connect?: PatientsWhereUniqueInput
    update?: XOR<XOR<PatientsUpdateToOneWithWhereWithoutMedicalHistoryInput, PatientsUpdateWithoutMedicalHistoryInput>, PatientsUncheckedUpdateWithoutMedicalHistoryInput>
  }

  export type PatientsCreateNestedOneWithoutDiagnosisInput = {
    create?: XOR<PatientsCreateWithoutDiagnosisInput, PatientsUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutDiagnosisInput
    connect?: PatientsWhereUniqueInput
  }

  export type DoctorsCreateNestedOneWithoutDiagnosisInput = {
    create?: XOR<DoctorsCreateWithoutDiagnosisInput, DoctorsUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: DoctorsCreateOrConnectWithoutDiagnosisInput
    connect?: DoctorsWhereUniqueInput
  }

  export type PatientsUpdateOneRequiredWithoutDiagnosisNestedInput = {
    create?: XOR<PatientsCreateWithoutDiagnosisInput, PatientsUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutDiagnosisInput
    upsert?: PatientsUpsertWithoutDiagnosisInput
    connect?: PatientsWhereUniqueInput
    update?: XOR<XOR<PatientsUpdateToOneWithWhereWithoutDiagnosisInput, PatientsUpdateWithoutDiagnosisInput>, PatientsUncheckedUpdateWithoutDiagnosisInput>
  }

  export type DoctorsUpdateOneRequiredWithoutDiagnosisNestedInput = {
    create?: XOR<DoctorsCreateWithoutDiagnosisInput, DoctorsUncheckedCreateWithoutDiagnosisInput>
    connectOrCreate?: DoctorsCreateOrConnectWithoutDiagnosisInput
    upsert?: DoctorsUpsertWithoutDiagnosisInput
    connect?: DoctorsWhereUniqueInput
    update?: XOR<XOR<DoctorsUpdateToOneWithWhereWithoutDiagnosisInput, DoctorsUpdateWithoutDiagnosisInput>, DoctorsUncheckedUpdateWithoutDiagnosisInput>
  }

  export type TreatmentsCreateNestedManyWithoutMedicationInput = {
    create?: XOR<TreatmentsCreateWithoutMedicationInput, TreatmentsUncheckedCreateWithoutMedicationInput> | TreatmentsCreateWithoutMedicationInput[] | TreatmentsUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutMedicationInput | TreatmentsCreateOrConnectWithoutMedicationInput[]
    createMany?: TreatmentsCreateManyMedicationInputEnvelope
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
  }

  export type TreatmentsUncheckedCreateNestedManyWithoutMedicationInput = {
    create?: XOR<TreatmentsCreateWithoutMedicationInput, TreatmentsUncheckedCreateWithoutMedicationInput> | TreatmentsCreateWithoutMedicationInput[] | TreatmentsUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutMedicationInput | TreatmentsCreateOrConnectWithoutMedicationInput[]
    createMany?: TreatmentsCreateManyMedicationInputEnvelope
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
  }

  export type TreatmentsUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<TreatmentsCreateWithoutMedicationInput, TreatmentsUncheckedCreateWithoutMedicationInput> | TreatmentsCreateWithoutMedicationInput[] | TreatmentsUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutMedicationInput | TreatmentsCreateOrConnectWithoutMedicationInput[]
    upsert?: TreatmentsUpsertWithWhereUniqueWithoutMedicationInput | TreatmentsUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: TreatmentsCreateManyMedicationInputEnvelope
    set?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    disconnect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    delete?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    update?: TreatmentsUpdateWithWhereUniqueWithoutMedicationInput | TreatmentsUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: TreatmentsUpdateManyWithWhereWithoutMedicationInput | TreatmentsUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: TreatmentsScalarWhereInput | TreatmentsScalarWhereInput[]
  }

  export type TreatmentsUncheckedUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<TreatmentsCreateWithoutMedicationInput, TreatmentsUncheckedCreateWithoutMedicationInput> | TreatmentsCreateWithoutMedicationInput[] | TreatmentsUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: TreatmentsCreateOrConnectWithoutMedicationInput | TreatmentsCreateOrConnectWithoutMedicationInput[]
    upsert?: TreatmentsUpsertWithWhereUniqueWithoutMedicationInput | TreatmentsUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: TreatmentsCreateManyMedicationInputEnvelope
    set?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    disconnect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    delete?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    connect?: TreatmentsWhereUniqueInput | TreatmentsWhereUniqueInput[]
    update?: TreatmentsUpdateWithWhereUniqueWithoutMedicationInput | TreatmentsUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: TreatmentsUpdateManyWithWhereWithoutMedicationInput | TreatmentsUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: TreatmentsScalarWhereInput | TreatmentsScalarWhereInput[]
  }

  export type PatientsCreateNestedOneWithoutTreatmentsInput = {
    create?: XOR<PatientsCreateWithoutTreatmentsInput, PatientsUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutTreatmentsInput
    connect?: PatientsWhereUniqueInput
  }

  export type DoctorsCreateNestedOneWithoutTreatmentsInput = {
    create?: XOR<DoctorsCreateWithoutTreatmentsInput, DoctorsUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: DoctorsCreateOrConnectWithoutTreatmentsInput
    connect?: DoctorsWhereUniqueInput
  }

  export type MedicationsCreateNestedOneWithoutTreatmentsInput = {
    create?: XOR<MedicationsCreateWithoutTreatmentsInput, MedicationsUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: MedicationsCreateOrConnectWithoutTreatmentsInput
    connect?: MedicationsWhereUniqueInput
  }

  export type PatientsUpdateOneRequiredWithoutTreatmentsNestedInput = {
    create?: XOR<PatientsCreateWithoutTreatmentsInput, PatientsUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutTreatmentsInput
    upsert?: PatientsUpsertWithoutTreatmentsInput
    connect?: PatientsWhereUniqueInput
    update?: XOR<XOR<PatientsUpdateToOneWithWhereWithoutTreatmentsInput, PatientsUpdateWithoutTreatmentsInput>, PatientsUncheckedUpdateWithoutTreatmentsInput>
  }

  export type DoctorsUpdateOneRequiredWithoutTreatmentsNestedInput = {
    create?: XOR<DoctorsCreateWithoutTreatmentsInput, DoctorsUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: DoctorsCreateOrConnectWithoutTreatmentsInput
    upsert?: DoctorsUpsertWithoutTreatmentsInput
    connect?: DoctorsWhereUniqueInput
    update?: XOR<XOR<DoctorsUpdateToOneWithWhereWithoutTreatmentsInput, DoctorsUpdateWithoutTreatmentsInput>, DoctorsUncheckedUpdateWithoutTreatmentsInput>
  }

  export type MedicationsUpdateOneRequiredWithoutTreatmentsNestedInput = {
    create?: XOR<MedicationsCreateWithoutTreatmentsInput, MedicationsUncheckedCreateWithoutTreatmentsInput>
    connectOrCreate?: MedicationsCreateOrConnectWithoutTreatmentsInput
    upsert?: MedicationsUpsertWithoutTreatmentsInput
    connect?: MedicationsWhereUniqueInput
    update?: XOR<XOR<MedicationsUpdateToOneWithWhereWithoutTreatmentsInput, MedicationsUpdateWithoutTreatmentsInput>, MedicationsUncheckedUpdateWithoutTreatmentsInput>
  }

  export type PatientsCreateNestedOneWithoutInsuranceInput = {
    create?: XOR<PatientsCreateWithoutInsuranceInput, PatientsUncheckedCreateWithoutInsuranceInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutInsuranceInput
    connect?: PatientsWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatientsUpdateOneRequiredWithoutInsuranceNestedInput = {
    create?: XOR<PatientsCreateWithoutInsuranceInput, PatientsUncheckedCreateWithoutInsuranceInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutInsuranceInput
    upsert?: PatientsUpsertWithoutInsuranceInput
    connect?: PatientsWhereUniqueInput
    update?: XOR<XOR<PatientsUpdateToOneWithWhereWithoutInsuranceInput, PatientsUpdateWithoutInsuranceInput>, PatientsUncheckedUpdateWithoutInsuranceInput>
  }

  export type PatientsCreateNestedOneWithoutLabTestsInput = {
    create?: XOR<PatientsCreateWithoutLabTestsInput, PatientsUncheckedCreateWithoutLabTestsInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutLabTestsInput
    connect?: PatientsWhereUniqueInput
  }

  export type DoctorsCreateNestedOneWithoutLabTestsInput = {
    create?: XOR<DoctorsCreateWithoutLabTestsInput, DoctorsUncheckedCreateWithoutLabTestsInput>
    connectOrCreate?: DoctorsCreateOrConnectWithoutLabTestsInput
    connect?: DoctorsWhereUniqueInput
  }

  export type PatientsUpdateOneRequiredWithoutLabTestsNestedInput = {
    create?: XOR<PatientsCreateWithoutLabTestsInput, PatientsUncheckedCreateWithoutLabTestsInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutLabTestsInput
    upsert?: PatientsUpsertWithoutLabTestsInput
    connect?: PatientsWhereUniqueInput
    update?: XOR<XOR<PatientsUpdateToOneWithWhereWithoutLabTestsInput, PatientsUpdateWithoutLabTestsInput>, PatientsUncheckedUpdateWithoutLabTestsInput>
  }

  export type DoctorsUpdateOneRequiredWithoutLabTestsNestedInput = {
    create?: XOR<DoctorsCreateWithoutLabTestsInput, DoctorsUncheckedCreateWithoutLabTestsInput>
    connectOrCreate?: DoctorsCreateOrConnectWithoutLabTestsInput
    upsert?: DoctorsUpsertWithoutLabTestsInput
    connect?: DoctorsWhereUniqueInput
    update?: XOR<XOR<DoctorsUpdateToOneWithWhereWithoutLabTestsInput, DoctorsUpdateWithoutLabTestsInput>, DoctorsUncheckedUpdateWithoutLabTestsInput>
  }

  export type PatientsCreateNestedOneWithoutBillsInput = {
    create?: XOR<PatientsCreateWithoutBillsInput, PatientsUncheckedCreateWithoutBillsInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutBillsInput
    connect?: PatientsWhereUniqueInput
  }

  export type PatientsUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<PatientsCreateWithoutBillsInput, PatientsUncheckedCreateWithoutBillsInput>
    connectOrCreate?: PatientsCreateOrConnectWithoutBillsInput
    upsert?: PatientsUpsertWithoutBillsInput
    connect?: PatientsWhereUniqueInput
    update?: XOR<XOR<PatientsUpdateToOneWithWhereWithoutBillsInput, PatientsUpdateWithoutBillsInput>, PatientsUncheckedUpdateWithoutBillsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AppointmentsCreateWithoutPatientInput = {
    appointment_date: Date | string
    reason_for_visit: string
    doctor: DoctorsCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentsUncheckedCreateWithoutPatientInput = {
    appointment_id?: number
    doctor_id: number
    appointment_date: Date | string
    reason_for_visit: string
  }

  export type AppointmentsCreateOrConnectWithoutPatientInput = {
    where: AppointmentsWhereUniqueInput
    create: XOR<AppointmentsCreateWithoutPatientInput, AppointmentsUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentsCreateManyPatientInputEnvelope = {
    data: AppointmentsCreateManyPatientInput | AppointmentsCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicalHistoryCreateWithoutPatientInput = {
    treatment: string
    treatment_date: Date | string
  }

  export type MedicalHistoryUncheckedCreateWithoutPatientInput = {
    history_id?: number
    treatment: string
    treatment_date: Date | string
  }

  export type MedicalHistoryCreateOrConnectWithoutPatientInput = {
    where: MedicalHistoryWhereUniqueInput
    create: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput>
  }

  export type MedicalHistoryCreateManyPatientInputEnvelope = {
    data: MedicalHistoryCreateManyPatientInput | MedicalHistoryCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosisCreateWithoutPatientInput = {
    diagnosis_description: string
    diagnosis_date: Date | string
    doctor: DoctorsCreateNestedOneWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateWithoutPatientInput = {
    diagnosis_id?: number
    doctor_id: number
    diagnosis_description: string
    diagnosis_date: Date | string
  }

  export type DiagnosisCreateOrConnectWithoutPatientInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput>
  }

  export type DiagnosisCreateManyPatientInputEnvelope = {
    data: DiagnosisCreateManyPatientInput | DiagnosisCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentsCreateWithoutPatientInput = {
    treatment_description: string
    treatment_date: Date | string
    doctor: DoctorsCreateNestedOneWithoutTreatmentsInput
    medication: MedicationsCreateNestedOneWithoutTreatmentsInput
  }

  export type TreatmentsUncheckedCreateWithoutPatientInput = {
    treatment_id?: number
    doctor_id: number
    medication_id: number
    treatment_description: string
    treatment_date: Date | string
  }

  export type TreatmentsCreateOrConnectWithoutPatientInput = {
    where: TreatmentsWhereUniqueInput
    create: XOR<TreatmentsCreateWithoutPatientInput, TreatmentsUncheckedCreateWithoutPatientInput>
  }

  export type TreatmentsCreateManyPatientInputEnvelope = {
    data: TreatmentsCreateManyPatientInput | TreatmentsCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InsuranceCreateWithoutPatientInput = {
    provider_name: string
    policy_number: string
    coverage_amount: number
  }

  export type InsuranceUncheckedCreateWithoutPatientInput = {
    insurance_id?: number
    provider_name: string
    policy_number: string
    coverage_amount: number
  }

  export type InsuranceCreateOrConnectWithoutPatientInput = {
    where: InsuranceWhereUniqueInput
    create: XOR<InsuranceCreateWithoutPatientInput, InsuranceUncheckedCreateWithoutPatientInput>
  }

  export type InsuranceCreateManyPatientInputEnvelope = {
    data: InsuranceCreateManyPatientInput | InsuranceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type LabTestsCreateWithoutPatientInput = {
    test_name: string
    test_result: string
    test_date: Date | string
    doctor: DoctorsCreateNestedOneWithoutLabTestsInput
  }

  export type LabTestsUncheckedCreateWithoutPatientInput = {
    test_id?: number
    test_name: string
    test_result: string
    test_date: Date | string
    doctor_id: number
  }

  export type LabTestsCreateOrConnectWithoutPatientInput = {
    where: LabTestsWhereUniqueInput
    create: XOR<LabTestsCreateWithoutPatientInput, LabTestsUncheckedCreateWithoutPatientInput>
  }

  export type LabTestsCreateManyPatientInputEnvelope = {
    data: LabTestsCreateManyPatientInput | LabTestsCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type BillsCreateWithoutPatientInput = {
    total_amount: number
    billing_date: Date | string
    insurance_covered: boolean
    amount_paid: number
  }

  export type BillsUncheckedCreateWithoutPatientInput = {
    bill_id?: number
    total_amount: number
    billing_date: Date | string
    insurance_covered: boolean
    amount_paid: number
  }

  export type BillsCreateOrConnectWithoutPatientInput = {
    where: BillsWhereUniqueInput
    create: XOR<BillsCreateWithoutPatientInput, BillsUncheckedCreateWithoutPatientInput>
  }

  export type BillsCreateManyPatientInputEnvelope = {
    data: BillsCreateManyPatientInput | BillsCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentsUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentsWhereUniqueInput
    update: XOR<AppointmentsUpdateWithoutPatientInput, AppointmentsUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentsCreateWithoutPatientInput, AppointmentsUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentsUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentsWhereUniqueInput
    data: XOR<AppointmentsUpdateWithoutPatientInput, AppointmentsUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentsUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentsScalarWhereInput
    data: XOR<AppointmentsUpdateManyMutationInput, AppointmentsUncheckedUpdateManyWithoutPatientInput>
  }

  export type AppointmentsScalarWhereInput = {
    AND?: AppointmentsScalarWhereInput | AppointmentsScalarWhereInput[]
    OR?: AppointmentsScalarWhereInput[]
    NOT?: AppointmentsScalarWhereInput | AppointmentsScalarWhereInput[]
    appointment_id?: IntFilter<"Appointments"> | number
    patient_id?: IntFilter<"Appointments"> | number
    doctor_id?: IntFilter<"Appointments"> | number
    appointment_date?: DateTimeFilter<"Appointments"> | Date | string
    reason_for_visit?: StringFilter<"Appointments"> | string
  }

  export type MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicalHistoryWhereUniqueInput
    update: XOR<MedicalHistoryUpdateWithoutPatientInput, MedicalHistoryUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput>
  }

  export type MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicalHistoryWhereUniqueInput
    data: XOR<MedicalHistoryUpdateWithoutPatientInput, MedicalHistoryUncheckedUpdateWithoutPatientInput>
  }

  export type MedicalHistoryUpdateManyWithWhereWithoutPatientInput = {
    where: MedicalHistoryScalarWhereInput
    data: XOR<MedicalHistoryUpdateManyMutationInput, MedicalHistoryUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicalHistoryScalarWhereInput = {
    AND?: MedicalHistoryScalarWhereInput | MedicalHistoryScalarWhereInput[]
    OR?: MedicalHistoryScalarWhereInput[]
    NOT?: MedicalHistoryScalarWhereInput | MedicalHistoryScalarWhereInput[]
    history_id?: IntFilter<"MedicalHistory"> | number
    patient_id?: IntFilter<"MedicalHistory"> | number
    treatment?: StringFilter<"MedicalHistory"> | string
    treatment_date?: DateTimeFilter<"MedicalHistory"> | Date | string
  }

  export type DiagnosisUpsertWithWhereUniqueWithoutPatientInput = {
    where: DiagnosisWhereUniqueInput
    update: XOR<DiagnosisUpdateWithoutPatientInput, DiagnosisUncheckedUpdateWithoutPatientInput>
    create: XOR<DiagnosisCreateWithoutPatientInput, DiagnosisUncheckedCreateWithoutPatientInput>
  }

  export type DiagnosisUpdateWithWhereUniqueWithoutPatientInput = {
    where: DiagnosisWhereUniqueInput
    data: XOR<DiagnosisUpdateWithoutPatientInput, DiagnosisUncheckedUpdateWithoutPatientInput>
  }

  export type DiagnosisUpdateManyWithWhereWithoutPatientInput = {
    where: DiagnosisScalarWhereInput
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyWithoutPatientInput>
  }

  export type DiagnosisScalarWhereInput = {
    AND?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
    OR?: DiagnosisScalarWhereInput[]
    NOT?: DiagnosisScalarWhereInput | DiagnosisScalarWhereInput[]
    diagnosis_id?: IntFilter<"Diagnosis"> | number
    patient_id?: IntFilter<"Diagnosis"> | number
    doctor_id?: IntFilter<"Diagnosis"> | number
    diagnosis_description?: StringFilter<"Diagnosis"> | string
    diagnosis_date?: DateTimeFilter<"Diagnosis"> | Date | string
  }

  export type TreatmentsUpsertWithWhereUniqueWithoutPatientInput = {
    where: TreatmentsWhereUniqueInput
    update: XOR<TreatmentsUpdateWithoutPatientInput, TreatmentsUncheckedUpdateWithoutPatientInput>
    create: XOR<TreatmentsCreateWithoutPatientInput, TreatmentsUncheckedCreateWithoutPatientInput>
  }

  export type TreatmentsUpdateWithWhereUniqueWithoutPatientInput = {
    where: TreatmentsWhereUniqueInput
    data: XOR<TreatmentsUpdateWithoutPatientInput, TreatmentsUncheckedUpdateWithoutPatientInput>
  }

  export type TreatmentsUpdateManyWithWhereWithoutPatientInput = {
    where: TreatmentsScalarWhereInput
    data: XOR<TreatmentsUpdateManyMutationInput, TreatmentsUncheckedUpdateManyWithoutPatientInput>
  }

  export type TreatmentsScalarWhereInput = {
    AND?: TreatmentsScalarWhereInput | TreatmentsScalarWhereInput[]
    OR?: TreatmentsScalarWhereInput[]
    NOT?: TreatmentsScalarWhereInput | TreatmentsScalarWhereInput[]
    treatment_id?: IntFilter<"Treatments"> | number
    patient_id?: IntFilter<"Treatments"> | number
    doctor_id?: IntFilter<"Treatments"> | number
    medication_id?: IntFilter<"Treatments"> | number
    treatment_description?: StringFilter<"Treatments"> | string
    treatment_date?: DateTimeFilter<"Treatments"> | Date | string
  }

  export type InsuranceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InsuranceWhereUniqueInput
    update: XOR<InsuranceUpdateWithoutPatientInput, InsuranceUncheckedUpdateWithoutPatientInput>
    create: XOR<InsuranceCreateWithoutPatientInput, InsuranceUncheckedCreateWithoutPatientInput>
  }

  export type InsuranceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InsuranceWhereUniqueInput
    data: XOR<InsuranceUpdateWithoutPatientInput, InsuranceUncheckedUpdateWithoutPatientInput>
  }

  export type InsuranceUpdateManyWithWhereWithoutPatientInput = {
    where: InsuranceScalarWhereInput
    data: XOR<InsuranceUpdateManyMutationInput, InsuranceUncheckedUpdateManyWithoutPatientInput>
  }

  export type InsuranceScalarWhereInput = {
    AND?: InsuranceScalarWhereInput | InsuranceScalarWhereInput[]
    OR?: InsuranceScalarWhereInput[]
    NOT?: InsuranceScalarWhereInput | InsuranceScalarWhereInput[]
    insurance_id?: IntFilter<"Insurance"> | number
    patient_id?: IntFilter<"Insurance"> | number
    provider_name?: StringFilter<"Insurance"> | string
    policy_number?: StringFilter<"Insurance"> | string
    coverage_amount?: FloatFilter<"Insurance"> | number
  }

  export type LabTestsUpsertWithWhereUniqueWithoutPatientInput = {
    where: LabTestsWhereUniqueInput
    update: XOR<LabTestsUpdateWithoutPatientInput, LabTestsUncheckedUpdateWithoutPatientInput>
    create: XOR<LabTestsCreateWithoutPatientInput, LabTestsUncheckedCreateWithoutPatientInput>
  }

  export type LabTestsUpdateWithWhereUniqueWithoutPatientInput = {
    where: LabTestsWhereUniqueInput
    data: XOR<LabTestsUpdateWithoutPatientInput, LabTestsUncheckedUpdateWithoutPatientInput>
  }

  export type LabTestsUpdateManyWithWhereWithoutPatientInput = {
    where: LabTestsScalarWhereInput
    data: XOR<LabTestsUpdateManyMutationInput, LabTestsUncheckedUpdateManyWithoutPatientInput>
  }

  export type LabTestsScalarWhereInput = {
    AND?: LabTestsScalarWhereInput | LabTestsScalarWhereInput[]
    OR?: LabTestsScalarWhereInput[]
    NOT?: LabTestsScalarWhereInput | LabTestsScalarWhereInput[]
    test_id?: IntFilter<"LabTests"> | number
    patient_id?: IntFilter<"LabTests"> | number
    test_name?: StringFilter<"LabTests"> | string
    test_result?: StringFilter<"LabTests"> | string
    test_date?: DateTimeFilter<"LabTests"> | Date | string
    doctor_id?: IntFilter<"LabTests"> | number
  }

  export type BillsUpsertWithWhereUniqueWithoutPatientInput = {
    where: BillsWhereUniqueInput
    update: XOR<BillsUpdateWithoutPatientInput, BillsUncheckedUpdateWithoutPatientInput>
    create: XOR<BillsCreateWithoutPatientInput, BillsUncheckedCreateWithoutPatientInput>
  }

  export type BillsUpdateWithWhereUniqueWithoutPatientInput = {
    where: BillsWhereUniqueInput
    data: XOR<BillsUpdateWithoutPatientInput, BillsUncheckedUpdateWithoutPatientInput>
  }

  export type BillsUpdateManyWithWhereWithoutPatientInput = {
    where: BillsScalarWhereInput
    data: XOR<BillsUpdateManyMutationInput, BillsUncheckedUpdateManyWithoutPatientInput>
  }

  export type BillsScalarWhereInput = {
    AND?: BillsScalarWhereInput | BillsScalarWhereInput[]
    OR?: BillsScalarWhereInput[]
    NOT?: BillsScalarWhereInput | BillsScalarWhereInput[]
    bill_id?: IntFilter<"Bills"> | number
    patient_id?: IntFilter<"Bills"> | number
    total_amount?: FloatFilter<"Bills"> | number
    billing_date?: DateTimeFilter<"Bills"> | Date | string
    insurance_covered?: BoolFilter<"Bills"> | boolean
    amount_paid?: FloatFilter<"Bills"> | number
  }

  export type DepartmentsCreateWithoutDoctorsInput = {
    department_name: string
  }

  export type DepartmentsUncheckedCreateWithoutDoctorsInput = {
    department_id?: number
    department_name: string
  }

  export type DepartmentsCreateOrConnectWithoutDoctorsInput = {
    where: DepartmentsWhereUniqueInput
    create: XOR<DepartmentsCreateWithoutDoctorsInput, DepartmentsUncheckedCreateWithoutDoctorsInput>
  }

  export type AppointmentsCreateWithoutDoctorInput = {
    appointment_date: Date | string
    reason_for_visit: string
    patient: PatientsCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentsUncheckedCreateWithoutDoctorInput = {
    appointment_id?: number
    patient_id: number
    appointment_date: Date | string
    reason_for_visit: string
  }

  export type AppointmentsCreateOrConnectWithoutDoctorInput = {
    where: AppointmentsWhereUniqueInput
    create: XOR<AppointmentsCreateWithoutDoctorInput, AppointmentsUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentsCreateManyDoctorInputEnvelope = {
    data: AppointmentsCreateManyDoctorInput | AppointmentsCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DiagnosisCreateWithoutDoctorInput = {
    diagnosis_description: string
    diagnosis_date: Date | string
    patient: PatientsCreateNestedOneWithoutDiagnosisInput
  }

  export type DiagnosisUncheckedCreateWithoutDoctorInput = {
    diagnosis_id?: number
    patient_id: number
    diagnosis_description: string
    diagnosis_date: Date | string
  }

  export type DiagnosisCreateOrConnectWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    create: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput>
  }

  export type DiagnosisCreateManyDoctorInputEnvelope = {
    data: DiagnosisCreateManyDoctorInput | DiagnosisCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentsCreateWithoutDoctorInput = {
    treatment_description: string
    treatment_date: Date | string
    patient: PatientsCreateNestedOneWithoutTreatmentsInput
    medication: MedicationsCreateNestedOneWithoutTreatmentsInput
  }

  export type TreatmentsUncheckedCreateWithoutDoctorInput = {
    treatment_id?: number
    patient_id: number
    medication_id: number
    treatment_description: string
    treatment_date: Date | string
  }

  export type TreatmentsCreateOrConnectWithoutDoctorInput = {
    where: TreatmentsWhereUniqueInput
    create: XOR<TreatmentsCreateWithoutDoctorInput, TreatmentsUncheckedCreateWithoutDoctorInput>
  }

  export type TreatmentsCreateManyDoctorInputEnvelope = {
    data: TreatmentsCreateManyDoctorInput | TreatmentsCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type LabTestsCreateWithoutDoctorInput = {
    test_name: string
    test_result: string
    test_date: Date | string
    patient: PatientsCreateNestedOneWithoutLabTestsInput
  }

  export type LabTestsUncheckedCreateWithoutDoctorInput = {
    test_id?: number
    patient_id: number
    test_name: string
    test_result: string
    test_date: Date | string
  }

  export type LabTestsCreateOrConnectWithoutDoctorInput = {
    where: LabTestsWhereUniqueInput
    create: XOR<LabTestsCreateWithoutDoctorInput, LabTestsUncheckedCreateWithoutDoctorInput>
  }

  export type LabTestsCreateManyDoctorInputEnvelope = {
    data: LabTestsCreateManyDoctorInput | LabTestsCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentsUpsertWithoutDoctorsInput = {
    update: XOR<DepartmentsUpdateWithoutDoctorsInput, DepartmentsUncheckedUpdateWithoutDoctorsInput>
    create: XOR<DepartmentsCreateWithoutDoctorsInput, DepartmentsUncheckedCreateWithoutDoctorsInput>
    where?: DepartmentsWhereInput
  }

  export type DepartmentsUpdateToOneWithWhereWithoutDoctorsInput = {
    where?: DepartmentsWhereInput
    data: XOR<DepartmentsUpdateWithoutDoctorsInput, DepartmentsUncheckedUpdateWithoutDoctorsInput>
  }

  export type DepartmentsUpdateWithoutDoctorsInput = {
    department_name?: StringFieldUpdateOperationsInput | string
  }

  export type DepartmentsUncheckedUpdateWithoutDoctorsInput = {
    department_id?: IntFieldUpdateOperationsInput | number
    department_name?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentsUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentsWhereUniqueInput
    update: XOR<AppointmentsUpdateWithoutDoctorInput, AppointmentsUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentsCreateWithoutDoctorInput, AppointmentsUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentsUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentsWhereUniqueInput
    data: XOR<AppointmentsUpdateWithoutDoctorInput, AppointmentsUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentsUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentsScalarWhereInput
    data: XOR<AppointmentsUpdateManyMutationInput, AppointmentsUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DiagnosisUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    update: XOR<DiagnosisUpdateWithoutDoctorInput, DiagnosisUncheckedUpdateWithoutDoctorInput>
    create: XOR<DiagnosisCreateWithoutDoctorInput, DiagnosisUncheckedCreateWithoutDoctorInput>
  }

  export type DiagnosisUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DiagnosisWhereUniqueInput
    data: XOR<DiagnosisUpdateWithoutDoctorInput, DiagnosisUncheckedUpdateWithoutDoctorInput>
  }

  export type DiagnosisUpdateManyWithWhereWithoutDoctorInput = {
    where: DiagnosisScalarWhereInput
    data: XOR<DiagnosisUpdateManyMutationInput, DiagnosisUncheckedUpdateManyWithoutDoctorInput>
  }

  export type TreatmentsUpsertWithWhereUniqueWithoutDoctorInput = {
    where: TreatmentsWhereUniqueInput
    update: XOR<TreatmentsUpdateWithoutDoctorInput, TreatmentsUncheckedUpdateWithoutDoctorInput>
    create: XOR<TreatmentsCreateWithoutDoctorInput, TreatmentsUncheckedCreateWithoutDoctorInput>
  }

  export type TreatmentsUpdateWithWhereUniqueWithoutDoctorInput = {
    where: TreatmentsWhereUniqueInput
    data: XOR<TreatmentsUpdateWithoutDoctorInput, TreatmentsUncheckedUpdateWithoutDoctorInput>
  }

  export type TreatmentsUpdateManyWithWhereWithoutDoctorInput = {
    where: TreatmentsScalarWhereInput
    data: XOR<TreatmentsUpdateManyMutationInput, TreatmentsUncheckedUpdateManyWithoutDoctorInput>
  }

  export type LabTestsUpsertWithWhereUniqueWithoutDoctorInput = {
    where: LabTestsWhereUniqueInput
    update: XOR<LabTestsUpdateWithoutDoctorInput, LabTestsUncheckedUpdateWithoutDoctorInput>
    create: XOR<LabTestsCreateWithoutDoctorInput, LabTestsUncheckedCreateWithoutDoctorInput>
  }

  export type LabTestsUpdateWithWhereUniqueWithoutDoctorInput = {
    where: LabTestsWhereUniqueInput
    data: XOR<LabTestsUpdateWithoutDoctorInput, LabTestsUncheckedUpdateWithoutDoctorInput>
  }

  export type LabTestsUpdateManyWithWhereWithoutDoctorInput = {
    where: LabTestsScalarWhereInput
    data: XOR<LabTestsUpdateManyMutationInput, LabTestsUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DoctorsCreateWithoutDepartmentInput = {
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    appointments?: AppointmentsCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsUncheckedCreateWithoutDepartmentInput = {
    doctor_id?: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsCreateOrConnectWithoutDepartmentInput = {
    where: DoctorsWhereUniqueInput
    create: XOR<DoctorsCreateWithoutDepartmentInput, DoctorsUncheckedCreateWithoutDepartmentInput>
  }

  export type DoctorsCreateManyDepartmentInputEnvelope = {
    data: DoctorsCreateManyDepartmentInput | DoctorsCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DoctorsUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: DoctorsWhereUniqueInput
    update: XOR<DoctorsUpdateWithoutDepartmentInput, DoctorsUncheckedUpdateWithoutDepartmentInput>
    create: XOR<DoctorsCreateWithoutDepartmentInput, DoctorsUncheckedCreateWithoutDepartmentInput>
  }

  export type DoctorsUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: DoctorsWhereUniqueInput
    data: XOR<DoctorsUpdateWithoutDepartmentInput, DoctorsUncheckedUpdateWithoutDepartmentInput>
  }

  export type DoctorsUpdateManyWithWhereWithoutDepartmentInput = {
    where: DoctorsScalarWhereInput
    data: XOR<DoctorsUpdateManyMutationInput, DoctorsUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DoctorsScalarWhereInput = {
    AND?: DoctorsScalarWhereInput | DoctorsScalarWhereInput[]
    OR?: DoctorsScalarWhereInput[]
    NOT?: DoctorsScalarWhereInput | DoctorsScalarWhereInput[]
    doctor_id?: IntFilter<"Doctors"> | number
    first_name?: StringFilter<"Doctors"> | string
    last_name?: StringFilter<"Doctors"> | string
    specialty?: StringFilter<"Doctors"> | string
    contact_number?: StringFilter<"Doctors"> | string
    department_id?: IntFilter<"Doctors"> | number
  }

  export type PatientsCreateWithoutAppointmentsInput = {
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsCreateNestedManyWithoutPatientInput
    insurance?: InsuranceCreateNestedManyWithoutPatientInput
    labTests?: LabTestsCreateNestedManyWithoutPatientInput
    bills?: BillsCreateNestedManyWithoutPatientInput
  }

  export type PatientsUncheckedCreateWithoutAppointmentsInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutPatientInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPatientInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutPatientInput
    bills?: BillsUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientsCreateOrConnectWithoutAppointmentsInput = {
    where: PatientsWhereUniqueInput
    create: XOR<PatientsCreateWithoutAppointmentsInput, PatientsUncheckedCreateWithoutAppointmentsInput>
  }

  export type DoctorsCreateWithoutAppointmentsInput = {
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department: DepartmentsCreateNestedOneWithoutDoctorsInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsUncheckedCreateWithoutAppointmentsInput = {
    doctor_id?: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department_id: number
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsCreateOrConnectWithoutAppointmentsInput = {
    where: DoctorsWhereUniqueInput
    create: XOR<DoctorsCreateWithoutAppointmentsInput, DoctorsUncheckedCreateWithoutAppointmentsInput>
  }

  export type PatientsUpsertWithoutAppointmentsInput = {
    update: XOR<PatientsUpdateWithoutAppointmentsInput, PatientsUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientsCreateWithoutAppointmentsInput, PatientsUncheckedCreateWithoutAppointmentsInput>
    where?: PatientsWhereInput
  }

  export type PatientsUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientsWhereInput
    data: XOR<PatientsUpdateWithoutAppointmentsInput, PatientsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientsUpdateWithoutAppointmentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUpdateManyWithoutPatientNestedInput
    bills?: BillsUpdateManyWithoutPatientNestedInput
  }

  export type PatientsUncheckedUpdateWithoutAppointmentsInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutPatientNestedInput
    bills?: BillsUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorsUpsertWithoutAppointmentsInput = {
    update: XOR<DoctorsUpdateWithoutAppointmentsInput, DoctorsUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DoctorsCreateWithoutAppointmentsInput, DoctorsUncheckedCreateWithoutAppointmentsInput>
    where?: DoctorsWhereInput
  }

  export type DoctorsUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DoctorsWhereInput
    data: XOR<DoctorsUpdateWithoutAppointmentsInput, DoctorsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorsUpdateWithoutAppointmentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department?: DepartmentsUpdateOneRequiredWithoutDoctorsNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorsUncheckedUpdateWithoutAppointmentsInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientsCreateWithoutMedicalHistoryInput = {
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsCreateNestedManyWithoutPatientInput
    insurance?: InsuranceCreateNestedManyWithoutPatientInput
    labTests?: LabTestsCreateNestedManyWithoutPatientInput
    bills?: BillsCreateNestedManyWithoutPatientInput
  }

  export type PatientsUncheckedCreateWithoutMedicalHistoryInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutPatientInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPatientInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutPatientInput
    bills?: BillsUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientsCreateOrConnectWithoutMedicalHistoryInput = {
    where: PatientsWhereUniqueInput
    create: XOR<PatientsCreateWithoutMedicalHistoryInput, PatientsUncheckedCreateWithoutMedicalHistoryInput>
  }

  export type PatientsUpsertWithoutMedicalHistoryInput = {
    update: XOR<PatientsUpdateWithoutMedicalHistoryInput, PatientsUncheckedUpdateWithoutMedicalHistoryInput>
    create: XOR<PatientsCreateWithoutMedicalHistoryInput, PatientsUncheckedCreateWithoutMedicalHistoryInput>
    where?: PatientsWhereInput
  }

  export type PatientsUpdateToOneWithWhereWithoutMedicalHistoryInput = {
    where?: PatientsWhereInput
    data: XOR<PatientsUpdateWithoutMedicalHistoryInput, PatientsUncheckedUpdateWithoutMedicalHistoryInput>
  }

  export type PatientsUpdateWithoutMedicalHistoryInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUpdateManyWithoutPatientNestedInput
    bills?: BillsUpdateManyWithoutPatientNestedInput
  }

  export type PatientsUncheckedUpdateWithoutMedicalHistoryInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUncheckedUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutPatientNestedInput
    bills?: BillsUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientsCreateWithoutDiagnosisInput = {
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsCreateNestedManyWithoutPatientInput
    insurance?: InsuranceCreateNestedManyWithoutPatientInput
    labTests?: LabTestsCreateNestedManyWithoutPatientInput
    bills?: BillsCreateNestedManyWithoutPatientInput
  }

  export type PatientsUncheckedCreateWithoutDiagnosisInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutPatientInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPatientInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutPatientInput
    bills?: BillsUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientsCreateOrConnectWithoutDiagnosisInput = {
    where: PatientsWhereUniqueInput
    create: XOR<PatientsCreateWithoutDiagnosisInput, PatientsUncheckedCreateWithoutDiagnosisInput>
  }

  export type DoctorsCreateWithoutDiagnosisInput = {
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department: DepartmentsCreateNestedOneWithoutDoctorsInput
    appointments?: AppointmentsCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsUncheckedCreateWithoutDiagnosisInput = {
    doctor_id?: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department_id: number
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsCreateOrConnectWithoutDiagnosisInput = {
    where: DoctorsWhereUniqueInput
    create: XOR<DoctorsCreateWithoutDiagnosisInput, DoctorsUncheckedCreateWithoutDiagnosisInput>
  }

  export type PatientsUpsertWithoutDiagnosisInput = {
    update: XOR<PatientsUpdateWithoutDiagnosisInput, PatientsUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<PatientsCreateWithoutDiagnosisInput, PatientsUncheckedCreateWithoutDiagnosisInput>
    where?: PatientsWhereInput
  }

  export type PatientsUpdateToOneWithWhereWithoutDiagnosisInput = {
    where?: PatientsWhereInput
    data: XOR<PatientsUpdateWithoutDiagnosisInput, PatientsUncheckedUpdateWithoutDiagnosisInput>
  }

  export type PatientsUpdateWithoutDiagnosisInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUpdateManyWithoutPatientNestedInput
    bills?: BillsUpdateManyWithoutPatientNestedInput
  }

  export type PatientsUncheckedUpdateWithoutDiagnosisInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUncheckedUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutPatientNestedInput
    bills?: BillsUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorsUpsertWithoutDiagnosisInput = {
    update: XOR<DoctorsUpdateWithoutDiagnosisInput, DoctorsUncheckedUpdateWithoutDiagnosisInput>
    create: XOR<DoctorsCreateWithoutDiagnosisInput, DoctorsUncheckedCreateWithoutDiagnosisInput>
    where?: DoctorsWhereInput
  }

  export type DoctorsUpdateToOneWithWhereWithoutDiagnosisInput = {
    where?: DoctorsWhereInput
    data: XOR<DoctorsUpdateWithoutDiagnosisInput, DoctorsUncheckedUpdateWithoutDiagnosisInput>
  }

  export type DoctorsUpdateWithoutDiagnosisInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department?: DepartmentsUpdateOneRequiredWithoutDoctorsNestedInput
    appointments?: AppointmentsUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorsUncheckedUpdateWithoutDiagnosisInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    appointments?: AppointmentsUncheckedUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type TreatmentsCreateWithoutMedicationInput = {
    treatment_description: string
    treatment_date: Date | string
    patient: PatientsCreateNestedOneWithoutTreatmentsInput
    doctor: DoctorsCreateNestedOneWithoutTreatmentsInput
  }

  export type TreatmentsUncheckedCreateWithoutMedicationInput = {
    treatment_id?: number
    patient_id: number
    doctor_id: number
    treatment_description: string
    treatment_date: Date | string
  }

  export type TreatmentsCreateOrConnectWithoutMedicationInput = {
    where: TreatmentsWhereUniqueInput
    create: XOR<TreatmentsCreateWithoutMedicationInput, TreatmentsUncheckedCreateWithoutMedicationInput>
  }

  export type TreatmentsCreateManyMedicationInputEnvelope = {
    data: TreatmentsCreateManyMedicationInput | TreatmentsCreateManyMedicationInput[]
    skipDuplicates?: boolean
  }

  export type TreatmentsUpsertWithWhereUniqueWithoutMedicationInput = {
    where: TreatmentsWhereUniqueInput
    update: XOR<TreatmentsUpdateWithoutMedicationInput, TreatmentsUncheckedUpdateWithoutMedicationInput>
    create: XOR<TreatmentsCreateWithoutMedicationInput, TreatmentsUncheckedCreateWithoutMedicationInput>
  }

  export type TreatmentsUpdateWithWhereUniqueWithoutMedicationInput = {
    where: TreatmentsWhereUniqueInput
    data: XOR<TreatmentsUpdateWithoutMedicationInput, TreatmentsUncheckedUpdateWithoutMedicationInput>
  }

  export type TreatmentsUpdateManyWithWhereWithoutMedicationInput = {
    where: TreatmentsScalarWhereInput
    data: XOR<TreatmentsUpdateManyMutationInput, TreatmentsUncheckedUpdateManyWithoutMedicationInput>
  }

  export type PatientsCreateWithoutTreatmentsInput = {
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisCreateNestedManyWithoutPatientInput
    insurance?: InsuranceCreateNestedManyWithoutPatientInput
    labTests?: LabTestsCreateNestedManyWithoutPatientInput
    bills?: BillsCreateNestedManyWithoutPatientInput
  }

  export type PatientsUncheckedCreateWithoutTreatmentsInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPatientInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutPatientInput
    bills?: BillsUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientsCreateOrConnectWithoutTreatmentsInput = {
    where: PatientsWhereUniqueInput
    create: XOR<PatientsCreateWithoutTreatmentsInput, PatientsUncheckedCreateWithoutTreatmentsInput>
  }

  export type DoctorsCreateWithoutTreatmentsInput = {
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department: DepartmentsCreateNestedOneWithoutDoctorsInput
    appointments?: AppointmentsCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsUncheckedCreateWithoutTreatmentsInput = {
    doctor_id?: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department_id: number
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsCreateOrConnectWithoutTreatmentsInput = {
    where: DoctorsWhereUniqueInput
    create: XOR<DoctorsCreateWithoutTreatmentsInput, DoctorsUncheckedCreateWithoutTreatmentsInput>
  }

  export type MedicationsCreateWithoutTreatmentsInput = {
    medication_name: string
    dosage: string
    side_effects: string
  }

  export type MedicationsUncheckedCreateWithoutTreatmentsInput = {
    medication_id?: number
    medication_name: string
    dosage: string
    side_effects: string
  }

  export type MedicationsCreateOrConnectWithoutTreatmentsInput = {
    where: MedicationsWhereUniqueInput
    create: XOR<MedicationsCreateWithoutTreatmentsInput, MedicationsUncheckedCreateWithoutTreatmentsInput>
  }

  export type PatientsUpsertWithoutTreatmentsInput = {
    update: XOR<PatientsUpdateWithoutTreatmentsInput, PatientsUncheckedUpdateWithoutTreatmentsInput>
    create: XOR<PatientsCreateWithoutTreatmentsInput, PatientsUncheckedCreateWithoutTreatmentsInput>
    where?: PatientsWhereInput
  }

  export type PatientsUpdateToOneWithWhereWithoutTreatmentsInput = {
    where?: PatientsWhereInput
    data: XOR<PatientsUpdateWithoutTreatmentsInput, PatientsUncheckedUpdateWithoutTreatmentsInput>
  }

  export type PatientsUpdateWithoutTreatmentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUpdateManyWithoutPatientNestedInput
    bills?: BillsUpdateManyWithoutPatientNestedInput
  }

  export type PatientsUncheckedUpdateWithoutTreatmentsInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUncheckedUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutPatientNestedInput
    bills?: BillsUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorsUpsertWithoutTreatmentsInput = {
    update: XOR<DoctorsUpdateWithoutTreatmentsInput, DoctorsUncheckedUpdateWithoutTreatmentsInput>
    create: XOR<DoctorsCreateWithoutTreatmentsInput, DoctorsUncheckedCreateWithoutTreatmentsInput>
    where?: DoctorsWhereInput
  }

  export type DoctorsUpdateToOneWithWhereWithoutTreatmentsInput = {
    where?: DoctorsWhereInput
    data: XOR<DoctorsUpdateWithoutTreatmentsInput, DoctorsUncheckedUpdateWithoutTreatmentsInput>
  }

  export type DoctorsUpdateWithoutTreatmentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department?: DepartmentsUpdateOneRequiredWithoutDoctorsNestedInput
    appointments?: AppointmentsUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorsUncheckedUpdateWithoutTreatmentsInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    appointments?: AppointmentsUncheckedUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type MedicationsUpsertWithoutTreatmentsInput = {
    update: XOR<MedicationsUpdateWithoutTreatmentsInput, MedicationsUncheckedUpdateWithoutTreatmentsInput>
    create: XOR<MedicationsCreateWithoutTreatmentsInput, MedicationsUncheckedCreateWithoutTreatmentsInput>
    where?: MedicationsWhereInput
  }

  export type MedicationsUpdateToOneWithWhereWithoutTreatmentsInput = {
    where?: MedicationsWhereInput
    data: XOR<MedicationsUpdateWithoutTreatmentsInput, MedicationsUncheckedUpdateWithoutTreatmentsInput>
  }

  export type MedicationsUpdateWithoutTreatmentsInput = {
    medication_name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    side_effects?: StringFieldUpdateOperationsInput | string
  }

  export type MedicationsUncheckedUpdateWithoutTreatmentsInput = {
    medication_id?: IntFieldUpdateOperationsInput | number
    medication_name?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    side_effects?: StringFieldUpdateOperationsInput | string
  }

  export type PatientsCreateWithoutInsuranceInput = {
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsCreateNestedManyWithoutPatientInput
    labTests?: LabTestsCreateNestedManyWithoutPatientInput
    bills?: BillsCreateNestedManyWithoutPatientInput
  }

  export type PatientsUncheckedCreateWithoutInsuranceInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutPatientInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutPatientInput
    bills?: BillsUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientsCreateOrConnectWithoutInsuranceInput = {
    where: PatientsWhereUniqueInput
    create: XOR<PatientsCreateWithoutInsuranceInput, PatientsUncheckedCreateWithoutInsuranceInput>
  }

  export type PatientsUpsertWithoutInsuranceInput = {
    update: XOR<PatientsUpdateWithoutInsuranceInput, PatientsUncheckedUpdateWithoutInsuranceInput>
    create: XOR<PatientsCreateWithoutInsuranceInput, PatientsUncheckedCreateWithoutInsuranceInput>
    where?: PatientsWhereInput
  }

  export type PatientsUpdateToOneWithWhereWithoutInsuranceInput = {
    where?: PatientsWhereInput
    data: XOR<PatientsUpdateWithoutInsuranceInput, PatientsUncheckedUpdateWithoutInsuranceInput>
  }

  export type PatientsUpdateWithoutInsuranceInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUpdateManyWithoutPatientNestedInput
    bills?: BillsUpdateManyWithoutPatientNestedInput
  }

  export type PatientsUncheckedUpdateWithoutInsuranceInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUncheckedUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutPatientNestedInput
    bills?: BillsUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientsCreateWithoutLabTestsInput = {
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsCreateNestedManyWithoutPatientInput
    insurance?: InsuranceCreateNestedManyWithoutPatientInput
    bills?: BillsCreateNestedManyWithoutPatientInput
  }

  export type PatientsUncheckedCreateWithoutLabTestsInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutPatientInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPatientInput
    bills?: BillsUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientsCreateOrConnectWithoutLabTestsInput = {
    where: PatientsWhereUniqueInput
    create: XOR<PatientsCreateWithoutLabTestsInput, PatientsUncheckedCreateWithoutLabTestsInput>
  }

  export type DoctorsCreateWithoutLabTestsInput = {
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department: DepartmentsCreateNestedOneWithoutDoctorsInput
    appointments?: AppointmentsCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsUncheckedCreateWithoutLabTestsInput = {
    doctor_id?: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
    department_id: number
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutDoctorInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutDoctorInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorsCreateOrConnectWithoutLabTestsInput = {
    where: DoctorsWhereUniqueInput
    create: XOR<DoctorsCreateWithoutLabTestsInput, DoctorsUncheckedCreateWithoutLabTestsInput>
  }

  export type PatientsUpsertWithoutLabTestsInput = {
    update: XOR<PatientsUpdateWithoutLabTestsInput, PatientsUncheckedUpdateWithoutLabTestsInput>
    create: XOR<PatientsCreateWithoutLabTestsInput, PatientsUncheckedCreateWithoutLabTestsInput>
    where?: PatientsWhereInput
  }

  export type PatientsUpdateToOneWithWhereWithoutLabTestsInput = {
    where?: PatientsWhereInput
    data: XOR<PatientsUpdateWithoutLabTestsInput, PatientsUncheckedUpdateWithoutLabTestsInput>
  }

  export type PatientsUpdateWithoutLabTestsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUpdateManyWithoutPatientNestedInput
    bills?: BillsUpdateManyWithoutPatientNestedInput
  }

  export type PatientsUncheckedUpdateWithoutLabTestsInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUncheckedUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPatientNestedInput
    bills?: BillsUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorsUpsertWithoutLabTestsInput = {
    update: XOR<DoctorsUpdateWithoutLabTestsInput, DoctorsUncheckedUpdateWithoutLabTestsInput>
    create: XOR<DoctorsCreateWithoutLabTestsInput, DoctorsUncheckedCreateWithoutLabTestsInput>
    where?: DoctorsWhereInput
  }

  export type DoctorsUpdateToOneWithWhereWithoutLabTestsInput = {
    where?: DoctorsWhereInput
    data: XOR<DoctorsUpdateWithoutLabTestsInput, DoctorsUncheckedUpdateWithoutLabTestsInput>
  }

  export type DoctorsUpdateWithoutLabTestsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department?: DepartmentsUpdateOneRequiredWithoutDoctorsNestedInput
    appointments?: AppointmentsUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorsUncheckedUpdateWithoutLabTestsInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    department_id?: IntFieldUpdateOperationsInput | number
    appointments?: AppointmentsUncheckedUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientsCreateWithoutBillsInput = {
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsCreateNestedManyWithoutPatientInput
    insurance?: InsuranceCreateNestedManyWithoutPatientInput
    labTests?: LabTestsCreateNestedManyWithoutPatientInput
  }

  export type PatientsUncheckedCreateWithoutBillsInput = {
    patient_id?: number
    first_name: string
    last_name: string
    date_of_birth: Date | string
    gender: string
    contact_number: string
    address: string
    appointments?: AppointmentsUncheckedCreateNestedManyWithoutPatientInput
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    diagnosis?: DiagnosisUncheckedCreateNestedManyWithoutPatientInput
    treatments?: TreatmentsUncheckedCreateNestedManyWithoutPatientInput
    insurance?: InsuranceUncheckedCreateNestedManyWithoutPatientInput
    labTests?: LabTestsUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientsCreateOrConnectWithoutBillsInput = {
    where: PatientsWhereUniqueInput
    create: XOR<PatientsCreateWithoutBillsInput, PatientsUncheckedCreateWithoutBillsInput>
  }

  export type PatientsUpsertWithoutBillsInput = {
    update: XOR<PatientsUpdateWithoutBillsInput, PatientsUncheckedUpdateWithoutBillsInput>
    create: XOR<PatientsCreateWithoutBillsInput, PatientsUncheckedCreateWithoutBillsInput>
    where?: PatientsWhereInput
  }

  export type PatientsUpdateToOneWithWhereWithoutBillsInput = {
    where?: PatientsWhereInput
    data: XOR<PatientsUpdateWithoutBillsInput, PatientsUncheckedUpdateWithoutBillsInput>
  }

  export type PatientsUpdateWithoutBillsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUpdateManyWithoutPatientNestedInput
  }

  export type PatientsUncheckedUpdateWithoutBillsInput = {
    patient_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    date_of_birth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUncheckedUpdateManyWithoutPatientNestedInput
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutPatientNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutPatientNestedInput
    insurance?: InsuranceUncheckedUpdateManyWithoutPatientNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type AppointmentsCreateManyPatientInput = {
    appointment_id?: number
    doctor_id: number
    appointment_date: Date | string
    reason_for_visit: string
  }

  export type MedicalHistoryCreateManyPatientInput = {
    history_id?: number
    treatment: string
    treatment_date: Date | string
  }

  export type DiagnosisCreateManyPatientInput = {
    diagnosis_id?: number
    doctor_id: number
    diagnosis_description: string
    diagnosis_date: Date | string
  }

  export type TreatmentsCreateManyPatientInput = {
    treatment_id?: number
    doctor_id: number
    medication_id: number
    treatment_description: string
    treatment_date: Date | string
  }

  export type InsuranceCreateManyPatientInput = {
    insurance_id?: number
    provider_name: string
    policy_number: string
    coverage_amount: number
  }

  export type LabTestsCreateManyPatientInput = {
    test_id?: number
    test_name: string
    test_result: string
    test_date: Date | string
    doctor_id: number
  }

  export type BillsCreateManyPatientInput = {
    bill_id?: number
    total_amount: number
    billing_date: Date | string
    insurance_covered: boolean
    amount_paid: number
  }

  export type AppointmentsUpdateWithoutPatientInput = {
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
    doctor?: DoctorsUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentsUncheckedUpdateWithoutPatientInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentsUncheckedUpdateManyWithoutPatientInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
  }

  export type MedicalHistoryUpdateWithoutPatientInput = {
    treatment?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalHistoryUncheckedUpdateWithoutPatientInput = {
    history_id?: IntFieldUpdateOperationsInput | number
    treatment?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalHistoryUncheckedUpdateManyWithoutPatientInput = {
    history_id?: IntFieldUpdateOperationsInput | number
    treatment?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUpdateWithoutPatientInput = {
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorsUpdateOneRequiredWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutPatientInput = {
    diagnosis_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyWithoutPatientInput = {
    diagnosis_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentsUpdateWithoutPatientInput = {
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorsUpdateOneRequiredWithoutTreatmentsNestedInput
    medication?: MedicationsUpdateOneRequiredWithoutTreatmentsNestedInput
  }

  export type TreatmentsUncheckedUpdateWithoutPatientInput = {
    treatment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    medication_id?: IntFieldUpdateOperationsInput | number
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentsUncheckedUpdateManyWithoutPatientInput = {
    treatment_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    medication_id?: IntFieldUpdateOperationsInput | number
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceUpdateWithoutPatientInput = {
    provider_name?: StringFieldUpdateOperationsInput | string
    policy_number?: StringFieldUpdateOperationsInput | string
    coverage_amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InsuranceUncheckedUpdateWithoutPatientInput = {
    insurance_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    policy_number?: StringFieldUpdateOperationsInput | string
    coverage_amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InsuranceUncheckedUpdateManyWithoutPatientInput = {
    insurance_id?: IntFieldUpdateOperationsInput | number
    provider_name?: StringFieldUpdateOperationsInput | string
    policy_number?: StringFieldUpdateOperationsInput | string
    coverage_amount?: FloatFieldUpdateOperationsInput | number
  }

  export type LabTestsUpdateWithoutPatientInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorsUpdateOneRequiredWithoutLabTestsNestedInput
  }

  export type LabTestsUncheckedUpdateWithoutPatientInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor_id?: IntFieldUpdateOperationsInput | number
  }

  export type LabTestsUncheckedUpdateManyWithoutPatientInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor_id?: IntFieldUpdateOperationsInput | number
  }

  export type BillsUpdateWithoutPatientInput = {
    total_amount?: FloatFieldUpdateOperationsInput | number
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance_covered?: BoolFieldUpdateOperationsInput | boolean
    amount_paid?: FloatFieldUpdateOperationsInput | number
  }

  export type BillsUncheckedUpdateWithoutPatientInput = {
    bill_id?: IntFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance_covered?: BoolFieldUpdateOperationsInput | boolean
    amount_paid?: FloatFieldUpdateOperationsInput | number
  }

  export type BillsUncheckedUpdateManyWithoutPatientInput = {
    bill_id?: IntFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    billing_date?: DateTimeFieldUpdateOperationsInput | Date | string
    insurance_covered?: BoolFieldUpdateOperationsInput | boolean
    amount_paid?: FloatFieldUpdateOperationsInput | number
  }

  export type AppointmentsCreateManyDoctorInput = {
    appointment_id?: number
    patient_id: number
    appointment_date: Date | string
    reason_for_visit: string
  }

  export type DiagnosisCreateManyDoctorInput = {
    diagnosis_id?: number
    patient_id: number
    diagnosis_description: string
    diagnosis_date: Date | string
  }

  export type TreatmentsCreateManyDoctorInput = {
    treatment_id?: number
    patient_id: number
    medication_id: number
    treatment_description: string
    treatment_date: Date | string
  }

  export type LabTestsCreateManyDoctorInput = {
    test_id?: number
    patient_id: number
    test_name: string
    test_result: string
    test_date: Date | string
  }

  export type AppointmentsUpdateWithoutDoctorInput = {
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
    patient?: PatientsUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentsUncheckedUpdateWithoutDoctorInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentsUncheckedUpdateManyWithoutDoctorInput = {
    appointment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    appointment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason_for_visit?: StringFieldUpdateOperationsInput | string
  }

  export type DiagnosisUpdateWithoutDoctorInput = {
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientsUpdateOneRequiredWithoutDiagnosisNestedInput
  }

  export type DiagnosisUncheckedUpdateWithoutDoctorInput = {
    diagnosis_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiagnosisUncheckedUpdateManyWithoutDoctorInput = {
    diagnosis_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    diagnosis_description?: StringFieldUpdateOperationsInput | string
    diagnosis_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentsUpdateWithoutDoctorInput = {
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientsUpdateOneRequiredWithoutTreatmentsNestedInput
    medication?: MedicationsUpdateOneRequiredWithoutTreatmentsNestedInput
  }

  export type TreatmentsUncheckedUpdateWithoutDoctorInput = {
    treatment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    medication_id?: IntFieldUpdateOperationsInput | number
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentsUncheckedUpdateManyWithoutDoctorInput = {
    treatment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    medication_id?: IntFieldUpdateOperationsInput | number
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestsUpdateWithoutDoctorInput = {
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientsUpdateOneRequiredWithoutLabTestsNestedInput
  }

  export type LabTestsUncheckedUpdateWithoutDoctorInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestsUncheckedUpdateManyWithoutDoctorInput = {
    test_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    test_name?: StringFieldUpdateOperationsInput | string
    test_result?: StringFieldUpdateOperationsInput | string
    test_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorsCreateManyDepartmentInput = {
    doctor_id?: number
    first_name: string
    last_name: string
    specialty: string
    contact_number: string
  }

  export type DoctorsUpdateWithoutDepartmentInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorsUncheckedUpdateWithoutDepartmentInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentsUncheckedUpdateManyWithoutDoctorNestedInput
    diagnosis?: DiagnosisUncheckedUpdateManyWithoutDoctorNestedInput
    treatments?: TreatmentsUncheckedUpdateManyWithoutDoctorNestedInput
    labTests?: LabTestsUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorsUncheckedUpdateManyWithoutDepartmentInput = {
    doctor_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    contact_number?: StringFieldUpdateOperationsInput | string
  }

  export type TreatmentsCreateManyMedicationInput = {
    treatment_id?: number
    patient_id: number
    doctor_id: number
    treatment_description: string
    treatment_date: Date | string
  }

  export type TreatmentsUpdateWithoutMedicationInput = {
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientsUpdateOneRequiredWithoutTreatmentsNestedInput
    doctor?: DoctorsUpdateOneRequiredWithoutTreatmentsNestedInput
  }

  export type TreatmentsUncheckedUpdateWithoutMedicationInput = {
    treatment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TreatmentsUncheckedUpdateManyWithoutMedicationInput = {
    treatment_id?: IntFieldUpdateOperationsInput | number
    patient_id?: IntFieldUpdateOperationsInput | number
    doctor_id?: IntFieldUpdateOperationsInput | number
    treatment_description?: StringFieldUpdateOperationsInput | string
    treatment_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use PatientsCountOutputTypeDefaultArgs instead
     */
    export type PatientsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorsCountOutputTypeDefaultArgs instead
     */
    export type DoctorsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentsCountOutputTypeDefaultArgs instead
     */
    export type DepartmentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicationsCountOutputTypeDefaultArgs instead
     */
    export type MedicationsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicationsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientsDefaultArgs instead
     */
    export type PatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorsDefaultArgs instead
     */
    export type DoctorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentsDefaultArgs instead
     */
    export type DepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentsDefaultArgs instead
     */
    export type AppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomsDefaultArgs instead
     */
    export type RoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicalHistoryDefaultArgs instead
     */
    export type MedicalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicalHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DiagnosisDefaultArgs instead
     */
    export type DiagnosisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DiagnosisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicationsDefaultArgs instead
     */
    export type MedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TreatmentsDefaultArgs instead
     */
    export type TreatmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TreatmentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsuranceDefaultArgs instead
     */
    export type InsuranceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsuranceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabTestsDefaultArgs instead
     */
    export type LabTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabTestsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BillsDefaultArgs instead
     */
    export type BillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BillsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}